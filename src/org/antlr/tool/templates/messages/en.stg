/*
 [The "BSD licence"]
 Copyright (c) 2005-2006 Terence Parr
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
    derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
group en_US;

// TOOL ERRORS
// file errors
CANNOT_WRITE_FILE(arg,exception,stackTrace) ::= <<
cannot write file <arg>: <exception>
<stackTrace; separator="\n">
>>
CANNOT_CLOSE_FILE(arg,exception,stackTrace) ::= "cannot close file <arg>: <exception>"
CANNOT_FIND_TOKENS_FILE(arg) ::= "cannot find tokens file <arg>"
ERROR_READING_TOKENS_FILE(arg,exception,stackTrace) ::= <<
problem reading token vocabulary file <arg>: <exception>
<stackTrace; separator="\n">
>>
DIR_NOT_FOUND(arg) ::= "directory not found: <arg>"
OUTPUT_DIR_IS_FILE(arg) ::= "output directory is a file: <arg>"

INTERNAL_ERROR(arg,arg2,exception,stackTrace) ::= <<
internal error: <arg> <arg2><if(exception)>: <exception><endif>
<stackTrace; separator="\n">
>>
INTERNAL_WARNING(arg) ::= "internal warning: <arg>"
ERROR_CREATING_ARTIFICIAL_RULE(arg,exception,stackTrace) ::= <<
problems creating lexer rule listing all tokens: <exception>
<stackTrace; separator="\n">
>>
TOKENS_FILE_SYNTAX_ERROR(arg,arg2) ::= 
	"problems parsing token vocabulary file <arg> on line <arg2>"
CANNOT_GEN_DOT_FILE(arg,exception,stackTrace) ::= 
	"cannot write DFA DOT file <arg>: <exception>"
BAD_ACTION_AST_STRUCTURE(exception,stackTrace) ::=
	"bad internal tree structure for action '<arg>': <exception>"
BAD_AST_STRUCTURE(arg,exception,stackTrace) ::= <<
bad internal tree structure '<arg>': <exception>
<stackTrace; separator="\n">
>>

// code gen errors
MISSING_CODE_GEN_TEMPLATES(arg) ::= 
	"cannot find code generation templates <arg>.stg"
MISSING_CYCLIC_DFA_CODE_GEN_TEMPLATES() ::=
	"cannot find code generation cyclic DFA templates for language <arg>"
CODE_GEN_TEMPLATES_INCOMPLETE(arg) ::= 
	"at least one code generation template missing for language <arg>"
CANNOT_CREATE_TARGET_GENERATOR(arg,exception,stackTrace) ::= 
	"cannot create target <arg> code generator: <exception>"
CANNOT_COMPUTE_SAMPLE_INPUT_SEQ() ::= 
	"cannot generate a sample input sequence from lookahead DFA"

// grammar interpretation errors
/*
NO_VIABLE_DFA_ALT(arg,arg2) ::=
	"no viable transition from state <arg> on <arg2> while interpreting DFA"
*/

// bytecode problems
BYTECODE_UNKNOWN_INSTR(arg) ::= "unknown instruction '<arg>'"
BYTECODE_CANNOT_HANDLE_ILOAD_ISTORE_OPND(arg) ::= 
	"can't handle general iload/istore operand '<arg>'"
BYTECODE_CANNOT_HANDLE_ALOAD_OPND(arg) ::= 
	"can't handle general aload operand '<arg>'"
BYTECODE_CANNOT_HANDLE_LDC_OPND(arg) ::= 
	"can't handle general ldc operand '<arg>'"
BYTECODE_DUP_LABEL(arg) ::= "duplicate label ignored: '<arg>'"
BYTECODE_UNDEFINED_LABEL(arg) ::= "undefined label: '<arg>'"
BYTECODE_OPND_MISSING_QUOTE(arg) ::= "missing operand quote: '<arg>'"
BYTECODE_MISSING_METHOD(arg) ::= "missing .method instruction"
BYTECODE_MISSING_METHOD_NAME(arg) ::= "missing .method name"
BYTECODE_MISSING_METHOD_SIG(arg) ::= "missing .method signature"
BYTECODE_MISSING_METHOD_MAXSTACK(arg) ::= "missing .method maxstack value"
BYTECODE_MISSING_METHOD_MAXLOCALS(arg) ::= "missing .method locals value"

// GRAMMAR ERRORS
SYNTAX_ERROR(file,line,col,arg) ::= "<line>:<col>: syntax error: <arg>"
RULE_REDEFINITION(file,line,col,arg) ::= 
	"<loc()>rule <arg> redefinition"
LEXER_RULES_NOT_ALLOWED(file,line,col,arg) ::= 
	"<loc()>lexer rule <arg> not allowed in parser"
PARSER_RULES_NOT_ALLOWED(file,line,col,arg) ::= 
	"<loc()>parser rule <arg> not allowed in lexer"
CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL(arg) ::=
	"cannot find an attribute name in attribute declaration"
NO_TOKEN_DEFINITION(file,line,col,arg) ::= 
	"<loc()>no lexer rule corresponding to token: <arg>"
UNDEFINED_RULE_REF(file,line,col,arg) ::= 
	"<loc()>reference to undefined rule: <arg>"
LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE(file,line,col,arg) ::=
	"<loc()>literal has no associated lexer rule: <arg>"
CANNOT_ALIAS_TOKENS_IN_LEXER(file,line,col,arg) ::=
	"<loc()>literals are illegal in lexer tokens{} section: <arg>"
ATTRIBUTE_REF_NOT_IN_RULE(file,line,col,arg) ::=
	"<loc()>reference to attribute outside of a rule: <arg>"
UNKNOWN_ATTRIBUTE_IN_SCOPE(file,line,col,arg,arg2) ::=
	"<loc()>unknown attribute for <arg>: <arg2>"
UNKNOWN_RULE_ATTRIBUTE(file,line,col,arg,arg2) ::=
	"<loc()>unknown attribute for rule <arg>: <arg2>"
UNKNOWN_SIMPLE_ATTRIBUTE(file,line,col,arg,args2) ::=
	"<loc()>attribute is not a token, parameter, or return value: <arg>"
ISOLATED_RULE_SCOPE(file,line,col,arg) ::=
	"<loc()>missing attribute access on rule scope: <arg>"
INVALID_RULE_PARAMETER_REF(file,line,col,arg,arg2) ::=
	"<loc()>cannot access rule <arg>'s parameter: <arg2>"
INVALID_RULE_SCOPE_ATTRIBUTE_REF(file,line,col,arg,arg2) ::=
	"<loc()>cannot access rule <arg>'s dynamically-scoped attribute: <arg2>"
SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE(file,line,col,arg) ::=
	"<loc()>symbol <arg> conflicts with global dynamic scope with same name"
LABEL_CONFLICTS_WITH_RULE(file,line,col,arg) ::=
	"<loc()>label <arg> conflicts with rule with same name"
LABEL_CONFLICTS_WITH_TOKEN(file,line,col,arg) ::=
	"<loc()>label <arg> conflicts with token with same name"
LABEL_CONFLICTS_WITH_RULE_SCOPE_ATTRIBUTE(file,line,col,arg,arg2) ::=
	"<loc()>label <arg> conflicts with rule <arg2>'s dynamically-scoped attribute with same name"
LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL(file,line,col,arg,arg2) ::=
	"<loc()>label <arg> conflicts with rule <arg2>'s return value or parameter with same name"
ATTRIBUTE_CONFLICTS_WITH_RULE(file,line,col,arg,arg2) ::=
	"<loc()>rule <arg2>'s dynamically-scoped attribute <arg> conflicts with the rule name"
ATTRIBUTE_CONFLICTS_WITH_RULE_ARG_RETVAL(file,line,col,arg,arg2) ::=
	"<loc()>rule <arg2>'s dynamically-scoped attribute <arg> conflicts with<arg2>'s return value or parameter with same name"
LABEL_TYPE_CONFLICT(file,line,col,arg,arg2) ::=
	"<loc()>label <arg> type mismatch with previous definition: <arg2>"
ARG_RETVAL_CONFLICT(file,line,col,arg,arg2) ::=
	"<loc()>rule <arg2>'s argument <arg> conflicts a return value with same name"
NONUNIQUE_REF(file,line,col,arg) ::=
	"<loc()><arg> is a non-unique reference"
FORWARD_ELEMENT_REF(file,line,col,arg) ::=
	"<loc()>illegal forward reference: <arg>"
MISSING_RULE_ARGS(file,line,col,arg) ::=
	"<loc()>missing parameter(s) on rule reference: <arg>"
RULE_HAS_NO_ARGS(file,line,col,arg) ::=
	"<loc()>rule <arg> has no defined parameters"
ARGS_ON_TOKEN_REF(file,line,col,arg) ::=
	"<loc()>token reference <arg> may not have parameters"
/*
NONCHAR_RANGE(file,line,col) ::=
	"<loc()>range operator can only be used in the lexer"
*/
ILLEGAL_OPTION(file,line,col,arg) ::=
	"<loc()>illegal option <arg>"
LIST_LABEL_INVALID_UNLESS_RETVAL_STRUCT(file,line,col,arg) ::=
	"<loc()>rule '+=' list labels are not allowed unless building trees: <arg>"
UNDEFINED_TOKEN_REF_IN_REWRITE(file,line,col,arg) ::=
  "<loc()>reference to undefined token in rewrite rule: <arg>"
REWRITE_ELEMENT_NOT_PRESENT_ON_LHS(file,line,col,arg) ::=
  "<loc()>reference to rewrite element <arg> without reference on left of ->"
UNDEFINED_LABEL_REF_IN_REWRITE(file,line,col,arg) ::=
  "<loc()>reference to undefined label in rewrite rule: $<arg>"
NO_GRAMMAR_START_RULE (file,line,col,arg) ::=
  "grammar <arg>: no start rule (no rule can obviously be followed by EOF)"
EMPTY_COMPLEMENT(file,line,col,arg) ::= <<
<if(arg)>
<loc()>set complement ~<arg> is empty
<else>
<loc()>set complement is empty
<endif>
>>
UNKNOWN_DYNAMIC_SCOPE(file,line,col,arg) ::=
  "<loc()>unknown dynamic scope: <arg>"
UNKNOWN_DYNAMIC_SCOPE_ATTRIBUTE(file,line,col,arg,arg2) ::=
  "<loc()>unknown dynamically-scoped attribute for scope <arg>: <arg2>"
AMBIGUOUS_RULE_SCOPE(file,line,col,arg) ::=
  "<loc()>reference $<arg> is ambiguous since rule <arg> is referenced in the production and rule <arg> also has a dynamic scope"
ISOLATED_RULE_ATTRIBUTE(file,line,col,arg) ::=
  "<loc()>reference to locally-defined rule scope attribute without rule name: <arg>"
INVALID_ACTION_SCOPE(file,line,col,arg,arg2) ::=
  "<loc()>unknown or invalid action scope for <arg2> grammar: <arg>"
ACTION_REDEFINITION(file,line,col,arg) ::=
  "<loc()>redefinition of <arg> action"
DOUBLE_QUOTES_ILLEGAL(file,line,col,arg) ::=
  "<loc()>string literals must use single quotes (such as \'begin\'): <arg>"
INVALID_TEMPLATE_ACTION(file,line,col,arg) ::=
  "<loc()>invalid StringTemplate % shorthand syntax: '<arg>'"
MISSING_ATTRIBUTE_NAME(file,line,col) ::=
  "<loc()>missing attribute name on $ reference"
ARG_INIT_VALUES_ILLEGAL(file,line,col,arg) ::=
  "<loc()>rule parameters may not have init values: <arg>"
REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION(file,line,col,arg) ::=
  "<loc()>rule <arg> uses rewrite syntax or operator with no output option"

// GRAMMAR WARNINGS

GRAMMAR_NONDETERMINISM(file,line,col,input,conflictingAlts,paths,disabled) ::=
<<
<loc()><if(paths)>
Decision can match input such as "<input>" using multiple alternatives:
<paths:{  alt <it.alt> via NFA path <it.states; separator=","><\n>}>
<else>
Decision can match input such as "<input>" using multiple alternatives: <conflictingAlts; separator=", "><\n>
<endif>
<if(disabled)>
As a result, alternative(s) <disabled; separator=","> were disabled for that input
<endif>
>>

DANGLING_STATE(file,line,col,danglingAlts) ::= <<
<loc()>the decision cannot distinguish between alternative(s) <danglingAlts; separator=","> for at least one input sequence
>>

UNREACHABLE_ALTS(file,line,col,alts) ::= <<
<loc()>The following alternatives are unreachable: <alts; separator=","><\n>
>>

INSUFFICIENT_PREDICATES(file,line,col,alts) ::= <<
<loc()>The following alternatives are insufficiently covered with predicates: <alts; separator=","><\n>
>>

DUPLICATE_SET_ENTRY(file,line,col,arg) ::= 
	"<loc()>duplicate token type <arg> when collapsing subrule into set"

ANALYSIS_ABORTED(file,line,col,enclosingRule) ::= <<
<loc()>ANTLR could not analyze this decision in rule <enclosingRule> probably due to a true ambiguity in the grammar or left-recursion problems.  ANTLR re-analyzed the decision with a fixed lookahead of k=1.
>>

RECURSION_OVERLOW(file,line,col,alt,input,targetRules,callSiteStates) ::= <<
<loc()>Alternative <alt>: after matching input such as <input> decision cannot predict what comes next due to recursion overflow <targetRules,callSiteStates:{t,c|to <t> from <c:{s|<s.enclosingRule>};separator=", ">}; separator=" and ">
>>

LEFT_RECURSION(file,line,col,targetRules,alt,callSiteStates) ::= <<
<loc()>Alternative <alt> discovers infinite left-recursion <targetRules,callSiteStates:{t,c|to <t> from <c:{s|<s.enclosingRule>};separator=", ">}; separator=" and ">
>>

UNREACHABLE_TOKENS(file,line,col,tokens) ::= <<
<loc()>The following token definitions are unreachable: <tokens; separator=",">
>>

TOKEN_NONDETERMINISM(file,line,col,input,conflictingTokens,paths,disabled) ::=
<<
<loc()><if(paths)>
Decision can match input such as "<input>" using multiple alternatives:
<paths:{  alt <it.alt> via NFA path <it.states; separator=","><\n>}>
<else>
Multiple token rules can match input such as "<input>": <conflictingTokens; separator=", "><\n>
<endif>
<if(disabled)>
As a result, tokens(s) <disabled; separator=","> were disabled for that input
<endif>
>>

LEFT_RECURSION_CYCLES(listOfCycles) ::= <<
The following sets of rules are mutually left-recursive <listOfCycles:{c| [<c:{r|<r>}; separator=", ">]}; separator=" and ">
>>



/* This factors out file location formatting; file,line,col inherited from
 * enclosing template; don't manually pass stuff in.
 */
loc() ::= "<file>:<line>:<col>: "
