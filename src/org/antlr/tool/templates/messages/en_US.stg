group en_US;

// TOOL ERRORS
// file errors
CANNOT_WRITE_FILE(arg,exception) ::= "cannot write file <arg>: <exception>"
CANNOT_CLOSE_FILE(arg,exception) ::= "cannot close file <arg>: <exception>"
CANNOT_FIND_TOKENS_FILE(arg) ::= "cannot find tokens file <arg>"
ERROR_READING_TOKENS_FILE(arg,exception) ::= 
	"problem reading token vocabulary file <arg>: <exception>"

INTERNAL_ERROR(arg,arg2,exception,stackTrace) ::= <<
internal error: <arg> <arg2><if(exception)>: <exception><endif>
<stackTrace; separator="\n">
>>
INTERNAL_WARNING(arg) ::= "internal warning: <arg>"
ERROR_CREATING_ARTIFICIAL_RULE(exception) ::=
	"problems creating lexer rule listing all tokens: <exception>"
TOKENS_FILE_SYNTAX_ERROR(arg,arg2) ::= 
	"problems parsing token vocabulary file <arg> on line <arg2>"
CANNOT_GEN_DOT_FILE(arg,exception) ::= 
	"cannot write DFA DOT file <arg>: <exception>"
BAD_ACTION_AST_STRUCTURE(exception) ::=
	"bad internal tree structure for action '<arg>': <exception>"
BAD_AST_STRUCTURE(arg,exception) ::=
	"bad internal tree structure '<arg>': <exception>"

// code gen errors
MISSING_CODE_GEN_TEMPLATES(arg) ::= 
	"cannot find code generation templates for language <arg>"
MISSING_CYCLIC_DFA_CODE_GEN_TEMPLATES() ::=
	"cannot find code generation cyclic DFA templates for language <arg>"
CODE_GEN_TEMPLATES_INCOMPLETE() ::= 
	"at least one code generation template missing for language <arg>"
CANNOT_CREATE_TARGET_GENERATOR(arg,exception) ::= 
	"cannot create target <arg> code generator: <exception>"
CANNOT_COMPUTE_SAMPLE_INPUT_SEQ() ::= 
	"cannot generate a sample input sequence from lookahead DFA"

// grammar interpretation errors
/*
NO_VIABLE_DFA_ALT(arg,arg2) ::=
	"no viable transition from state <arg> on <arg2> while interpreting DFA"
*/

// bytecode problems
BYTECODE_UNKNOWN_INSTR(arg) ::= "unknown instruction '<arg>'"
BYTECODE_CANNOT_HANDLE_ILOAD_ISTORE_OPND(arg) ::= 
	"can't handle general iload/istore operand '<arg>'"
BYTECODE_CANNOT_HANDLE_ALOAD_OPND(arg) ::= 
	"can't handle general aload operand '<arg>'"
BYTECODE_CANNOT_HANDLE_LDC_OPND(arg) ::= 
	"can't handle general ldc operand '<arg>'"
BYTECODE_DUP_LABEL(arg) ::= "duplicate label ignored: '<arg>'"
BYTECODE_UNDEFINED_LABEL(arg) ::= "undefined label: '<arg>'"
BYTECODE_OPND_MISSING_QUOTE(arg) ::= "missing operand quote: '<arg>'"
BYTECODE_MISSING_METHOD(arg) ::= "missing .method instruction"
BYTECODE_MISSING_METHOD_NAME(arg) ::= "missing .method name"
BYTECODE_MISSING_METHOD_SIG(arg) ::= "missing .method signature"
BYTECODE_MISSING_METHOD_MAXSTACK(arg) ::= "missing .method maxstack value"
BYTECODE_MISSING_METHOD_MAXLOCALS(arg) ::= "missing .method locals value"

// GRAMMAR ERRORS
SYNTAX_ERROR() ::= "syntax error"
RULE_REDEFINITION(file,line,col,arg) ::= 
	"<loc()>rule <arg> redefinition"
LEXER_RULES_NOT_ALLOWED(arg) ::= 
	"<loc()>lexer rule <arg> not allowed in parser"
PARSER_RULES_NOT_ALLOWED(arg) ::= 
	"<loc()>parser rule <arg> not allowed in lexer"
CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL(arg) ::=
	"cannot find an attribute name in attribute declaration"
NO_TOKEN_DEFINITION(file,line,col,arg) ::= 
	"<loc()>no lexer rule corresponding to token: <arg>"
UNDEFINED_RULE_REF(file,line,col,arg) ::= 
	"<loc()>reference to undefined rule: <arg>"
LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE(file,line,col,arg) ::=
	"<loc()>literal has no associated lexer rule: <arg>"
CANNOT_ALIAS_TOKENS_IN_LEXER(file,line,col,arg) ::=
	"<loc()>literals are illegal in lexer tokens{} section: <arg>"
ATTRIBUTE_REF_NOT_IN_RULE(file,line,col) ::=
	"<loc()>reference to attribute outside of a rule"
UNKNOWN_ATTRIBUTE_IN_SCOPE(file,line,col,arg,arg2) ::=
	"<loc()>unknown attribute for <arg>: <arg2>"
UNKNOWN_RULE_ATTRIBUTE(file,line,col,arg,arg2) ::=
	"<loc()>unknown dynamically-scoped attribute for rule <arg>: <arg2>"
UNKNOWN_SIMPLE_ATTRIBUTE(file,line,col,arg,args2) ::=
	"<loc()>attribute is not a token, parameter, or return value: <arg>"
ISOLATED_RULE_ATTRIBUTE(file,line,col,arg) ::=
	"<loc()>missing attribute access on rule label: <arg>"
INVALID_RULE_PARAMETER_REF(file,line,col,arg,arg2) ::=
	"<loc()>cannot access rule <arg>'s parameter: <arg2>"
INVALID_RULE_SCOPE_ATTRIBUTE_REF(file,line,col,arg,arg2) ::=
	"<loc()>cannot access rule <arg>'s dynamically-scoped attribute: <arg2>"
SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE(file,line,col,arg) ::=
	"<loc()>symbol <arg> conflicts with global dynamic scope with same name"
LABEL_CONFLICTS_WITH_RULE(file,line,col,arg) ::=
	"<loc()>label <arg> conflicts with rule with same name"
LABEL_CONFLICTS_WITH_TOKEN(file,line,col,arg) ::=
	"<loc()>label <arg> conflicts with token with same name"
LABEL_CONFLICTS_WITH_RULE_SCOPE_ATTRIBUTE(file,line,col,arg,arg2) ::=
	"<loc()>label <arg> conflicts with rule <arg2>'s dynamically-scoped attribute with same name"
LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL(file,line,col,arg,arg2) ::=
	"<loc()>label <arg> conflicts with rule <arg2>'s return value or parameter with same name"
ATTRIBUTE_CONFLICTS_WITH_RULE(file,line,col,arg) ::=
	"<loc()>rule <arg>'s dynamically-scoped attribute <arg> conflicts with the rule name"
ATTRIBUTE_CONFLICTS_WITH_RULE_ARG_RETVAL(file,line,col,arg,arg2) ::=
	"<loc()>rule <arg2>'s dynamically-scoped attribute <arg> conflicts with<arg2>'s return value or parameter with same name"

// GRAMMAR WARNINGS

GRAMMAR_NONDETERMINISM(file,line,col,input,conflictingAlts,paths,disabled) ::=
<<
<loc()><if(paths)>
Decision can match input such as "<input>" using multiple alternatives:
<paths:{  alt <it.alt> via NFA path <it.states; separator=","><\n>}>
<else>
Decision can match input such as "<input>" using multiple alternatives: <conflictingAlts; separator=", "><\n>
<endif>
<if(disabled)>
As a result, alternative(s) <disabled; separator=","> were disabled for that input
<endif>
>>

DANGLING_STATE(file,line,col,danglingAlts) ::= <<
<loc()>the decision cannot distinguish between alternative(s) <danglingAlts; separator=","> for at least one input sequence
>>

UNREACHABLE_ALTS(file,line,col,alts) ::= <<
<loc()>The following alternatives are unreachable: <alts; separator=","><\n>
>>

INSUFFICIENT_PREDICATES(file,line,col,alts) ::= <<
<loc()>The following alternatives are insufficiently covered with predicates: <alts; separator=","><\n>
>>

DUPLICATE_SET_ENTRY(file,line,col,arg) ::= 
	"<loc()>duplicate token type <arg> when collapsing subrule into set"

ANALYSIS_ABORTED(file,line,col) ::= <<
<loc()>ANTLR could not analyze this decision probably due to a true ambiguity in the grammar.  ANTLR re-analyzed the decision with a fixed lookahead of k=1.
>>

/* This factors out file location formatting; file,line,col inherited from
 * enclosing template; don't manually pass stuff in.
 */
loc() ::= "<file>:<line>:<col>: "
