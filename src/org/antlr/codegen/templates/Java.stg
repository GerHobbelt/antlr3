group Java;

// G R A M M A R  E L E M E N T S

outputFile(LEXER,PARSER,TREE_PARSER, headerAction, docComment, recognizer,
           name, tokens, rules, cyclicDFAs) ::=
<<
<headerAction>

import org.antlr.runtime.*;
import java.util.*;

<docComment>
<recognizer><\n>
>>

headerFile(name, tokens, rules, cyclicDFAs) ::= <<
// header for <name>
<tokens:{const int <attr.name>=<attr.type>;<\n>}>
<rules:{extern void <it.name>(<it.args>);<\n>}>
>>

lexer(name, tokens, rules, cyclicDFAs) ::= <<
class <name> extends Lexer {
    <tokens:{public static final int <attr.name>=<attr.type>;}; separator="\n">
    public <name>(CharStream input) {
        super(input);
    }
    public Token nextToken() {
		if ( input.LA(1)==CharStream.EOF ) {
			return Token.EOFToken;
		}
		token=null;
		mTokens();
        return token;
    }

    <rules; separator="\n">
}
>>

parser(name, tokens, rules, cyclicDFAs) ::= <<
class <name> extends Parser {
    <tokens:{public static final int <attr.name>=<attr.type>;}; separator="\n">
    public <name>(TokenStream input) {
        super(input);
    }
    <rules; separator="\n">
}
>>

rule(ruleName,args,block,enterAction,exitAction) ::= <<
public void <ruleName>(<args>)
<if(enterAction)>
{
    <enterAction>
    <block>
    <exitAction>
}
<else>
{
	<block>
}
<endif>
>>

lexerRule(ruleName,nakedBlock,args,block,enterAction,exitAction) ::= <<
public void m<ruleName>(<args>)
{
<if(nakedBlock)>
	<block><\n>
<else>
    int type = <ruleName>;
    int start = getCharIndex();
    int line = getLine();
    int charPosition = getCharPositionInLine();
    int channel = Token.DEFAULT_CHANNEL;
	<block>
    if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}<\n>
<endif>
}
>>

blockSingleAlt(alts,decls,decision,decisionNumber,preamble) ::= <<
<preamble><decls><alts>
>>

block(alts,decls,decision,decisionNumber,preamble,maxK) ::= <<
<preamble>
int alt<decisionNumber>=0;
<decls>
<decision>
switch (alt<decisionNumber>) {
    <alts:altSwitchCase()>
}
>>

positiveClosureBlock(alts,decls,decision,decisionNumber,maxK) ::= <<
    int alt<decisionNumber>=0;
    int cnt<decisionNumber>=0;
    <decls>
loop<decisionNumber>:
    do {
        <decision>
        switch (alt<decisionNumber>) {
            <alts:altSwitchCase()>
            default :
		if ( cnt<decisionNumber> >= 1 ) break loop<decisionNumber>;
                <if(LEXER)>
		else System.err.println("line "+getLine()+": no viable alt in decision <decisionNumber> LA(1)=="+(char)input.LA(1));<\n>
                <else>
		else System.err.println("no viable alt in decision <decisionNumber> LT(1)=="+((TokenStream)input).LT(1).toString(((CommonTokenStream)input).getTokenSource().getCharStream()));<\n>
                <endif>
        }
        cnt<decisionNumber>++;
    } while (true);
>>

positiveClosureBlockSingleAlt ::= positiveClosureBlock

closureBlock(alts,decls,decision,decisionNumber,maxK) ::= <<
    int alt<decisionNumber>=0;
    <decls>
loop<decisionNumber>:
    do {
        <decision>
        switch (alt<decisionNumber>) {
            <alts:altSwitchCase()>
            default :
                break loop<decisionNumber>;
        }
    } while (true);
>>

closureBlockSingleAlt ::= closureBlock

optionalBlock ::= block

optionalBlockSingleAlt ::= block

altSwitchCase() ::= <<
case <i> :
    <attr>
    break;<\n>
>>

alt(elements) ::= "<elements; separator=\"\n\">"

tokenRef(token) ::= "match(<token>);"

charRef(char) ::= "match(<char>);"

charRangeRef(a,b) ::= "matchRange(<a>,<b>);"

matchSet(s) ::= <<
if ( !(<s>) ) System.err.println("set mismatch line "+getLine()+": '"+(char)input.LA(1)+"'");
input.consume();<\n>
>>

matchNotSet(s) ::= <<
if ( <s> ) System.err.println("~set mismatch line "+getLine()+": '"+(char)input.LA(1)+"'");
input.consume();
>>

lexerStringRef(string) ::= "match(<string>);"

wildcard() ::= "matchAny();"

wildcardChar() ::= "matchAny();"

ruleRef(rule,args) ::= "<rule>(<args>);"

lexerRuleRef(rule,args) ::= "m<rule>(<args>);"


// F i x e d  D F A  s t u f f

dfaDecision(decisionNumber,description) ::=
  "alt<decisionNumber> = DFA<decisionNumber>.predict(input);"

dfaState(edges,defaultClause,eotPredictsAlt,description) ::= <<
<edges; separator="else ">
else {
<if(eotPredictsAlt)>
    alt<decisionNumber>=<eotPredictsAlt>;
<else>
<if(LEXER)>
    System.err.println("<description>: no viable alt line "+getLine()+" c='"+(char)input.LA(1)+"'");<\n>
<else>
    System.err.println("<description>: no viable alt line token="+((TokenStream)input).LT(1).toString(((CommonTokenStream)input).getTokenSource().getCharStream()));<\n>
<endif>
    input.consume();<\n>
<endif>
}
>>

dfaAcceptState(alt) ::= "alt<decisionNumber>=<alt>;"

dfaEdge(labelExpr, targetState) ::= <<
if ( <labelExpr> ) {
    <targetState>
}
>>

// D F A  E X P R E S S I O N S

andPredicates(left,right) ::= "(<left>&&<right>)"

orPredicates(left,right) ::= "(<left>||<right>)"

notPredicate(pred) ::= "!(<pred>)"

lookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::=
	"(input.LA(<k>)>=<lower> && input.LA(<k>)\<=<upper>)"

setTest(ranges) ::= "<ranges; separator=\"||\">"

// A C T I O N S

emit(type) ::= "emit(<type>);"

setType(type) ::= "setType(<type>);"


// M I S C (properties, etc...)

codeFileExtension() ::= ".java"
