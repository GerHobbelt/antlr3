group Java;

// G R A M M A R  E L E M E N T S

outputFile(LEXER,PARSER,TREE_PARSER, headerAction, docComment, recognizer,
           name, tokens, tokenNames, rules, cyclicDFAs, bitsets,
           debug, predicates) ::=
<<
<headerAction>

import org.antlr.runtime.*;
import java.util.Stack;

<docComment>
<recognizer>
>>

lexer(name, tokens, globalAction, rules, cyclicDFAs, predicates) ::= <<
class <name> extends Lexer {
    <tokens:{public static final int <it.name>=<it.type>;}; separator="\n">
    <globalAction>
    public <name>(CharStream input) {
        super(input);
    }
    public Token nextToken() {
        token=null;
retry:
        while (true) {
	        if ( input.LA(1)==CharStream.EOF ) {
        	    return Token.EOFToken;
	        }	
            try {
                mTokens();
                break retry;
            }
            catch (RecognitionException re) {
                reportError(re);
				recover(re);
            }
        }
        return token;
    }

    <rules; separator="\n\n">

    <cyclicDFAs>

    <predicates; separator="\n">
}
>>

parser(name, scopes, tokens, tokenNames, globalAction, rules, cyclicDFAs, bitsets, predicates) ::= <<
class <name> extends <if(debug)>DebugParser<else>Parser<endif> {
    public static final String[] tokenNames = new String[] {
        "\<invalid>", "\<EOR>", <tokenNames; separator=", ">
    };
    <tokens:{public static final int <it.name>=<it.type>;}; separator="\n">
    <scopes:{<if(it.isGlobal)><attributeScope(scope=it)><endif>}>
    public <name>(TokenStream input) { super(input); }
<if(debug)>
    public <name>(TokenStream input, ANTLRDebugInterface dbg) {
        super(input,dbg);
    }<\n>
<endif>
    public String[] getTokenNames() { return tokenNames; }

    <globalAction>

    <rules; separator="\n\n">

    <predicates; separator="\n">

    <cyclicDFAs>

    <bitsets:bitset(name="FOLLOW_"+it.name+"_in_"+it.inName+it.tokenIndex, words64=it.bits)>
}
>>

attributeScope(scope) ::= <<
// scope <scope.name>
protected static class static_scope_<scope.name> {
    <scope.attributes:{<if(it.isStatic)><it.decl>;<endif>}; separator="\n">
}
static_scope_<scope.name> static_<scope.name> = new static_scope_<scope.name>();
protected static class scope_<scope.name> {
    <scope.attributes:{<if(!it.isStatic)><it.decl>;<endif>}; separator="\n">
}
protected Stack stack_<scope.name> = new Stack();<\n>
>>

returnScope(scope) ::= <<
<scope.attributes:{<if(it.isStatic)><it.decl>;<endif>}; separator="\n">
protected static class scope_<scope.name> {
    Token start=null, stop=null;
    <scope.attributes:{<if(!it.isStatic)><it.decl>;<endif>}; separator="\n">
};
>>

parameterScope(scope) ::= <<
<scope.attributes:{<it.decl>}; separator=", ">
>>

/** Used in codegen.g to translate @x.y references.
 *  I could have left actions as StringTemplates to be inserted in
 *  the output (so they could use attributes inherited from surrounding
 *  templates), but really wanted to pass in AttributeScope and Attribute
 *  objects so this translation could query them.  So, translation of
 *  @x.y to executable code occurs before recognizerST.toString() occurs.
 *  I.e., actions are just text strings during final code generation.
 */
globalAttributeRef(scope,attr) ::= <<
<if(attr.isStatic)>
static_<scope.name>.<attr.name>
<else>
((scope_<scope.name>)stack_<scope.name>.peek()).<attr.name>
<endif>
>>

scopeRef(scope) ::= "((scope_<scope.name>)stack_<scope.name>.peek())"

parameterAttributeRef(scope,attr) ::= "<attr.name>"

returnAttributeRef(scope,attr) ::= "retval.<attr.name>"

ruleAttributeRef ::= globalAttributeRef

/** How to translate @label */
tokenLabelRef(label) ::= "<label>"

// not sure the next are the right approach

tokenLabelPropertyRef_text(label) ::= "<label>.getText(input.getTokenSource().getCharStream())"
tokenLabelPropertyRef_type(label) ::= "<label>.getType()"
tokenLabelPropertyRef_line(label) ::= "<label>.getLine()"
tokenLabelPropertyRef_pos(label) ::= "<label>.getCharPositionInLine()"
tokenLabelPropertyRef_channel(label) ::= "<label>.getChannel()"
tokenLabelPropertyRef_index(label) ::= "<label>.getTokenIndex()"

ruleLabelPropertyRef_start(label) ::= "<label>.start"
ruleLabelPropertyRef_stop(label) ::= "<label>.stop"
ruleLabelPropertyRef_tree(label) ::= "<label>.tree"

bitset(name, words64) ::= <<
public static final BitSet <name> = new BitSet(new long[]{<words64:{<it>L};separator=",">});<\n>
>>

rule(ruleName,ruleDescriptor,initAction,block) ::= <<
<ruleDescriptor.ruleScope:attributeScope(scope=it)>
<ruleDescriptor.returnScope:returnScope(scope=it)>
// $ANTLR start <ruleName>
public <if(ruleDescriptor.returnScope)>scope_<ruleName>_return<else>void<endif> <ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) throws RecognitionException {   
    <ruleDescriptor.useScopes:{stack_<it>.push(new scope_<it>());}; separator="\n">
    <ruleDescriptor.ruleScope:{stack_<it.name>.push(new scope_<it.name>());}; separator="\n">
    <ruleDescriptor.returnScope:{scope_<it.name> retval = new scope_<it.name>();<\n>retval.start = input.LT(1);}; separator="\n">
    <ruleDescriptor.tokenLabels:{Token <it.label.text>=null;}; separator="\n">
    <ruleDescriptor.ruleLabels:{scope_<it.elementRef.text>_return <it.label.text>=null;}; separator="\n">
    <initAction>
<if(debug)>
    dbg.enterRule("<ruleName>");
    dbg.location(<ruleDescriptor.tree.line>, <ruleDescriptor.tree.column>);<\n>
<endif>
    try {
        <block>
    }
    catch (RecognitionException re) {
        reportError(re);
        errorRecovery = true;
        recover(re);
    }
    finally {
        <ruleDescriptor.useScopes:{stack_<it>.pop();}; separator="\n">
        <ruleDescriptor.ruleScope:{stack_<it.name>.pop();}; separator="\n">
        retval.stop = input.LT(0);
    }<\n>
<if(debug)>
    dbg.exitRule("<ruleName>");<\n>
<endif>
<if(ruleDescriptor.returnScope)>
    return retval;<\n>
<endif>
}
// $ANTLR end <ruleName>
>>

tokensRule(ruleName,nakedBlock,args,block) ::= <<
public void mTokens() throws RecognitionException {
    <block><\n>
}
>>

lexerRule(ruleName,nakedBlock,args,initAction,block) ::= <<
public void m<ruleName>(<args>) throws RecognitionException {
<initAction>
<if(nakedBlock)>
    <block><\n>
<else>
    int type = <ruleName>;
    int start = getCharIndex();
    int line = getLine();
    int charPosition = getCharPositionInLine();
    int channel = Token.DEFAULT_CHANNEL;
    <block>
    if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}<\n>
<endif>
}
>>

blockSingleAlt(alts,decls,decision,decisionNumber) ::= <<
<if(debug)>
dbg.enterAlt(1);<\n>
<endif>
<decls><alts>
>>

block(alts,decls,decision,decisionNumber,maxK,maxAlt) ::= <<
int alt<decisionNumber>=<maxAlt>;
<decls>
<if(debug)>
dbg.enterSubRule();<\n>
<endif>
<decision>
switch (alt<decisionNumber>) {
    <alts:altSwitchCase()>
}
<if(debug)>
dbg.exitSubRule();<\n>
<endif>
>>

ruleBlockSingleAlt ::= blockSingleAlt

ruleBlock(alts,decls,decision,decisionNumber,maxK,maxAlt) ::= <<
int alt<decisionNumber>=<maxAlt>;
<decls>
<decision>
switch (alt<decisionNumber>) {
    <alts:altSwitchCase()>
}
>>

positiveClosureBlock(alts,decls,decision,decisionNumber,maxK,maxAlt) ::= <<
int cnt<decisionNumber>=0;
<decls>
<if(debug)>
dbg.enterSubRule();<\n>
<endif>
loop<decisionNumber>:
do {
    int alt<decisionNumber>=<maxAlt>;
    <decision>
    switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
	default :
	    if ( cnt<decisionNumber> >= 1 ) break loop<decisionNumber>;
	    throw new EarlyExitException(<decisionNumber>, input);
    }
    cnt<decisionNumber>++;
} while (true);
<if(debug)>
dbg.exitSubRule();<\n>
<endif>
>>

positiveClosureBlockSingleAlt ::= positiveClosureBlock

closureBlock(alts,decls,decision,decisionNumber,maxK,maxAlt) ::= <<
<decls>
<if(debug)>
dbg.enterSubRule();<\n>
<endif>
loop<decisionNumber>:
do {
    int alt<decisionNumber>=<maxAlt>;
    <decision>
    switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
	default :
	    break loop<decisionNumber>;
    }
} while (true);
<if(debug)>
dbg.exitSubRule();<\n>
<endif>
>>

closureBlockSingleAlt ::= closureBlock

optionalBlock ::= block

optionalBlockSingleAlt ::= block

altSwitchCase() ::= <<
case <i> :
<if(debug)>
    dbg.enterAlt(<i>);<\n>
<endif>
    <it>
    break;<\n>
>>

alt(elements) ::= "<elements:element()>"

element() ::= <<
<if(debug)>
dbg.location(<it.line>,<it.pos>);<\n>
<endif>
<it.el><\n>
>>

tokenRef(token,label,elementIndex) ::= <<
<if(label)><label>=input.LT(1);<endif>
match(<token>,FOLLOW_<token>_in_<ruleName><elementIndex>);
>>

charRef(char) ::= "match(<char>);"

charRangeRef(a,b) ::= "matchRange(<a>,<b>);"

/** For now, sets are interval tests and must be tested inline */
matchSet(s,label) ::= <<
<if(label)><label>=input.LT(1);<endif>
if ( <s> ) input.consume();
else throw new MismatchedSetException(null,input);<\n>
>>

matchNotSet(s,label) ::= <<
<if(label)><label>=input.LT(1);<endif>
if ( !(<s>) ) input.consume();
else throw new MismatchedNotSetException(null,input);<\n>
>>

lexerStringRef(string) ::= "match(<string>);"

wildcard(label) ::= <<
<if(label)><label>=input.LT(1);<endif>
matchAny();
>>

wildcardChar() ::= "matchAny();"

ruleRef(rule,label,elementIndex,args) ::= <<

following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<if(label)>
<label>=<rule>(<args>);<\n>
<else>
<rule>(<args>);<\n>
<endif>
following.pop();
>>

lexerRuleRef(rule,args) ::= "m<rule>(<args>);"


// F i x e d  D F A  (if-then-else)

/*
dfaDecision(decisionNumber,description) ::=
  "alt<decisionNumber> = DFA<decisionNumber>.predict(input);"
*/

dfaState(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
int LA<decisionNumber>_<stateNumber> = input.LA(<k>);
<edges; separator="\nelse ">
else {
<if(eotPredictsAlt)>
    alt<decisionNumber>=<eotPredictsAlt>;
<else>
<if(LEXER)>
    System.err.println("<description>: no viable alt line "+((CharStream)input).getLine()+" c='"+(char)input.LA(1)+"'");
<else>
    System.err.println("<description>: no viable alt line token="+((TokenStream)input).LT(1));
    throw new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
<endif>
<endif>
}
>>

dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
int LA<decisionNumber>_<stateNumber> = input.LA(<k>);
<edges; separator="\nelse ">
>>

dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
int LA<decisionNumber>_<stateNumber> = input.LA(<k>);
<edges; separator="\nelse "><\n>
<if(eotPredictsAlt)>
else {
    alt<decisionNumber>=<eotPredictsAlt>;
}<\n>
<endif>
>>

dfaAcceptState(alt) ::= "alt<decisionNumber>=<alt>;"

dfaEdge(labelExpr, targetState) ::= <<
if ( <labelExpr> ) {
    <targetState>
}
>>

// F i x e d  D F A  (switch case)

dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
switch ( input.LA(<k>) ) {
<edges; separator="\n">
default:
<if(eotPredictsAlt)>
    alt<decisionNumber>=<eotPredictsAlt>;
<else>
    throw new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
<endif>
}<\n>
>>

dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
switch ( input.LA(<k>) ) {
    <edges; separator="\n">
}<\n>
>>

dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber) ::= <<
switch ( input.LA(<k>) ) {
<edges; separator="\n"><\n>
<if(eotPredictsAlt)>
default:
    alt<decisionNumber>=<eotPredictsAlt>;
    break;<\n>
<endif>
}<\n>
>>

dfaEdgeSwitch(labels, targetState) ::= <<
<labels:{case <it>:}; separator="\n">
    <targetState>
    break;
>>

// C y c l i c  D F A

allCyclicDFAs(cyclicDFAs) ::= <<
>>

dfaDecision(decisionNumber,description) ::= <<
int m<decisionNumber> = input.mark();
<! the <name> attribute is inherited via the parser, lexer, ... !>
alt<decisionNumber> = DFA<decisionNumber>.predict(input);
input.rewind(m<decisionNumber>);
>>

cyclicDFA(className,decisionNumber,states,description) ::= <<
static class DFA<decisionNumber> extends DFA {
    public static int predict(IntStream input) throws RecognitionException {
        return predict(input, s0);
    }
    <states>
}
>>

cyclicDFAState(stateNumber,edges,needErrorClause) ::= <<
static DFA.State s<stateNumber> = new DFA.State() {
    public DFA.State transition(IntStream input) throws RecognitionException {
        int LA<decisionNumber>_<stateNumber> = input.LA(1);
        <edges>
        <if(needErrorClause)>
        <if(LEXER)>
        System.err.println("no viable alt line "+((CharStream)input).getLine()+" c='"+(char)input.LA(1)+"'");
	throw new NoViableAltException("<description>", 0, <stateNumber>, input);<\n>
        <else>
        System.err.println("<description>: no viable alt line token="+((TokenStream)input).LT(1));
	throw new NoViableAltException("<description>", 0, <stateNumber>, input);<\n>
        <endif>
        <endif>
    }
};<\n>
>>

cyclicDFAAcceptState(stateNumber,predictAlt) ::= <<
static DFA.State s<stateNumber> = new DFA.State() {{alt=<predictAlt>;}};<\n>
>>

cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber) ::= <<
if ( <labelExpr> ) {return s<targetStateNumber>;}<\n>
>>

eotDFAEdge(targetStateNumber,edgeNumber) ::= <<
return s<targetStateNumber>;<\n>
>>

// C y c l i c  S W I T C H

cyclicDFAStateSwitch(stateNumber,labels,edges,
                     needErrorClause,EOTTargetStateNumber) ::= <<
static DFA.State s<stateNumber> = new DFA.State() {
    public DFA.State transition(IntStream input) throws RecognitionException {
        switch ( input.LA(1) ) {
        <edges; separator="\n">
        default:
<if(needErrorClause)>
            throw new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
<else>
            return s<EOTTargetStateNumber>;<\n>	
<endif>
        }
    }
};<\n>
>>

cyclicDFAEdgeSwitch(labels, targetStateNumber, edgeNumber) ::= <<
<labels:{case <it>:}; separator="\n">
    return s<targetStateNumber>;<\n>
>>

singlePredicateMethod(decision,stateNumber,edgeNumber,pred) ::= <<
public boolean pred_DFA<decision>s<stateNumber>e<edgeNumber>() {return <pred>;}
>>

// D F A  E X P R E S S I O N S

andPredicates(left,right) ::= "(<left>&&<right>)"

orPredicates(left,right) ::= "(<left>||<right>)"

notPredicate(pred) ::= "!(<pred>)"

singlePredicate(pred) ::= "<pred>"

/** because generation of pred code and reference to it may be different,
 *  have a way to invoke predicates; they could be placed in methods
 *  somewhere, for example.  For acyclic DFAs, this method just directly
 *  evals the pred inline.
 */
invokePredicate(pred) ::= "<pred>"

/** If this template exists, then build methods for acylic DFAs
singlePredicateMethod(decision,stateNumber,edgeNumber,pred) ::= "...";
 */

lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"

isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <<
(LA<decisionNumber>_<stateNumber>\>=<lower> && LA<decisionNumber>_<stateNumber>\<=<upper>)
>>

isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)\>=<lower> && input.LA(<k>)\<=<upper>)"

setTest(ranges) ::= "<ranges; separator=\"||\">"

// A C T I O N S

emit(type) ::= "emit(<type>);"

setType(type) ::= "setType(<type>);"


// M I S C (properties, etc...)

codeFileExtension() ::= ".java"
