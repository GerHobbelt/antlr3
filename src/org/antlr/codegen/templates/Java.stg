group Java;

// G R A M M A R  E L E M E N T S

outputFile(LEXER,PARSER,TREE_PARSER, headerAction, docComment, recognizer,
           name, tokens, rules, cyclicDFAs, bitsets) ::=
<<
<headerAction>

import org.antlr.runtime.*;

<docComment>
<recognizer><\n>
>>

lexer(name, tokens, rules, cyclicDFAs) ::= <<
class <name> extends Lexer {
    <tokens:{public static final int <attr.name>=<attr.type>;}; separator="\n">
    public <name>(CharStream input) {
        super(input);
    }
    public Token nextToken() {
        if ( input.LA(1)==CharStream.EOF ) {
            return Token.EOFToken;
        }
        token=null;
retry:
        while (true) {
            try {
                mTokens();
                break retry;
            }
            catch (RecognitionException re) {
                reportError(re);
		recover(re);
            }
        }
        return token;
    }

    <rules; separator="\n\n">
}
>>

parser(name, tokens, rules, cyclicDFAs, bitsets) ::= <<
class <name> extends Parser {
    <tokens:{public static final int <attr.name>=<attr.type>;}; separator="\n">
    public <name>(TokenStream input) {
        super(input);
    }
    <rules; separator="\n\n">
    <bitsets:bitset(name="FOLLOW_"+it.name+"_in_"+it.inName+it.tokenIndex, words64=it.bits)>
}
>>

bitset(name, words64) ::= <<
public static final BitSet <name> = new BitSet(new long[]{<words64:{<it>L};separator=",">});<\n>
>>

rule(ruleName,args,block,enterAction,exitAction) ::= <<
public void <ruleName>(<args>) throws RecognitionException {   
<if(enterAction)>
    <enterAction><\n>
<endif>
    try {
        <block>
    }
    catch (RecognitionException re) {
        reportError(re);
        recover(re);
    }
<if(exitAction)>
    finally {
        <exitAction><\n>
    }<\n>
<endif>
}
>>

tokensRule(ruleName,nakedBlock,args,block,enterAction,exitAction) ::= <<
public void mTokens() throws RecognitionException {
    <block><\n>
}
>>

lexerRule(ruleName,nakedBlock,args,block,enterAction,exitAction) ::= <<
public void m<ruleName>(<args>) throws RecognitionException {
<if(nakedBlock)>
    <block><\n>
<else>
    int type = <ruleName>;
    int start = getCharIndex();
    int line = getLine();
    int charPosition = getCharPositionInLine();
    int channel = Token.DEFAULT_CHANNEL;
    <block>
    if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}<\n>
<endif>
}
>>

blockSingleAlt(alts,decls,decision,decisionNumber,preamble) ::= <<
<preamble><decls><alts>
>>

block(alts,decls,decision,decisionNumber,preamble,maxK) ::= <<
<preamble>
int alt<decisionNumber>=0;
<decls>
<decision>
switch (alt<decisionNumber>) {
    <alts:altSwitchCase()>
}
>>

positiveClosureBlock(alts,decls,decision,decisionNumber,maxK) ::= <<
int cnt<decisionNumber>=0;
<decls>
loop<decisionNumber>:
do {
    int alt<decisionNumber>=0;
    <decision>
    switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
	default :
	    if ( cnt<decisionNumber> >= 1 ) break loop<decisionNumber>;
	    throw new EarlyExitException(<decisionNumber>);
    }
    cnt<decisionNumber>++;
} while (true);
>>

positiveClosureBlockSingleAlt ::= positiveClosureBlock

closureBlock(alts,decls,decision,decisionNumber,maxK) ::= <<
<decls>
loop<decisionNumber>:
do {
    int alt<decisionNumber>=0;
    <decision>
    switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
	default :
	    break loop<decisionNumber>;
    }
} while (true);
>>

closureBlockSingleAlt ::= closureBlock

optionalBlock ::= block

optionalBlockSingleAlt ::= block

altSwitchCase() ::= <<
case <i> :
    <attr>
    break;<\n>
>>

alt(elements) ::= "<elements; separator=\"\n\">"

tokenRef(token) ::= "match(<token>);"

charRef(char) ::= "match(<char>);"

charRangeRef(a,b) ::= "matchRange(<a>,<b>);"

/** For now, sets are interval tests and must be tested inline */
matchSet(s) ::= <<
if ( <s> ) input.consume();
else throw new MismatchedSetException("<s>");<\n>
>>

matchNotSet(s) ::= <<
if ( !(<s>) ) input.consume();
else throw new MismatchedNotSetException("");<\n>
>>

lexerStringRef(string) ::= "match(<string>);"

wildcard() ::= "matchAny();"

wildcardChar() ::= "matchAny();"

ruleRef(rule,tokenIndex,args) ::= <<
<if(!LEXER)>
following.push(FOLLOW_<rule>_in_<ruleName><tokenIndex>);
<rule>(<args>);
following.pop();
<else>
<rule>(<args>);<\n>
<endif>
>>

lexerRuleRef(rule,args) ::= "m<rule>(<args>);"


// F i x e d  D F A  s t u f f

dfaDecision(decisionNumber,description) ::=
  "alt<decisionNumber> = DFA<decisionNumber>.predict(input);"

dfaState(edges,defaultClause,eotPredictsAlt,description,stateNumber) ::= <<
<edges; separator="else ">
else {
<if(eotPredictsAlt)>
    alt<decisionNumber>=<eotPredictsAlt>;
<else>
    throw new NoViableAltException("<description>", <decisionNumber>, <stateNumber>);<\n>
<endif>
}
>>

dfaAcceptState(alt) ::= "alt<decisionNumber>=<alt>;"

dfaEdge(labelExpr, targetState) ::= <<
if ( <labelExpr> ) {
    <targetState>
}
>>

// D F A  E X P R E S S I O N S

andPredicates(left,right) ::= "(<left>&&<right>)"

orPredicates(left,right) ::= "(<left>||<right>)"

notPredicate(pred) ::= "!(<pred>)"

lookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::=
	"(input.LA(<k>)>=<lower> && input.LA(<k>)\<=<upper>)"

setTest(ranges) ::= "<ranges; separator=\"||\">"

// A C T I O N S

emit(type) ::= "emit(<type>);"

setType(type) ::= "setType(<type>);"


// M I S C (properties, etc...)

codeFileExtension() ::= ".java"
