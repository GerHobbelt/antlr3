group Java;

// G R A M M A R  E L E M E N T S

outputFile(LEXER,PARSER,TREE_PARSER, headerAction, docComment, recognizer,
           name, tokens, tokenNames, rules, cyclicDFAs, bitsets) ::=
<<
<headerAction>

import org.antlr.runtime.*;
import java.util.Stack;

<docComment>
<recognizer><\n>
>>

lexer(name, tokens, globalAction, rules, cyclicDFAs) ::= <<
class <name> extends Lexer {
    <tokens:{public static final int <it.name>=<it.type>;}; separator="\n">
    <globalAction>
    public <name>(CharStream input) {
        super(input);
    }
    public Token nextToken() {
        if ( input.LA(1)==CharStream.EOF ) {
            return Token.EOFToken;
        }
        token=null;
retry:
        while (true) {
            try {
                mTokens();
                break retry;
            }
            catch (RecognitionException re) {
                reportError(re);
		recover(re);
            }
        }
        return token;
    }

    <rules; separator="\n\n">
}
>>

parser(name, scopes, tokens, tokenNames, globalAction, rules, cyclicDFAs, bitsets) ::= <<
class <name> extends Parser {
    public static final String[] tokenNames = new String[] {
        "\<invalid>", "\<EOR>", <tokenNames; separator=", ">
    };
    <tokens:{public static final int <it.name>=<it.type>;}; separator="\n">
    <scopes:{<if(it.isGlobal)><attributeScope(scope=it)><endif>}>
    public <name>(TokenStream input) { super(input); }
    public String[] getTokenNames() { return tokenNames; }

    <globalAction>
    <rules; separator="\n\n">
    <bitsets:bitset(name="FOLLOW_"+it.name+"_in_"+it.inName+it.tokenIndex, words64=it.bits)>
}
>>

attributeScope(scope) ::= <<
// scope <scope.name>
protected static class static_scope_<scope.name> {
    <scope.attributes:{<if(it.isStatic)><it.decl>;<endif>}; separator="\n">
}
static_scope_<scope.name> static_<scope.name> = new static_scope_<scope.name>();
protected static class scope_<scope.name> {
    <scope.attributes:{<if(!it.isStatic)><it.decl>;<endif>}; separator="\n">
}
protected Stack stack_<scope.name> = new Stack();<\n>
>>

returnScope(scope) ::= <<
<scope.attributes:{<if(it.isStatic)><it.decl>;<endif>}; separator="\n">
protected static class scope_<scope.name> {
    Token start=null, stop=null;
    <scope.attributes:{<if(!it.isStatic)><it.decl>;<endif>}; separator="\n">
};
>>

parameterScope(scope) ::= <<
<scope.attributes:{<it.decl>}; separator=", ">
>>

/** Used in codegen.g to translate @x.y references.
 *  I could have left actions as StringTemplates to be inserted in
 *  the output (so they could use attributes inherited from surrounding
 *  templates), but really wanted to pass in AttributeScope and Attribute
 *  objects so this translation could query them.  So, translation of
 *  @x.y to executable code occurs before recognizerST.toString() occurs.
 *  I.e., actions are just text strings during final code generation.
 */
globalAttributeRef(scope,attr) ::= <<
<if(attr.isStatic)>
static_<scope.name>.<attr.name>
<else>
((scope_<scope.name>)stack_<scope.name>.peek()).<attr.name>
<endif>
>>

scopeRef(scope) ::= "((scope_<scope.name>)stack_<scope.name>.peek())"

parameterAttributeRef(scope,attr) ::= "<attr.name>"

returnAttributeRef(scope,attr) ::= "retval.<attr.name>"

ruleAttributeRef ::= globalAttributeRef

/** How to translate @label */
tokenLabelRef(label) ::= "<label>"

// not sure the next are the right approach

tokenLabelPropertyRef_text(label) ::= "<label>.getText(input.getTokenSource().getCharStream())"
tokenLabelPropertyRef_type(label) ::= "<label>.getType()"
tokenLabelPropertyRef_line(label) ::= "<label>.getLine()"
tokenLabelPropertyRef_pos(label) ::= "<label>.getCharPositionInLine()"
tokenLabelPropertyRef_channel(label) ::= "<label>.getChannel()"
tokenLabelPropertyRef_index(label) ::= "<label>.getTokenIndex()"

ruleLabelPropertyRef_start(label) ::= "<label>.start"
ruleLabelPropertyRef_stop(label) ::= "<label>.stop"
ruleLabelPropertyRef_tree(label) ::= "<label>.tree"

bitset(name, words64) ::= <<
public static final BitSet <name> = new BitSet(new long[]{<words64:{<it>L};separator=",">});<\n>
>>

rule(ruleName,ruleDescriptor,initAction,block,enterAction,exitAction) ::= <<
<ruleDescriptor.ruleScope:attributeScope(scope=it)>
<ruleDescriptor.returnScope:returnScope(scope=it)>
public <if(ruleDescriptor.returnScope)>scope_<ruleName>_return<else>void<endif> <ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) throws RecognitionException {   
    <ruleDescriptor.useScopes:{stack_<it>.push(new scope_<it>());}; separator="\n">
    <ruleDescriptor.ruleScope:{stack_<it.name>.push(new scope_<it.name>());}; separator="\n">
    <ruleDescriptor.returnScope:{scope_<it.name> retval = new scope_<it.name>();<\n>retval.start = input.LT(1);}; separator="\n">
    <ruleDescriptor.tokenLabels:{Token <it.label.text>=null;}; separator="\n">
    <ruleDescriptor.ruleLabels:{scope_<it.elementRef.text>_return <it.label.text>=null;}; separator="\n">
    <initAction>
<if(enterAction)>
    <enterAction><\n>
<endif>
    try {
        <block>
    }
    catch (RecognitionException re) {
        reportError(re);
        errorRecovery = true;
        recover(re);
    }
    finally {
        <ruleDescriptor.useScopes:{stack_<it>.pop();}; separator="\n">
        <ruleDescriptor.ruleScope:{stack_<it.name>.pop();}; separator="\n">
        retval.stop = input.LT(0);
        <exitAction>
    }<\n>
<if(ruleDescriptor.returnScope)>
    return retval;<\n>
<endif>
}
>>

tokensRule(ruleName,nakedBlock,args,block,enterAction,exitAction) ::= <<
public void mTokens() throws RecognitionException {
    <block><\n>
}
>>

lexerRule(ruleName,nakedBlock,args,initAction,block,enterAction,exitAction) ::= <<
public void m<ruleName>(<args>) throws RecognitionException {
<initAction>
<if(nakedBlock)>
    <block><\n>
<else>
    int type = <ruleName>;
    int start = getCharIndex();
    int line = getLine();
    int charPosition = getCharPositionInLine();
    int channel = Token.DEFAULT_CHANNEL;
    <block>
    if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}<\n>
<endif>
}
>>

blockSingleAlt(alts,decls,decision,decisionNumber,preamble) ::= <<
<preamble><decls><alts>
>>

block(alts,decls,decision,decisionNumber,preamble,maxK,maxAlt) ::= <<
<preamble>
int alt<decisionNumber>=<maxAlt>;
<decls>
<decision>
switch (alt<decisionNumber>) {
    <alts:altSwitchCase()>
}
>>

positiveClosureBlock(alts,decls,decision,decisionNumber,maxK,maxAlt) ::= <<
int cnt<decisionNumber>=0;
<decls>
loop<decisionNumber>:
do {
    int alt<decisionNumber>=<maxAlt>;
    <decision>
    switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
	default :
	    if ( cnt<decisionNumber> >= 1 ) break loop<decisionNumber>;
	    throw new EarlyExitException(<decisionNumber>);
    }
    cnt<decisionNumber>++;
} while (true);
>>

positiveClosureBlockSingleAlt ::= positiveClosureBlock

closureBlock(alts,decls,decision,decisionNumber,maxK,maxAlt) ::= <<
<decls>
loop<decisionNumber>:
do {
    int alt<decisionNumber>=<maxAlt>;
    <decision>
    switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
	default :
	    break loop<decisionNumber>;
    }
} while (true);
>>

closureBlockSingleAlt ::= closureBlock

optionalBlock ::= block

optionalBlockSingleAlt ::= block

altSwitchCase() ::= <<
case <i> :
    <it>
    break;<\n>
>>

alt(elements) ::= "<elements; separator=\"\n\">"

tokenRef(token,label,elementIndex) ::= <<
<if(label)><label>=input.LT(1);<endif>
match(<token>,FOLLOW_<token>_in_<ruleName><elementIndex>);
>>

charRef(char) ::= "match(<char>);"

charRangeRef(a,b) ::= "matchRange(<a>,<b>);"

/** For now, sets are interval tests and must be tested inline */
matchSet(s,label) ::= <<
<if(label)><label>=input.LT(1);<endif>
if ( <s> ) input.consume();
else throw new MismatchedSetException("<s>");<\n>
>>

matchNotSet(s,label) ::= <<
<if(label)><label>=input.LT(1);<endif>
if ( !(<s>) ) input.consume();
else throw new MismatchedNotSetException("");<\n>
>>

lexerStringRef(string) ::= "match(<string>);"

wildcard(label) ::= <<
<if(label)><label>=input.LT(1);<endif>
matchAny();
>>

wildcardChar() ::= "matchAny();"

ruleRef(rule,label,elementIndex,args) ::= <<

following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<if(label)>
<label>=<rule>(<args>);<\n>
<else>
<rule>(<args>);<\n>
<endif>
following.pop();
>>

lexerRuleRef(rule,args) ::= "m<rule>(<args>);"


// F i x e d  D F A  s t u f f

dfaDecision(decisionNumber,description) ::=
  "alt<decisionNumber> = DFA<decisionNumber>.predict(input);"

dfaState(edges,eotPredictsAlt,description,stateNumber) ::= <<
<edges; separator="\nelse ">
else {
<if(eotPredictsAlt)>
    alt<decisionNumber>=<eotPredictsAlt>;
<else>
    throw new NoViableAltException("<description>", <decisionNumber>, <stateNumber>);<\n>
<endif>
}
>>

dfaOptionalBlockState(edges,eotPredictsAlt,description,stateNumber) ::= <<
<edges; separator="\nelse ">
>>

dfaLoopbackState(edges,eotPredictsAlt,description,stateNumber) ::= <<
<edges; separator="\nelse "><\n>
<if(eotPredictsAlt)>
else {
    alt<decisionNumber>=<eotPredictsAlt>;
}<\n>
<endif>
>>

dfaAcceptState(alt) ::= "alt<decisionNumber>=<alt>;"

dfaEdge(labelExpr, targetState) ::= <<
if ( <labelExpr> ) {
    <targetState>
}
>>

// D F A  E X P R E S S I O N S

andPredicates(left,right) ::= "(<left>&&<right>)"

orPredicates(left,right) ::= "(<left>||<right>)"

notPredicate(pred) ::= "!(<pred>)"

lookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::=
	"(input.LA(<k>)>=<lower> && input.LA(<k>)\<=<upper>)"

setTest(ranges) ::= "<ranges; separator=\"||\">"

// A C T I O N S

emit(type) ::= "emit(<type>);"

setType(type) ::= "setType(<type>);"


// M I S C (properties, etc...)

codeFileExtension() ::= ".java"
