group Java_dfa;

dfaDecision(decisionNumber,description) ::= <<
int m<decisionNumber> = input.mark();
<! the <name> attribute is inherited via the parser, lexer, ... !>
alt<decisionNumber> = <name>_DFA.DFA<decisionNumber>(input);
input.rewind(m<decisionNumber>);
>>

allCyclicDFAs(cyclicDFAs) ::= <<
.method \<init> ()V 1
	aload 0
	invokespecial java/lang/Object.\<init>()V
	return
<cyclicDFAs>
>>

cyclicDFA(decision,states,description) ::= <<
.method DFA<decision> (Lorg/antlr/runtime/CharStream;)I 2
    goto s0
errorState:
    getstatic java/lang/System.err Ljava/io/PrintStream;
	ldc "DFA match error!"
	invokevirtual java/io/PrintStream.println(Ljava/lang/String;)V
    iconst 0
    ireturn
<states>
>>

cyclicDFAState(stateNumber,edges,needErrorClause) ::= <<
s<stateNumber>:
; load lookahead into a local in every state
    aload 0
    iconst 1
    invokeinterface org/antlr/runtime/CharStream.LA(I)I 2
    istore 1
<edges>
<if(needErrorClause)>
    goto errorState
<endif>
>>

cyclicDFAAcceptState(stateNumber,predictAlt) ::= <<
s<stateNumber>:
    iconst <predictAlt>
    ireturn
>>

cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber) ::= <<
s<stateNumber>e<edgeNumber>:
<labelExpr>
s<stateNumber>e<edgeNumber>_go:
    aload 0
    invokeinterface org/antlr/runtime/CharStream.consume()V 1
    goto s<targetStateNumber>
s<stateNumber>e<edgeNumber>_skip:
>>

eotDFAEdge(targetStateNumber) ::= <<
    goto s<targetStateNumber>
>>

// D F A  E X P R E S S I O N S

andPredicates(left,right) ::= "(<left>&&<right>)"

orPredicates(left,right) ::= "(<left>||<right>)"

notPredicate(pred) ::= "!(<pred>)"

lookaheadTest(atom,k,atomAsInt) ::= <<
    iload 1
    iconst <atomAsInt>
    if_icmpne s<stateNumber>e<edgeNumber>_skip
>>

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <<
;	(i>=<lowerAsInt> && i\<=<upperAsInt>)
    iload 1
    iconst <lowerAsInt>
    if_icmplt s<stateNumber>r<rangeNumber>_false
    iload 1
    iconst <upperAsInt>
    if_icmpgt s<stateNumber>r<rangeNumber>_false
    goto s<stateNumber>e<edgeNumber>_transition
s<stateNumber>r<rangeNumber>_false:
>>

setTest(ranges) ::= <<
<ranges>
    goto s<stateNumber>e<edgeNumber>_skip
>>
