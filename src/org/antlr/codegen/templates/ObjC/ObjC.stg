/*
 [The "BSD licence"]
 Copyright (c) 2006 Kay Roepke
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
    derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
	Template group file for the Objective C code generator.
	Heavily based on Java.stg

	Written by Kay Roepke <kroepke(at)classdump.org>

	This file is part of ANTLR and subject to the same license as ANTLR itself.
*/

group ObjC implements ANTLRCore;

objcTypeInitMap ::= [
	"int":"0",
	"long":"0",
	"float":"0.0",
	"double":"0.0",
	"boolean":"false",
	"byte":"0",
	"short":"0",
	"char":"0",
	"id":"nil",
	default:"nil" // anything other than an atomic type
]

/** The overall file structure of a recognizer; stores methods for rules
 *  and cyclic DFAs plus support code.
 */
outputFile(LEXER,PARSER,TREE_PARSER, actionScope, actions,
           docComment, recognizer,
           name, tokens, tokenNames, rules, cyclicDFAs,
	   bitsets, buildTemplate, profile,
	   backtracking, synpreds, memoize, numRules,
	   fileName, ANTLRVersion, generatedTimestamp, trace, scopes, superClass,literals) ::=
<<
// $ANTLR <ANTLRVersion> <fileName> <generatedTimestamp>

<@imports>
#import "<name>.h"
<@end>

<docComment>
<recognizer>
>>


headerFile(LEXER,PARSER,TREE_PARSER, actionScope, actions,
           docComment, recognizer,
           name, tokens, tokenNames, rules, cyclicDFAs,
	   bitsets, buildTemplate, profile,
	   backtracking, synpreds, memoize, numRules,
	   fileName, ANTLRVersion, generatedTimestamp, trace, scopes, superClass,literals) ::=
<<
// $ANTLR <ANTLRVersion> <fileName> <generatedTimestamp>

#import \<Cocoa/Cocoa.h>
#import \<ANTLR/ANTLR.h>

<actions.(actionScope).header>

<if(LEXER)>
<lexerHeaderFile(...)>
<endif>
<if(PARSER)>
<parserHeaderFile(...)>
<endif>
<if(TREE_PARSER)>
<parserHeaderFile(...)>
<endif>
>>

lexerHeaderFile() ::=
<<
#pragma mark Cyclic DFA start
<cyclicDFAs:cyclicDFAInterface()>
#pragma mark Cyclic DFA end

#pragma mark Rule return scopes start
<rules:{rule |
<rule.ruleDescriptor:returnScopeInterface(ruleDescriptor=rule.ruleDescriptor)>
}>
#pragma mark Rule return scopes end

#pragma mark Tokens
<tokens:{#define <name>_<it.name>	<it.type>}; separator="\n">

@interface <name> : ANTLRLexer {
	<cyclicDFAs:{dfa | <name>DFA<dfa.decisionNumber> *dfa<dfa.decisionNumber>;}; separator="\n">
	<synpreds:{p | SEL <p>SyntacticPredicate;}; separator="\n">
	<actions.lexer.ivars>
}

<actions.lexer.methodsdecl>

<rules:{rule |
- (<rule.ruleDescriptor:{ruleDescriptor|<returnType()>}>) m<rule.ruleName><if(rule.ruleDescriptor.parameterScope)><rule.ruleDescriptor.parameterScope:parameterScope(scope=it)><endif>;
}>


@end
>>

lexer(grammar, name, tokens, scopes, rules, numRules, labelType="ANTLRToken *",
      filterMode) ::= <<
#pragma mark Cyclic DFAs
<cyclicDFAs:cyclicDFA()>

/** As per Terence: No returns for lexer rules!
#pragma mark Rule return scopes start
<rules:{rule |
<rule.ruleDescriptor:returnScope(ruleDescriptor=rule.ruleDescriptor)>
}>
#pragma mark Rule return scopes end
*/
@implementation <name>

<actions.lexer.methods>

- (id) initWithCharStream:(id\<ANTLRCharStream>)anInput
{
	if (nil!=(self = [super initWithCharStream:anInput])) {
		<if(memoize)>
		// init memoize facility
		<endif>
		<synpreds:{p | <lexerSynpred(name=p)>};separator="\n">
		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = [[<name>DFA<dfa.decisionNumber> alloc] init];}; separator="\n">
		<actions.lexer.init>
	}
	return self;
}

- (void) dealloc
{
	<cyclicDFAs:{dfa | [dfa<dfa.decisionNumber> release];}; separator="\n">
<actions.lexer.dealloc>
	[super dealloc];
}

<if(actions.lexer.reset)>
- (void) reset
{
<actions.lexer.reset>
	[super reset];
}
<endif>

<if(filterMode)>
<filteringNextToken()>
<endif>

<rules; separator="\n\n">

@end
>>

/** A override of Lexer.nextToken() that backtracks over mTokens() looking
 *  for matches.  No error can be generated upon error; just rewind, consume
 *  a token and then try again.  backtracking needs to be set as well.
 */
filteringNextToken() ::= <<
- (ANTLRToken *) nextToken
{
	[self setToken:nil];
    tokenStartCharIndex = [self charIndex];
    while (YES) {
        if ( [input LA:1] == ANTLRCharStreamEOF ) {
            return nil; // should really be a +eofToken call here -> go figure
        }
        @try {
            int m = [input mark];
            backtracking = 1;
            failed = NO;
            [self mTokens];
            backtracking = 0;
            [input rewind:m];
            if ( failed ) {
                [input consume]; <! // advance one char and try again !>
            } else {
                [self mTokens];
                return token;
            }
        }
        @catch (ANTLRRecognitionException *re) {
            // shouldn't happen in backtracking mode, but...
            [self reportError:re];
            [self recover:re];
        }
    }
}
>>

filteringActionGate() ::= "backtracking==1"

parserHeaderFile(LEXER, PARSER, TREE_PARSER, actionScope, actions, docComment,
           recognizer, name, tokens, tokenNames, rules, cyclicDFAs,
           bitsets, buildTemplate, profile, backtracking, synpreds,
           memoize, numRules, fileName, ANTLRVersion, generatedTimestamp, trace, scopes, superClass="ANTLRParser") ::=
<<

#pragma mark Cyclic DFA
<cyclicDFAs:cyclicDFAInterface()>

#pragma mark Tokens
<tokens:{#define <name>_<it.name>	<it.type>}; separator="\n">

#pragma mark Dynamic Scopes
<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScopeDecl(scope=it)><endif>}>

#pragma mark Rule return scopes start
<rules:{rule |
<rule.ruleDescriptor:returnScopeInterface(ruleDescriptor=rule.ruleDescriptor)>
}>
#pragma mark Rule return scopes end


@interface <name> : <@superClassName><superClass><@end> {

	<cyclicDFAs:{dfa | <name>DFA<dfa.decisionNumber> *dfa<dfa.decisionNumber>;}; separator="\n">
	<synpreds:{p | SEL <p>SyntacticPredicate;}; separator="\n">
	<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScopeIVar(scope=it)><endif>}>

	<@ivars()>

	<actions.parser.ivars>
 }

<actions.parser.methodsdecl>

<rules:{rule |
- (<rule.ruleDescriptor:{ruleDescriptor|<returnType()>}>) <rule.ruleName><if(rule.ruleDescriptor.parameterScope)><rule.ruleDescriptor.parameterScope:parameterScope(scope=it)><endif>;
}>

<@methods()>

@end
>>

/** How to generate a parser */
genericParser(name, scopes, tokens, tokenNames, rules, numRules,
              cyclicDFAs, bitsets, inputStreamType, superClass,
              ASTLabelType="id", labelType, members) ::= <<

#pragma mark Cyclic DFA
<cyclicDFAs:cyclicDFA()>

#pragma mark Bitsets
<bitsets:bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>}, words64=it.bits)>

#pragma mark Scopes
<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScopeImpl(scope=it)><endif>}>

#pragma mark Rule return scopes start
<rules:{rule |
<rule.ruleDescriptor:returnScope(ruleDescriptor=rule.ruleDescriptor)>
}>

@implementation <name>

+ (void) initialize
{
	<bitsets:bitsetInit(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>}, words64=it.bits)>
}

- (id) initWithTokenStream:(id\<ANTLRTokenStream>)aStream
{
	if ((self = [super initWithTokenStream:aStream])) {
		tokenNames = [[NSArray alloc] initWithObjects:@"\<invalid>", @"\<EOR>", @"\<DOWN>", @"\<UP>", <tokenNames:{@<it>}; separator=", ", wrap="    ">, nil];
<if(backtracking)>
		ruleMemo = [[NSMutableDictionary alloc] init];
<endif>
		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = [[<name>DFA<dfa.decisionNumber> alloc] init];}; separator="\n">
		<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScopeInit(scope=it)><endif>}>
		<actions.parser.init>
		<@init()>
	}
	return self;
}

- (void) dealloc
{
	[tokenNames release];
<if(backtracking)>
	[ruleMemo release];
<endif>
	<cyclicDFAs:{dfa | [dfa<dfa.decisionNumber> release];}; separator="\n">
	<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScopeDealloc(scope=it)><endif>}>
	<actions.parser.dealloc>
	<@dealloc()>
	[super dealloc];
}

<actions.parser.methods>

<rules; separator="\n\n">

<synpreds:{p | <synpred(p)>}>

<@methods()>

@end
>>

parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets, ASTLabelType, superClass="ANTLRParser", labelType="ANTLRToken *", members={<actions.parser.members>}) ::= <<
<genericParser(inputStreamType="ANTLRTokenStream *", ...)>
>>

treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules, numRules, bitsets, labelType={<ANTLRASTLabelType>}, ASTLabelType="id", superClass="ANTLRTreeParser", members={<actions.treeparser.members>}) ::= <<
<genericParser(inputStreamType="ANTLRTreeNodeStream *", ...)>
>>
/** A simpler version of a rule template that is specific to the imaginary
 *  rules created for syntactic predicates.  As they never have return values
 *  nor parameters etc..., just give simplest possible method.  Don't do
 *  any of the normal memoization stuff in here either; it's a waste.
 *  As predicates cannot be inlined into the invoking rule, they need to
 *  be in a rule by themselves.
 */
synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
<<
- (void) m<ruleName>
{
    <if(trace)>NSLog(@"enter <ruleName> %@ failed=%@ backtracking=%d", [input LT:1], failed ? @"YES" : @"NO", backtracking);
    @try {
        <block>
    }
    @finally {
        NSLog(@"exit <ruleName> %@ failed=%@ backtracking=%d", [input LT:1], failed ? @"YES" : @"NO", backtracking);
    }
<else>
    <block>
<endif>
}
>>


synpred(name) ::= <<
<name>SyntacticPredicate = @selector(m<name>);
>>

lexerSynpred(name) ::= <<
<synpred(name)>
>>

ruleMemoization(name) ::= <<
<if(memoize)>
if ( backtracking>0 && alreadyParsedRule(input, <ruleDescriptor.index>) ) { return <ruleReturnValue()>; }
<endif>
>>


/** How to generate code for a rule.
 *  The return type aggregates are declared in the header file (headerFile template)
 */
rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions, memoize) ::= <<
<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>

// $ANTLR start <ruleName>
// <fileName>:<description>
- (<returnType()>) <ruleName><ruleDescriptor.parameterScope:parameterScope(scope=it)>
{
    <if(trace)>NSLog(@"enter <ruleName> %@ failed=%@ backtracking=%d", [input LT:1], failed ? @"YES" : @"NO", backtracking);<endif>
    <ruleDeclarations()>
    <ruleLabelDefs()>
    <ruleDescriptor.actions.init>
    <@preamble()>
    <ruleMemoization(name=ruleName)>
    @try {
        <block>
    }
<if(exceptions)>
    <exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
<else>
<if(!emptyRule)>
<if(actions.(actionScope).rulecatch)>
    <actions.(actionScope).rulecatch>
<else>
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input exception:re];
    }<\n>
<endif>
<endif>
<endif>
    @finally {
        <if(trace)>NSLog(@"exit <ruleName> %@ failed=%@ backtracking=%d", [input LT:1], failed ? @"YES" : @"NO", backtracking);<endif>
        <ruleCleanUp()>
<if(ruleDescriptor.actions.finally)>
<if(backtracking)>
        if ( backtracking==0 ) {
            <ruleDescriptor.actions.finally>
        }<\n>
<else>
        <ruleDescriptor.actions.finally>
<endif>
<endif>
    }
    <@postamble()>
    return <ruleReturnValue()>;
}
// $ANTLR end <ruleName>
>>

catch(decl,action) ::= <<
catch (<e.decl>) {
    <e.action>
}
>>

ruleDeclarations() ::= <<
<ruleDescriptor.useScopes:{[<name>_<it>_stack addObject:[[[<name>_<it>_scope alloc] init] autorelease]];}; separator="\n">
<ruleDescriptor.ruleScope:{[<name>_<it.name>_stack addObject:[[[<name>_<it.name>_scope alloc] init] autorelease]];}; separator="\n">
<if(ruleDescriptor.hasMultipleReturnValues)>
<returnType()> retval = [[<returnTypeName()> alloc] init]; <! retvals are released in the calling rule! !>
[retval setStart:[input LT:1]];<\n>
<else>
<if(ruleDescriptor.hasSingleReturnValue)>
<returnType()> <ruleDescriptor.singleValueReturnName>;
<endif>
<endif>
<if(memoize)>
int <ruleDescriptor.name>_StartIndex = [input index];
<endif>
>>

ruleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels]
    :{<labelType> <it.label.text> = nil;}; separator="\n"
>
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels]
    :{NSMutableArray *list_<it.label.text> = nil;}; separator="\n"
>
<[ruleDescriptor.ruleLabels,ruleDescriptor.ruleListLabels]
    :ruleLabelDef(label=it); separator="\n"
>
<[ruleDescriptor.allRuleRefsInAltsWithRewrites,ruleDescriptor.allTokenRefsInAltsWithRewrites]
    :{NSMutableArray *list_<it> = [[NSMutableArray alloc] init];}; separator="\n"
>
>>

ruleReturnValue() ::= <<
<if(ruleDescriptor.hasReturnValue)>
<if(ruleDescriptor.hasSingleReturnValue)>
<ruleDescriptor.singleValueReturnName>
<else>
retval
<endif>
<endif>
>>

ruleCleanUp() ::= <<
// token labels
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels]:{[<it.label.text> release];}; separator="\n">
// token+rule list labels
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels]:{[list_<it.label.text> release];}; separator="\n">
// rule labels
<[ruleDescriptor.ruleLabels,ruleDescriptor.ruleListLabels]:{[<it.label.text> release];}; separator="\n">
// rule refs in alts with rewrites
<[ruleDescriptor.allRuleRefsInAltsWithRewrites,ruleDescriptor.allTokenRefsInAltsWithRewrites]
	:{[list_<it> release];}; separator="\n">
<ruleDescriptor.useScopes:{[<name>_<it>_stack removeLastObject];}; separator="\n">
<ruleDescriptor.ruleScope:{[<name>_<it.name>_stack removeLastObject];}; separator="\n">
<if(ruleDescriptor.hasMultipleReturnValues)>
[retval setStop:[input LT:-1]];<\n>
<endif>
<if(memoize)>
<if(backtracking)>
if ( backtracking>0 ) { [self memoize(input, <ruleDescriptor.index>, <ruleDescriptor.name>_StartIndex)]; }
<endif>
<endif>
>>


/** How to generate a rule in the lexer; naked blocks are used for
 *  fragment rules.
 */
lexerRule(ruleName,nakedBlock,ruleDescriptor,block, memoize) ::= <<

<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>

- (void) m<ruleName><if(ruleDescriptor.parameterScope)><ruleDescriptor.parameterScope:parameterScope(scope=it)><endif>
{
    <if(trace)>NSLog(@"enter <ruleName> %C line=%d:%d failed=%@ backtracking=%d", [input LA:1], [self line], [self charPositionInLine], failed ? @"YES" : @"NO", backtracking);<endif>
	<ruleDeclarations()>
	<ruleLabelDefs()>
	@try {
<ruleDescriptor.actions.init>
<if(nakedBlock)>
        <ruleMemoization(name=ruleName)>
		<block><\n>
<else>
		int type = <name>_<ruleName>;
		int start = [self charIndex];
		int line = [self line];
		int charPosition = [self charPositionInLine];
		int channel = [ANTLRToken defaultChannel];
		<block>
		if ( token == nil ) { [self emitTokenWithType:type line:line charPosition:charPosition channel:channel start:start stop:[self charIndex]];}<\n>
<endif>
	}
	@finally {
        <if(trace)>NSLog(@"exit <ruleName> %@ failed=%@ backtracking=%d", [input LA:1], [self line], [self charPositionInLine], failed ? @"YES" : @"NO", backtracking);<endif>
        // rule cleanup
		<ruleCleanUp()>
<if(backtracking)>
		if ( backtracking == 0 ) {
			<ruleDescriptor.actions.finally>
		}<\n>
<else>
		<ruleDescriptor.actions.finally>
<endif>
	}
	return;
}
// $ANTLR end <ruleName>
>>

/** How to generate code for the implicitly-defined lexer grammar rule
 *  that chooses between lexer rules.
 */
tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
- (void) mTokens
{
    <block><\n>
}
>>

// S U B R U L E S

/** A (...) subrule with multiple alternatives */
block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
// <fileName>:<description> // block
int alt<decisionNumber>=<maxAlt>;
<decls>
<@predecision()>
<decision>
<@postdecision()>
<@prebranch()>
switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
}
<@postbranch()>
>>

/** A rule block with multiple alternatives */
ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
// <fileName>:<description> //ruleblock
int alt<decisionNumber>=<maxAlt>;
<decls>
<@predecision()>
<decision>
<@postdecision()>
switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
}
>>

ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
// <fileName>:<description> // ruleBlockSingleAlt
<decls>
<@prealt()>
<alts>
<@postalt()>
>>

/** A special case of a (...) subrule with a single alternative */
blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
// <fileName>:<description> // blockSingleAlt
<decls>
<@prealt()>
<alts>
<@postalt()>
>>

/** A (..)+ block with 0 or more alternatives */
positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
// <fileName>:<description>	// positiveClosureBlock
int cnt<decisionNumber>=0;
<decls>
<@preloop()>

do {
    int alt<decisionNumber>=<maxAlt>;
    <@predecision()>
    <decision>
    <@postdecision()>
    switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
	default :
	    if ( cnt<decisionNumber> >= 1 )  goto loop<decisionNumber>;
	    <if(backtracking)>
            if (backtracking>0) { failed = YES; return; }
            <endif>
			ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:<decisionNumber>];
			<@earlyExitException()>
			@throw eee;
    }
    cnt<decisionNumber>++;
} while (YES); loop<decisionNumber>: ;
<@postloop()>
>>

positiveClosureBlockSingleAlt ::= positiveClosureBlock

/** A (..)* block with 0 or more alternatives */
closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
<decls>
<@preloop()>
do {
    int alt<decisionNumber>=<maxAlt>;
    <@predecision()>
    <decision>
    <@postdecision()>
    switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
	default :
	    goto loop<decisionNumber>;
    }
} while (YES); loop<decisionNumber>: ;
<@postloop()>
>>

closureBlockSingleAlt ::= closureBlock

/** Optional blocks (x)? are translated to (x|) by before code generation
 *  so we can just use the normal block template
 */
optionalBlock ::= block

optionalBlockSingleAlt ::= block

/** A case in a switch that jumps to an alternative given the alternative
 *  number.  A DFA predicts the alternative and then a simple switch
 *  does the jump to the code that actually matches that alternative.
 */
altSwitchCase() ::= <<
case <i> :
    <@prealt()>
    <it>
    break;<\n>
>>

/** An alternative is just a list of elements; at outermost level */
alt(elements,altNum,description,autoAST,outerAlt) ::= <<
// <fileName>:<description> // alt
{
<@declarations()>
<elements:element()>
<@cleanup()>
}
>>

// E L E M E N T S

/** Dump the elements one per line */
element() ::= <<
<@prematch()>
<it.el><\n>
>>

/** match a token optionally with a label in front */
tokenRef(token,label,elementIndex) ::= <<
<if(label)>
<label>=(<labelType>)[input LT:1];<\n>
<endif>
[self match:input tokenType:<token> follow:FOLLOW_<token>_in_<ruleName><elementIndex>]; <if(backtracking)> if (failed) return;<endif>
>>

/** ids+=ID */
tokenRefAndListLabel(token,label,elementIndex) ::= <<
<tokenRef(...)>
<listLabel(...)>
>>

listLabel(label) ::= <<
if (list_<label> == nil)
	list_<label> = [[NSMutableArray alloc] initWithObjects:<label>, nil];
else
	[list_<label> addObject:<label>];
>>

/** match a character */
charRef(char,label) ::= <<
<if(label)>
int <label> = [input LA:1];<\n>
<endif>
[self matchChar:<char>];
<if(backtracking)>if (failed) return;<endif><\n>
>>

/** match a character range */
charRangeRef(a,b) ::= "[self matchRangeFromChar:<a> to:<b>];<if(backtracking)> if (failed) return;<endif>"

/** For now, sets are interval tests and must be tested inline */
matchSet(s,label,elementIndex,postmatchCode="") ::= <<
<if(label)>
<label> = (<labelType>)[input LT:1];<\n>
<endif>
if (<s>) {
	<postmatchCode>
	[input consume];
	errorRecovery = NO;
	<if(backtracking)>failed = NO;<endif>
} else {
	<if(backtracking)>if (backtracking > 0) {
		failed = YES;
		return;
	}
	<endif>
	ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
<if(LEXER)>
	[self recover:mse];
<else>
	[self recoverFromMismatchedSet:input exception:mse follow:FOLLOW_set_in_<ruleName><elementIndex>];
<endif>
	@throw mse;
}<\n>
>>

matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
<matchSet(...)>
<listLabel(...)>
>>

/** Match a string literal */
lexerStringRef(string,label) ::= <<
<if(label)>
int <label>Start = [self charIndex];
[self matchString:<string>];
<if(backtracking)>if (failed) return;<endif><\n>
<label> = [[ANTLRCommonToken alloc] initWithInput:input tokenType:ANTLRTokenTypeInvalid channel:ANTLRTokenChannelDefault start:<label>Start, stop:[self charIndex]];
<else>
[self matchString:<string>];
<if(backtracking)>if (failed) return;<endif><\n>
<endif>
>>

wildcard(label,elementIndex) ::= <<
<if(label)>
<label> = (<labelType>)[input LT:1];<\n>
<endif>
[self matchAny:input];
<if(backtracking)>if (failed) return;<endif><\n>
>>

wildcardAndListLabel(label,elementIndex) ::= <<
<wildcard(...)>
<listLabel(...)>
>>

/** Match . wildcard in lexer */
wildcardChar(label, elementIndex) ::= <<
<if(label)>
int <label> = [input LA:1];<\n>
<endif>
[self matchAny];
<if(backtracking)>if (failed) return;<endif><\n>
>>

wildcardCharListLabel(label, elementIndex) ::= <<
<wildcardChar(...)>
<listLabel(...)>
>>

/** Match a rule reference by invoking it possibly with arguments
 *  and a return value or values.
 */
ruleRef(rule,label,elementIndex,args) ::= <<
[following addObject:FOLLOW_<rule>_in_<ruleName><elementIndex>];
<if(label)>
<label> = [self <rule><if(args)>:<args; separator=" :"><endif>];<\n>
<else>
[self <rule><if(args)>:<args; separator=" :"><endif>];<\n>
<endif>
[following removeLastObject];
<if(backtracking)>if (failed) return;<endif><\n>
>>

/** ids+=ID */
ruleRefAndListLabel(rule,label,elementIndex,args) ::= <<
<ruleRef(...)>
<listLabel(...)>
>>

/** A lexer rule reference */
lexerRuleRef(rule,label,args) ::= <<
<if(label)>
int <label>Start = [self charIndex];
[self m<rule><if(args)>:<args; separator=" :"><endif>];
<if(backtracking)>if (failed) return;<endif><\n>
<label> = [[ANTLRCommonToken alloc] initWithInput:input tokenType:ANTLRTokenTypeInvalid channel:ANTLRTokenChannelDefault start:<label>Start stop:[self charIndex]];
<else>
[self m<rule><if(args)>:<args; separator=" :"><endif>];
<if(backtracking)>if (failed) return;<endif><\n>
<endif>
>>

/** EOF in the lexer */
lexerMatchEOF(label) ::= <<
#warning ObjCify!
<if(label)>
int <label>Start = getCharIndex();
match(EOF); <checkRuleBacktrackFailure()>
<labelType> <label> = new CommonToken(input, EOF, Token.DEFAULT_CHANNEL, <label>Start, getCharIndex()-1);
<else>
match(EOF); <checkRuleBacktrackFailure()>
<endif>
>>

/** match ^(root children) in tree parser */
tree(root, children,nullableChildList) ::= <<
#warning Tree stuff incomplete!
>>

/** Every predicate is used as a validating predicate (even when it is
 *  also hoisted into a prediction expression).
 */
validateSemanticPredicate(pred,description) ::= <<
>>

// F i x e d  D F A  (if-then-else)

dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
{
	int LA<decisionNumber>_<stateNumber> = [input LA:<k>];
	<edges; separator="\nelse ">
else {
<if(eotPredictsAlt)>
	alt<decisionNumber> = <eotPredictsAlt>;
<else>
	<if(backtracking)>
	if (backtracking > 0) {
		failed = YES;
		return;
	}
	<endif>
    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException exceptionWithDecision:<decisionNumber> state:<stateNumber> stream:input];
	<@noViableAltException()>
	@throw nvae;<\n>
<endif>
	}
}
>>

/** Same as a normal DFA state except that we don't examine lookahead
 *  for the bypass alternative.  It delays error detection but this
 *  is faster, smaller, and more what people expect.  For (X)? people
 *  expect "if ( LA(1)==X ) match(X);" and that's it.
 */
dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
int LA<decisionNumber>_<stateNumber> = [input LA:<k>];
<edges; separator="\nelse ">
>>

/** A DFA state that is actually the loopback decision of a closure
 *  loop.  If end-of-token (EOT) predicts any of the targets then it
 *  should act like a default clause (i.e., no error can be generated).
 *  This is used only in the lexer so that for ('a')* on the end of a rule
 *  anything other than 'a' predicts exiting.
 */
dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
int LA<decisionNumber>_<stateNumber> = [input LA:<k>];
<edges; separator="\nelse "><\n>
<if(eotPredictsAlt)>
else {
    alt<decisionNumber> = <eotPredictsAlt>;
}<\n>
<endif>
>>

/** An accept state indicates a unique alternative has been predicted */
dfaAcceptState(alt) ::= "alt<decisionNumber> = <alt>;"

/** A simple edge with an expression.  If the expression is satisfied,
 *  enter to the target state.  To handle gated productions, we may
 *  have to evaluate some predicates for this edge.
 */
dfaEdge(labelExpr, targetState, predicates) ::= <<
if ( <labelExpr> <if(predicates)>&& <predicates><endif>) {
	<targetState>
}
>>

// F i x e d  D F A  (switch case)

/** A DFA state where a SWITCH may be generated.  The code generator
 *  decides if this is possible: CodeGenerator.canGenerateSwitch().
 */
dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
switch ([input LA:<k>]) {
	<edges; separator="\n">
default:
<if(eotPredictsAlt)>
	alt<decisionNumber> = <eotPredictsAlt>;
<else> {
	<if(backtracking)>
	if (backtracking > 0) {
		failed = YES;
		return;
	}
	<endif>
    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException exceptionWithDecision:<decisionNumber> state:<stateNumber> stream:input];
	<@noViableAltException()>
	@throw nvae;<\n>
	}
<endif>
}
>>

dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
switch ([input LA:<k>]) {
	<edges; separator="\n">
}<\n>
>>

dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
switch ([input LA:<k>]) {
	<edges; separator="\n">
<if(eotPredictsAlt)>
default:
	alt<decisionNumber> = <eotPredictsAlt>
	break;<\n>
<endif>
}<\n>
>>

dfaEdgeSwitch(labels, targetState) ::= <<
<labels:{case <it>:}; separator="\n">
	<targetState>
	break;
>>

// C y c l i c  D F A

/** The code to initiate execution of a cyclic DFA; this is used
 *  in the rule to predict an alt just like the fixed DFA case.
 *  The <name> attribute is inherited via the parser, lexer, ...
 */
dfaDecision(decisionNumber,description) ::= <<
alt<decisionNumber> = [dfa<decisionNumber> predict:input];
>>

/** Used in headerFile */
cyclicDFAInterface(dfa) ::= <<
@interface <name>DFA<dfa.decisionNumber> : ANTLRDFA {} @end<\n>
>>

/** Used in lexer/parser implementation files */
cyclicDFA(dfa) ::= <<
@implementation <name>DFA<dfa.decisionNumber>
const static int <name>dfa<dfa.decisionNumber>_eot[<dfa.numberOfStates>] =
    {<dfa.eot; wrap="\n     ", separator=",", null="-1">};
const static int <name>dfa<dfa.decisionNumber>_eof[<dfa.numberOfStates>] =
    {<dfa.eof; wrap="\n     ", separator=",", null="-1">};
const static unichar <name>dfa<dfa.decisionNumber>_min[<dfa.numberOfStates>] =
    {<dfa.min; wrap="\n     ", separator=",", null="0">};
const static unichar <name>dfa<dfa.decisionNumber>_max[<dfa.numberOfStates>] =
    {<dfa.max; wrap="\n     ", separator=",", null="0">};
const static int <name>dfa<dfa.decisionNumber>_accept[<dfa.numberOfStates>] =
    {<dfa.accept; wrap="\n     ", separator=",", null="-1">};
const static int <name>dfa<dfa.decisionNumber>_special[<dfa.numberOfStates>] =
    {<dfa.special; wrap="\n     ", separator=",", null="-1">};
const static int <name>dfa<dfa.decisionNumber>_transition[] = {};
<dfa.edgeTransitionClassMap.keys:{ table |
const static int <name>dfa<dfa.decisionNumber>_transition<i0>[] = {<table; separator=", ", wrap="\n	", null="-1">};
}; null="">

- (id) init
{
	if ((self = [super init]) != nil) {
		eot = <name>dfa<dfa.decisionNumber>_eot;
		eof = <name>dfa<dfa.decisionNumber>_eof;
		min = <name>dfa<dfa.decisionNumber>_min;
		max = <name>dfa<dfa.decisionNumber>_max;
		accept = <name>dfa<dfa.decisionNumber>_accept;
		special = <name>dfa<dfa.decisionNumber>_special;
		if (!(transition = calloc(<dfa.numberOfStates>, sizeof(void*)))) {
			[self release];
			return nil;
		}
		<dfa.transitionEdgeTables:{whichTable|transition[<i0>] = <name>dfa<dfa.decisionNumber>_transition<whichTable>;}; separator="\n", null="">
	}
	return self;
}

<if(dfa.specialStateSTs)>
- (int) specialStateTransition:(int) s
{
	int _s = s;
	switch ( s ) {
 		<dfa.specialStateSTs:{state |
		case <i0> : <! compressed special state numbers 0..n-1 !>
		<state>}; separator="\n">
	}
<if(backtracking)>
	if ([recognizer isBacktracking]) {
		[recognizer setIsFailed:YES];
		return -1;
	}<\n>
<endif>
	ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException exceptionWithDecision:<dfa.decisionNumber> state:_s stream:input];
	[self error:nvae];
	@throw nvae;
}<\n>
<endif>

- (void) release
{
	free(transition);
	[super release];
}

- (NSString *) description
{
	return @"<dfa.description>";
}

@end
<\n>
>>

cyclicDFAState(decisionNumber, stateNumber,edges,needErrorClause,semPredState) ::= <<
<if(semPredState)>
input.rewind();<\n>
<else>
int LA<decisionNumber>_<stateNumber> = [input LA:1];<\n>
<endif>
s = -1;
<edges; separator="\nelse ">
if ( s>=0 ) return s;
break;
>>

/** Just like a fixed DFA edge, test the lookahead and indicate what
 *  state to jump to next if successful.
 */
cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
if ( (<labelExpr>) <if(predicates)>&& (<predicates>)<endif>) {s = <targetStateNumber>;}<\n>
>>

/** An edge pointing at end-of-token; essentially matches any char;
 *  always jump to the target.
 */
eotDFAEdge(targetStateNumber,edgeNumber, predicates) ::= <<
s = <targetStateNumber>;<\n>
>>

// D F A  E X P R E S S I O N S

andPredicates(left,right) ::= "(<left>&&<right>)"

orPredicates(operands) ::= "(first(operands)<rest(operands):{o | ||<o>}>)"

notPredicate(pred) ::= "!(<evalPredicate(...)>)"

evalPredicate(pred,description) ::= "<pred>"

evalSynPredicate(pred,description) ::= "[self evaluateSyntacticPredicate:<pred>SyntacticPredicate stream:input]"

lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"

/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
 *  somewhere.  Must ask for the lookahead directly.
 */
isolatedLookaheadTest(atom,k,atomAsInt) ::= "[input LA:<k>]==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <<
(LA<decisionNumber>_<stateNumber>\>=<lower> && LA<decisionNumber>_<stateNumber>\<=<upper>)
>>

isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "([input LA:<k>]\>=<lower> && [input LA:<k>]\<=<upper>)"

setTest(ranges) ::= "<ranges; separator=\"||\">"

// A T T R I B U T E S

globalAttributeScope(scope) ::= <<
<if(scope.attributes)>
protected static class <scope.name>_scope {
    <scope.attributes:{<it.decl>;}; separator="\n">
}
protected Stack <scope.name>_stack = new Stack();<\n>
<endif>
>>

globalAttributeScopeDecl(scope) ::= <<
@interface <name>_<scope.name>_scope : NSObject {
	<scope.attributes:{<it.decl>;}; separator="\n">
}
// use KVC to access attributes!
@end
>>

globalAttributeScopeIVar(scope) ::= <<
NSMutableArray *<name>_<scope.name>_stack;
>>

globalAttributeScopeImpl(scope) ::= <<
@implementation <name>_<scope.name>_scope
@end
>>

globalAttributeScopeInit(scope) ::= <<
<name>_<scope.name>_stack = [[NSMutableArray alloc] init];
>>

globalAttributeScopeDealloc(scope) ::= <<
[<name>_<scope.name>_stack release];
>>


ruleAttributeScope(scope) ::= <<
<if(scope.attributes)>
protected static class <scope.name>_scope {
    <scope.attributes:{<it.decl>;}; separator="\n">
}
protected Stack <scope.name>_stack = new Stack();<\n>
<endif>
>>

ruleAttributeScopeDecl(scope) ::= <<
@interface <name>_<scope.name>_scope : NSObject {
	<scope.attributes:{<it.decl>;}; separator="\n">
}
// use KVC to access attributes!
@end
>>

ruleAttributeScopeIVar(scope) ::= <<
NSMutableArray *<name>_<scope.name>_stack;
>>

ruleAttributeScopeImpl(scope) ::= <<
@implementation <name>_<scope.name>_scope
@end
>>

ruleAttributeScopeInit(scope) ::= <<
<name>_<scope.name>_stack = [[NSMutableArray alloc] init];
>>

ruleAttributeScopeDealloc(scope) ::= <<
[<name>_<scope.name>_stack release];
>>


returnTypeName() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
<name><ruleDescriptor.name>_return
<else>
<if(ruleDescriptor.hasSingleReturnValue)>
<ruleDescriptor.singleValueReturnType>
<else>
void
<endif>
<endif>
>>

returnType() ::= <<
<returnTypeName()><if(ruleDescriptor.hasMultipleReturnValues)> *<endif>
>>

/** Generate the Objective-C type associated with a single or multiple return
 *  values.
 */
ruleLabelType(referencedRule) ::= <<
<if(referencedRule.hasMultipleReturnValues)>
<name><referencedRule.name>_return *
<else>
<if(referencedRule.hasSingleReturnValue)>
<referencedRule.singleValueReturnType>
<else>
void
<endif>
<endif>
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<objcTypeInitMap.(typeName)>
>>

/** Define a rule label including default value */
ruleLabelDef(label) ::= <<
<ruleLabelType(referencedRule=label.referencedRule)> <label.label.text> = <initValue(typeName=ruleLabelType(referencedRule=label.referencedRule))>;<\n>
>>

/** Define a return struct for a rule if the code needs to access its
 *  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
 *  subgroups to stick in members.
 */
returnScopeInterface(ruleDescriptor) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
@interface <returnTypeName()> : ANTLR<if(TREE_PARSER)>Tree<endif>ParserRuleReturnScope {
    <ruleDescriptor.returnScope.attributes:{<it.decl>;}; separator="\n">
    <@ivars()>
}
<@methods()>
@end
<endif>
>>

returnScope(ruleDescriptor) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
@implementation <returnTypeName()>
<@methods()>
@end
<endif>
>>

parameterScope(scope) ::= <<
<scope.attributes:{:(<it.type>)<it.name>}; separator=" ">
>>

/** Used in codegen.g to translate $x.y references.
 *  I could have left actions as StringTemplates to be inserted in
 *  the output (so they could use attributes inherited from surrounding
 *  templates), but really wanted to pass in AttributeScope and Attribute
 *  objects so this translation could query them.  So, translation of
 *  $x.y to executable code occurs before recognizerST.toString() occurs.
 *  I.e., actions are just text strings during final code generation.
globalAttributeRef(scope,attr) ::= <<
[[(<scope>)<name>_<scope>_stack lastObject] valueForKey:@"<attr.name>"]
>>
 */

parameterAttributeRef(attr) ::= "<attr.name>"

scopeAttributeRef(scope,attr,index,negIndex) ::= <<
#warning TODO scopes
<if(negIndex)>
[[<name>_<scope>_stack objectAtIndex:[<name>_<scope>_stack count]<negIndex>-1] valueForKey:@"<attr.name>"]
((<scope>_scope)<scope>_stack.elementAt(<scope>_stack.size()<negIndex>-1)).<attr.name>
<else>
<if(index)>
[[<name>_<scope>_stack objectAtIndex:<index>] valueForKey:@"<attr.name>"]
<else>
[[<name>_<scope>_stack lastObject] valueForKey:@"<attr.name>"]
<endif>
<endif>
>>

/** $x is either global scope or x is rule with dynamic scope; refers
 *  to stack itself not top of stack.  This is useful for predicates
 *  like {$function.size()>0 && $function::name.equals("foo")}?
 */
isolatedDynamicScopeRef(scope) ::= "<name>_<scope>_stack"

/** reference an attribute of rule; might only have single return value */
ruleLabelRef(referencedRule,scope,attr) ::= <<
<if(referencedRule.hasMultipleReturnValues)>
[<scope> valueForKey:@"<attr.name>"]
<else>
<scope>
<endif>
>>

returnAttributeRef(ruleDescriptor,attr) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
[retval setValue: forKey:@"<attr.name>"];
<else>
<attr.name>
<endif>
>>

/** How to translate $tokenLabel */
tokenLabelRef(label) ::= "<label>"

/** ids+=ID {$ids} or e+=expr {$e} */
listLabelRef(label) ::= "list_<label>"


// not sure the next are the right approach; and they are evaluated early;
// they cannot see TREE_PARSER or PARSER attributes for example. :(

tokenLabelPropertyRef_text(scope,attr) ::= "[<scope> text]"
tokenLabelPropertyRef_type(scope,attr) ::= "[<scope> type]"
tokenLabelPropertyRef_line(scope,attr) ::= "[<scope> line]"
tokenLabelPropertyRef_pos(scope,attr) ::= "[<scope> charPositionInLine]"
tokenLabelPropertyRef_channel(scope,attr) ::= "[<scope> channel]"
tokenLabelPropertyRef_index(scope,attr) ::= "[<scope> tokenIndex]"
tokenLabelPropertyRef_tree(scope,attr) ::= "[<scope>_tree]"

ruleLabelPropertyRef_start(scope,attr) ::= "[<scope> start]"
ruleLabelPropertyRef_stop(scope,attr) ::= "[<scope> stop]"
ruleLabelPropertyRef_tree(scope,attr) ::= "[<scope> tree]"
ruleLabelPropertyRef_text(scope,attr) ::= "[input substringWithRange:NSMakeRange([<scope> start], [<scope> stop]-[<scope> start])]"
ruleLabelPropertyRef_st(scope,attr) ::= "[<scope> st]"

/** Isolated $RULE ref ok in lexer as it's a Token */
lexerRuleLabel(label) ::= "<label>"

lexerRuleLabelPropertyRef_type(scope,attr) ::= "[<scope> type]"
lexerRuleLabelPropertyRef_line(scope,attr) ::= "[<scope> line]"
lexerRuleLabelPropertyRef_pos(scope,attr) ::= "[<scope> charPositionInLine]"
lexerRuleLabelPropertyRef_channel(scope,attr) ::= "[<scope> channel]"
lexerRuleLabelPropertyRef_index(scope,attr) ::= "[<scope> tokenIndex]"
lexerRuleLabelPropertyRef_text(scope,attr) ::= "[<scope> text]"

// Somebody may ref $template or $tree or $stop within a rule:
rulePropertyRef_start(scope,attr) ::= "[retval start]"
rulePropertyRef_stop(scope,attr) ::= "[retval stop]"
rulePropertyRef_tree(scope,attr) ::= "[retval tree]"
rulePropertyRef_text(scope,attr) ::= "[input substringWithRange:NSMakeRange(start, [input index]-start)]"
rulePropertyRef_st(scope,attr) ::= "[retval st]"


/** How to execute an action */
execAction(action) ::= <<
<if(backtracking)>
if ( backtracking==0 ) {
  <action>
}
<else>
<action>
<endif>
>>


// L E X E R  A C T I O N S

emit(type) ::= "[self emit:<type>];"

setType(type) ::= "[self setType:<type>];"

// M I S C (properties, etc...)

bitset(name, words64) ::= <<
const static unsigned long long <name>_data[] = {<words64:{<it>LL};separator=",">};
static ANTLRBitSet *<name>;
<! ANTLRBitSet *<name> = [[ANTLRBitSet alloc] initWithBits:<name>_data count:<length(words64)>];<\n> !>
>>

bitsetInit(name, words64) ::= <<
<name> = [[ANTLRBitSet alloc] initWithBits:<name>_data count:<length(words64)>];<\n>
>>

codeFileExtension() ::= ".m"

true() ::= "YES"
false() ::= "NO"
