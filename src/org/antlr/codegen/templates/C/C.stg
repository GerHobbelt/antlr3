/*
 [The "BSD licence"]
 Copyright (c) 2005 Terence Parr
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
    derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * This code generating snarf blargle template thingy was cobbled together
 * by Jim "Any relation to Eric?" Idle. If it does cause the destruction of the
 * UniVerse, it will be pretty cool so long as I am in a different one at the
 * time. 
 */
group C implements ANTLRCore ;

cTypeInitMap ::= [
	"int"       : "0",              // Integers     start out being 0
	"long"      : "0",              // Longs        start out being 0
	"float"     : "0.0",            // Floats       start out being 0
	"double"    : "0.0",            // Doubles      start out being 0
	"boolean"   : "ANTLR3_FALSE",   // Booleans     start out being Antlr C for false
	"byte"      : "0",              // Bytes        start out being 0
	"short"     : "0",              // Shorts       start out being 0
	"char"      : "0",              // Chars        start out being 0
	default     : "NULL"            // Anything other than an atomic type (above) is a NULL (probably NULL pointer).
]

leadIn(type) ::=
<<
/** \file
 *  This <type> file was generated by $ANTLR version <ANTLRVersion>
 *
 *     -  From the grammar source file : <fileName>
 *     -                            On : <generatedTimestamp>
<if(LEXER)>
 *     -                 for the lexer : <name>Lexer
<endif>
<if(PARSER)>
 *     -                for the parser : <name>Parser
<endif>
<if(TREE_PARSER)>
 *     -           for the tree parser : <name>TreeParser
<endif>
 *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim "Any relation to Eric?" Idle - "jimi" at idledotws
 *
 * View this file with tabs set to 8 (:set ts=8 in gvim) and indent at 4 (:set sw=4 in gvim)
 *
>>

/** The overall file structure of a recognizer; stores methods for rules
 *  and cyclic DFAs plus support code.
 */
outputFile( LEXER,
            PARSER,
            TREE_PARSER,
            actionScope, 
	    backtracking, 
            synpreds, 
            memoize, 
            numRules,
            actions,
            docComment, 
            recognizer,
            name, 
            tokens, 
            tokenNames, 
            rules,
            cyclicDFAs,
            bitsets,
            buildTemplate,
            profile,
            fileName,
            ANTLRVersion,
            generatedTimestamp,
            trace,
            literals
            ) ::=
<<
<leadIn("C source")>
*/
<if(actions.(actionScope).header)>

/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */
<actions.(actionScope).header>
/* End of Header action.
 * =============================================================================
 */
<endif>

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    \<<name>.h\>

/* ----------------------------------------- */

<docComment>

<if(literals)>
/** String literals used by <name> that we must do things like matchs() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
<literals:{static ANTLR3_UCHAR	lit_<i>[]  = <it>;}; separator="\n">

<endif>

/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

<rules: {r |<if(r.ruleDescriptor.ruleScope)>
<ruleAttributeScopeFuncDecl(scope=r.ruleDescriptor.ruleScope)>
<ruleAttributeScopeFuncs(scope=r.ruleDescriptor.ruleScope)>
<endif>}>

<recognizer.scopes:{<if(it.isDynamicGlobalScope)>
<ruleAttributeScopeDef(scope=it)>
<globalAttributeScopeFuncDecl(scope=it)>
<globalAttributeScopeFuncs(scope=it)>
<endif>}>

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

<recognizer>

/* End of code
 * =============================================================================
 */

>>

headerFile( LEXER,
            PARSER,
            TREE_PARSER,
            actionScope, 
            actions,
            docComment, 
            recognizer,
            name, 
            tokens, 
            tokenNames, 
            rules,
            cyclicDFAs,
            bitsets,
            buildTemplate,
            profile,
	    backtracking, 
            synpreds, 
            memoize, 
            numRules,
            fileName,
            ANTLRVersion,
            generatedTimestamp,
            scopes,
            trace
        ) ::=
<<
<leadIn("C header")>
<if(PARSER)>
 * The parser <mainName()>
<endif>
<if(LEXER)>
 * The lexer <mainName()>
<endif>
<if(TREE_PARSER)>
 * The tree parser <mainName()>
<endif>
has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 * 
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef p<name>, which is returned from a call to <name>New().
 *
<if(LEXER)>
 * As this is a generated lexer, it is unlikely you will call it 'manually'. However
 * the entry points are provided anyway.
 *
<endif>
 * The entry points for <name> are  as follows:
 *
 * <rules: {r |  - <headerReturnType(ruleDescriptor=r.ruleDescriptor)>      p<name>-><r.ruleDescriptor.name>(p<name>)}; separator="\n * ">
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.
 */
#ifndef	_<name>_H
#define _<name>_H
<actions.(actionScope).headerfile>
<@includes>

<if(TREE_PARSER)>
/* If this is a tree parser then we need the generic include file for that.
 * Later on I will think through the inheritence thingy and come up with
 * a cunning plan that cannot fail! So, if you see this comment, you are using an
 * early access prototype, as unless I forget, this comment will be taken out once
 * I have swizzled tree node types and so on.
 */

/* =============================================================================
 * Runtime definitions for the generic tree parser
 */
#include \<antlr3treeparser.h>

/* End of runtime definitions for the generic tree parser.
 * =============================================================================
 */
<endif>

/* =============================================================================
 * Standard antlr3 C runtime definitions
 */
#include    \<antlr3.h>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */
<if(backtracking)>
/* Back tracking is enabled
 */
<endif>
<@end>

/** Tricky typedef state to allow dfa states in Cyclic dfas to return the address of the
 *  next dfa state that is predicted for the current dfa state, or the address
 *  of themselves if they predict an alt. :-)
 *
 * \remark
 * In case you can't read this, and I think no less of you if you cannot, 
 * this declares ANTLR3_DFASTATE to be a pointer to a
 * a function that accepts a context pointer and a pointer to the alt, and returns
 * a pointer to a function that accepts a context pointer and a pointer to int and
 * returns a pointer to void (which we then cast to ANTLR3_DFASTATE). There are other ways
 * of doing this such as cascading definitions, but this works just fine.
 *
 * Jim Idle - March 2006
 */
typedef	    void *(*(*ANTLR3_DFASTATE)(p<name>, pANTLR3_UINT32))(p<name>, pANTLR3_UINT32) ;

<rules:{r |<headerReturnScope(ruleDescriptor=r.ruleDescriptor)>}; separator="\n">

<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScopeDecl(scope=it)><endif>}>
<rules:{r |<ruleAttributeScopeDecl(scope=r.ruleDescriptor.ruleScope)>}>
<rules:{r |<ruleAttributeScopeFuncMacro(scope=r.ruleDescriptor.ruleScope)>}>

/** Context tracking structure for <mainName()>
 */
typedef struct <name>_Ctx_struct
{
    /** Built in ANTLR3 context tracker contains all the generic elements
     *  required for context tracking.
     */
<if(PARSER)>
    pANTLR3_PARSER   pParser;
<endif>
<if(LEXER)>
    pANTLR3_LEXER    pLexer;
<endif>
<if(TREE_PARSER)>
    pANTLR3_TREE_PARSER	    pTreeParser;
<endif>
<scopes:{<if(it.isDynamicGlobalScope)>

    <globalAttributeScopeDef(scope=it)>
<endif>}; separator="\n\n">
<rules: {r |<if(r.ruleDescriptor.ruleScope)>

    <ruleAttributeScopeDef(scope=r.ruleDescriptor.ruleScope)>
<endif>}; separator="\n">

<if(LEXER)>
    <rules:{r | <headerReturnType(ruleDescriptor=r.ruleDescriptor)> (*m<r.ruleDescriptor.name>)	(struct <name>_Ctx_struct * ctx<if(r.ruleDescriptor.parameterScope)>, <endif><r.ruleDescriptor.parameterScope:parameterScope(scope=it)>);}; separator="\n";>
<endif>
<if(PARSER)>
    <rules:{r | <headerReturnType(ruleDescriptor=r.ruleDescriptor)> (*<r.ruleDescriptor.name>)	(struct <name>_Ctx_struct * ctx<if(r.ruleDescriptor.parameterScope)>, <endif><r.ruleDescriptor.parameterScope:parameterScope(scope=it)>);}; separator="\n";>
<endif>
<if(TREE_PARSER)>
    <rules:{r | <headerReturnType(ruleDescriptor=r.ruleDescriptor)> (*<r.ruleDescriptor.name>)	(struct <name>_Ctx_struct * ctx<if(r.ruleDescriptor.parameterScope)>, <endif><r.ruleDescriptor.parameterScope:parameterScope(scope=it)>);}; separator="\n";>
<endif>

    void (*free)   (struct <name>_Ctx_struct * ctx);
}
    <name>, * p<name>;

<if(LEXER)>
/* Function protoypes for the lexer functions that external translation units
 * may wish to call.
 */
ANTLR3_API p<name> <name>New         (pANTLR3_INPUT_STREAM     instream);
<endif>
<if(PARSER)>
/* Function protoypes for the parser functions that external translation units
 * may wish to call.
 */
ANTLR3_API p<name> <name>New         (pANTLR3_COMMON_TOKEN_STREAM     instream);
<endif>

/** Symbolic definitions of all the tokens that the <grammarType()> will work with.
 * \{
 *
 * Antlr will define EOF, but we can't use that as it it is too common in
 * in C header files and that would be confusing. There is no way to filter this out at the moment
 * so we just undef it here for now. That isn't the value we get back from C recognizers
 * anyway. We are looking for ANTLR3_TOKEN_EOF.
 */
#ifdef	EOF
#undef	EOF
#endif
 
<tokens:{#define <it.name>      <it.type>}; separator="\n">


/* End of token definitions for <name>
 * =============================================================================
 */
/** \} */



/* MACROS for that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read. If you single step it, you know that input()
 * hides some indirect calls, but is always reffering to the input stream. This is
 * probaly more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritence and wihtout nailing anybody to a cross for 
 * suggesting we just be nice to each other.
 */
<if(LEXER)>
 
/* Macros for access things in a lexer
 */
#undef	    lexr
#undef	    ruleMemo		    
#undef	    getCharIndex
#undef	    getLine
#undef	    getCharPositionInLine
#undef	    emit
#undef	    emitNew
#undef	    matchc
#undef	    matchs
#undef	    matchRange
#undef	    ltoken
#undef	    hasFailed
#undef	    failedFlag
#undef	    theInput
#undef	    LA
#undef	    hasException
#undef	    theException
#undef	    exConstruct
#undef	    inputConsume
#undef	    lrecover
#undef	    markMyWords
#undef	    rewindInput

#define	    lexr		    ctx->pLexer
#define	    ruleMemo		    lexr->rec->ruleMemo
#define	    getCharIndex()	    lexr->getCharIndex(lexr->me)
#define	    getLine()		    lexr->getLine(lexr->me)
#define	    getCharPositionInLine() lexr->getCharPositionInLine(lexr->me)
#define	    emit(t)		    lexr->emit(lexr->me, t)
#define	    emitNew(t,l,cp,ch,s,i)  lexr->emitNew(lexr->me, t, l, cp, ch, s, i)
#define	    matchc(c)		    lexr->matchc(lexr->me, c)
#define	    matchs(s)		    lexr->matchs(lexr->me, s)
#define	    matchRange(c1,c2)	    lexr->matchRange(lexr->me, c1, c2)
#define	    ltoken()		    lexr->token
#define	    hasFailed()		    (lexr->rec->failed == ANTLR3_TRUE)
#define	    failedFlag()	    lexr->rec->failed
#define	    theInput()		    lexr->input
#define	    LA(n)		    theInput()->istream->LA(lexr->input->istream->me, n)
#define	    hasException()	    (theInput()->istream->error == ANTLR3_TRUE)
#define	    theException()	    theInput()->istream->exception
#define	    exConstruct()	    theInput()->istream->exConstruct(theInput()->istream)
#define	    inputConsume()	    theInput()->istream->consume(theInput()->istream->me)
#define	    lrecover()		    lexr->recover(lexr->me)
#define	    markMyWords()	    theInput()->istream->mark(theInput()->istream->me)
#define	    rewindInput(m)	    theInput()->istream->rewind(theInput()->istream->me, m)
<endif>

<if(PARSER)>
/* Macros for accessing things in the parser
 */
 
#undef	    prsr		    
#undef	    haveAlreadyParsedRule
#undef	    theInput
#undef	    hasException
#undef	    theException
#undef	    tmatch
#undef	    tmatchAny
#undef	    followStk
#undef	    followPush
#undef	    followPop
#undef	    precover
#undef	    preportError
#undef	    LA
#undef	    LT
#undef	    exConstruct
#undef	    inputConsume
#undef	    markMyWords
#undef	    rewindInput
#undef	    perrorRecovery
#undef	    hasFailed
#undef	    failedFlag
#undef	    precoverFromMismatchedSet
#undef	    precoverFromMismatchedElement

#define	    prsr		    ctx->pParser  
#define	    haveAlreadyParsedRule(r) prsr->rec->alreadyParsedRule(prsr->me, r)
#define	    theInput()		    prsr->tstream
#define	    hasException()	    (theInput()->istream->error == ANTLR3_TRUE)
#define	    theException()	    theInput()->istream->exception
#define	    tmatch(t, fs)	    prsr->rec->match(prsr->rec, theInput()->istream, t, fs)
#define	    tmatchAny()		    prsr->rec->matchAny(prsr->rec, theInput()->istream->me)
#define	    followStk()		    prsr->rec->following
#define	    followPush(x)	    followStk()->push(followStk(), ((void *)(x)), NULL)
#define	    followPop()		    followStk()->pop(followStk())
#define	    precover()		    prsr->rec->recover(prsr->me, theInput()->istream)
#define	    preportError()	    prsr->rec->reportError(prsr)
#define	    LA(n)		    theInput()->istream->LA(theInput()->me, n)
#define	    LT(n)		    theInput()->LT(theInput()->me, n)
#define	    exConstruct()	    theInput()->istream->exConstruct(theInput()->istream)
#define	    inputConsume()	    theInput()->istream->consume(theInput()->istream->me)
#define	    markMyWords()	    theInput()->istream->mark(theInput()->istream->me)
#define	    rewindInput(m)	    theInput()->istream->rewind(theInput()->istream->me, m)
#define	    perrorRecovery()	    prsr->rec->errorRecovery
#define	    hasFailed()		    prsr->rec->failed
#define	    precoverFromMismatchedSet(s)	prsr->rec->recoverFromMismatchedSet(prsr->rec, theInput()->istream, s)
#define	    precoverFromMismatchedElement(e)	prsr->rec->recoverFromMismatchedElement(prsr->rec, theInput()->istream, s)
<endif>

#endif
>>

grammarType() ::= <<
<if(PARSER)>
parser
<endif>
<if(LEXER)>
lexer
<endif>
<if(TREE_PARSER)>
tree parser
<endif>
>>

mainName() ::= <<
<if(PARSER)>
<name>
<endif>
<if(LEXER)>
<name>
<endif>
<if(TREE_PARSER)>
<name>
<endif>
>>

headerReturnScope(ruleDescriptor) ::= "<returnScope(scope=ruleDescriptor.returnScope)>"

headerReturnType(ruleDescriptor) ::= "<returnType()>"

// Produce the lexer output
//
lexer(  name, 
        tokens,
        scopes, 
        rules, 
        numRules, 
        cyclicDFAs, 
        labelType="pANTLR_COMMON_TOKEN",
        filterMode) ::= <<

<if(filterMode)>
/* Forward declare implementation function for ANTLR3_TOKEN_SOURCE interface.
 */
static pANTLR3_COMMON_TOKEN <name>NextToken   (pANTLR3_LEXER          lexerContext);
<endif>

/* Forward declare the locally static matching functions we have generated.
 */
<rules:{r | static <headerReturnType(ruleDescriptor=r.ruleDescriptor)>	m<r.ruleDescriptor.name>    (p<name> ctx<if(r.ruleDescriptor.parameterScope)>, <endif><r.ruleDescriptor.parameterScope:parameterScope(scope=it)>);}; separator="\n";>
static void	<name>Free(p<name> ctx);

<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>

<actions.lexer.members>

static void
<name>Free  (p<name> ctx)
{
<if(memoize)>
    ruleMemo->free(ruleMemo->me);
<endif>
    lexr->free(lexr->me);
    
    ANTLR3_FREE(ctx);
}

<if(filterMode)>
    <filteringNextToken()>
<endif>

/** \brief Create a new lexer called <name>
 *
 * \param[in] instream Pointer to an initialized input stream
 *
 * \return 
 *     - Success p<name> initialized for the lex start
 *     - Fail (p<name>)(ANTLR3_ERR_NOMEM)
 */
ANTLR3_API p<name> <name>New         (pANTLR3_INPUT_STREAM     instream)
{
    p<name> lexCtx; /* Context structure we will build and return   */

    lexCtx = (p<name>) ANTLR3_MALLOC(sizeof(<name>));

    if  (lexCtx == NULL)
    {
        /* Failed to allocate memory for lexer context */
        return  (p<name>)ANTLR3_ERR_NOMEM;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We intialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in <name>.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    lexCtx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream);

<if(memoize)>
    /* Create a LIST for recording rule memos.
     */
    lexCtx->pLexer->rec->ruleMemo    = antlr3ListNew(ANTLR3_SIZE_HINT);
<endif>

    /* Install the implementation of our <name> interface
     */
    <rules:{r | lexCtx->m<r.ruleDescriptor.name>	= m<r.ruleDescriptor.name>;}; separator="\n";>
    
    /** When the nextToken() call is made to this lexers's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    lexCtx->pLexer->ctx	    = lexCtx;
    
    /** Install the token matching function
     */
    lexCtx->pLexer->mTokens = mTokens;
    
    lexCtx->free    = <name>Free;
    
<if(filterMode)>
    /* We have filter mode turned on, so install the filtering nextToken function
     */
    lexCtx->lexer->tokSource->nextToken = <name>NextToken;
<endif>

    /* Return the newly built lexer to the caller
     */
    return  lexCtx;
}

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

<rules; separator="\n\n">

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */

/* =========================================================================
* Lexer syntactic predicates
*/
<synpreds:{p | <lexerSynpred(name=p)>}>
/* =========================================================================
 * Lexer syntactic predicates end.
 * =========================================================================
 */
 
/* =========================================================================
* Cyclic DFAs for the lexer
*/
<cyclicDFAs>

>>

/** An override of the lexer's nextToken() method that backtracks over mTokens() looking
 *  for matches.  No error can be generated upon error; just rewind, consume
 *  a token and then try again.  backtracking needs to be set as well.
 */
filteringNextToken() ::= <<
ANTLR3_API ANTLR3_TOKEN <name>nextToken(p<name> lexCtx) 
{
    ltoken  = NULL;
    tokenStartCharIndex = getCharIndex();
    while (true) {
        if ( LA(1)==CharStream.EOF ) {
            return Token.EOF_TOKEN;
        }
        try {
            int m = input.mark();
            backtracking=1;
            failed=false;
            mTokens();
            backtracking=0;
            input.rewind(m);
            if ( failed ) {
                input.consume(); <! // advance one char and try again !>
            }
            else {
                mTokens();
                return token;
            }
        }
        catch (RecognitionException re) {
            // shouldn't happen in backtracking mode, but...
            reportError(re);
            recover(re);
        }
    }
}
>>

/** How to generate a parser */
genericParser(  name, 
                scopes, 
                tokens, 
                tokenNames, 
                rules, 
                numRules,
                cyclicDFAs,
                bitsets,
                inputStreamType,
                superClass,
                ASTLabelType="Object",
                labelType,
				members
              ) ::= <<

/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
static pANTLR3_UINT8   <name>TokenNames[]
     = {
        (pANTLR3_UINT8) "\<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "\<EOR>",
        (pANTLR3_UINT8) "\<DOWN>", 
        (pANTLR3_UINT8) "\<UP>", 
        <tokenNames:{(pANTLR3_UINT8) <it>}; separator=",\n">
       };

    <@members>

    <@end>

/* Forward declare the locally static matching functions we have generated.
 */
<rules:{r | static <headerReturnType(ruleDescriptor=r.ruleDescriptor)>	<r.ruleDescriptor.name>    (p<name> ctx<if(r.ruleDescriptor.parameterScope)>, <endif><r.ruleDescriptor.parameterScope:parameterScope(scope=it)>);}; separator="\n";>
static void	<name>Free(p<name> ctx);

/* Function to initlize bitsets
 */
static	void <name>LoadFollowSets();

<cyclicDFAs:{dfa | <cyclicDFADeclare(decisionNumber=dfa.decisionNumber,states=dfa.states)>}>

/** \brief Create a new <name> parser and retrun a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API p<name>
<name>New   (<inputStreamType> instream)
{
    p<name> ctx;	    /* Context structure we will build and return   */
    
    ctx	= (p<name>) ANTLR3_MALLOC(sizeof(<name>));
    
    if	(ctx == NULL)
    {
	/* Failed to allocate memory for parser context */
        return  (p<name>)ANTLR3_ERR_NOMEM;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We intialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in <name>.h here so you can get a sense
     * of what goes where.
     */

<if(PARSER)>
    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream);
<endif>
<if(TREE_PARSER)>
    /* Create a base Tree parser/recognizer, using the supplied token stream
     */
    ctx->pTreeParser	    = antlr3TreeParserNewStream(instream);
<endif>


    /* Install the implementation of our <name> interface
     */
    <rules:{r | ctx-><r.ruleDescriptor.name>	= <r.ruleDescriptor.name>;}; separator="\n";>

    ctx->free    = <name>Free;
    
    /* Install the scope pushing methods.
     */
    <rules: {r |<if(r.ruleDescriptor.ruleScope)>
<ruleAttributeScope(scope=r.ruleDescriptor.ruleScope)><\n>
<endif>}>
    <recognizer.scopes:{<if(it.isDynamicGlobalScope)>
<globalAttributeScope(scope=it)><\n>
<endif>}>
    
    /* Initialize the follo bit sets
     */
    <name>LoadFollowSets();
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 <name>Free(p<name> ctx)
 {
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);
 }
 
/** Return token names used by this <grammarType()>
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return <name>TokenNames; 
}

    <members>
    
/* Declare the bitsets
 */
<bitsets:bitsetDeclare(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
                    words64=it.bits)>
     
/** Load up the static bitsets for following set for error recovery.
 *  \remark
 *  These are static after the parser is generated, hence they are static
 *  delcarations in the parser and are thread safe after initialization.
 */
static
void <name>LoadFollowSets()
{

    <bitsets:bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
                    words64=it.bits)>
    return;
}
               
<rules; separator="\n\n">

<! define a singleton instance for each cyclic DFA then define DFAs !>
<cyclicDFAs>

<synpreds:{p | <synpred(name=p)>}>


 
 


>>

parser(name, scopes, tokens, tokenNames, rules, numRules, cyclicDFAs, bitsets, ASTLabelType, superClass="Parser", labelType="pANTLR3_COMMON_TOKEN", members={<actions.parser.members>}) ::= <<
<genericParser(inputStreamType="pANTLR3_COMMON_TOKEN_STREAM", ...)>
>>

/** How to generate a tree parser; same as parser except the input
 *  stream is a different type.
 */
treeParser(name, scopes, tokens, tokenNames, globalAction, rules, numRules, cyclicDFAs, bitsets, labelType={<ASTLabelType>}, ASTLabelType="Object", superClass="TreeParser", members={<actions.treeparser.members>}) ::= <<
<genericParser(inputStreamType="TreeNodeStream", ...)>
>>

synpred(name) ::= <<
class <name>Ptr implements GrammarFragmentPtr {
    public void invoke() throws RecognitionException {<name>_fragment();}
}
<name>Ptr <name> = new <name>Ptr();<\n>
>>

lexerSynpred(name) ::= <<
class <name>Ptr implements GrammarFragmentPtr {
    public void invoke() throws RecognitionException {m<name>_fragment();}
}
<name>Ptr <name> = new <name>Ptr();<\n>
>>

ruleMemoization(name) ::= <<
<if(memoize)>
if ( backtracking>0 && haveAlreadyParsedRule(<ruleDescriptor.index>) )
{
    return <ruleReturnValue()>; 
}
<endif>
>>

/** How to test for failure and return from rule */
checkRuleBacktrackFailure() ::= <<
<if(backtracking)>
/* checkRuleBacktrackFailure()
 */
if (hasFailed())
{
    return <ruleReturnValue()>;
}
<endif>
>>

/** This rule has failed, exit indicating failure during backtrack */
ruleBacktrackFailure() ::= <<
<if(backtracking)>
/* ruleBacktrackFailure()
 */
if (backtracking>0)
{
    failedFlag() = <true()>; 
    return <ruleReturnValue()>;
}
<endif>
>>

/** How to generate code for a rule.  This includes any return type
 *  data aggregates required for multiple return values.
 */
rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions) ::= <<
/* rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions)
 * 
 * $ANTLR start <ruleName>
 * <fileName>:<description>
 */
static <returnType()>
<ruleName>(p<name> ctx<if(ruleDescriptor.parameterScope)>, <endif><ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{   
    <if(trace)>printf("enter <ruleName> %s failed=%d, backtracking=%d\n", LT(1), backtracking);<endif>
    <ruleDeclarations()>
    <ruleLabelDefs()>
    <ruleInitializations()>
    <ruleLabelInitializations()>
    <ruleDescriptor.actions.init>
    <@preamble()>
    <ruleMemoization(name=ruleName)>
    {
        <block>
    }
    
<ruleCleanUp()>
<if(exceptions)>
    <exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
<else>
<if(!emptyRule)>
    if (hasException())
    {
        preportError();
        precover();
    }<\n>
<endif>
<endif>
    <if(trace)>System.out.println("exit <ruleName> "+LT(1)+" failed="+failed+" backtracking="+backtracking);<endif>


    <@postamble()>
    return <ruleReturnValue()>;
}
// $ANTLR end <ruleName>
>>

catch(decl,action) ::= <<
/* catch(decl,action)
 */
if  (hasException() && theException()->type == <e.decl> )
{
    <e.action>
}
>>

ruleDeclarations() ::= <<
/* ruleDeclarations()
 */
<if(ruleDescriptor.hasMultipleReturnValues)>
<returnType()> retval;
<else>
<if(ruleDescriptor.hasSingleReturnValue)>
<returnType()> <ruleDescriptor.singleValueReturnName>;
<endif>
<endif>
<if(memoize)>
ANTLR3_UINT64 <ruleDescriptor.name>_StartIndex;
<endif>
>>

ruleInitializations() ::= <<
/* Initilalize rule variables
 */
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.start = LT(1);<\n>
<endif>
<if(memoize)>
<ruleDescriptor.name>_StartIndex = input.index();
<endif>
<ruleDescriptor.useScopes:{<scopeTop(sname=it.name)> = <scopePush(sname=it.name)>;}; separator="\n">
<ruleDescriptor.ruleScope:{<scopeTop(sname=it.name)> = <scopePush(sname=it.name)>;}; separator="\n">
/* End ruleDeclarations()
 */
>>

ruleLabelDefs() ::= <<
/* ruleLabelDefs()
 */
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels]
    :{<labelType>    <it.label.text>;}; separator="\n"
>
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels]
    :{pANLTR3_LIST    list_<it.label.text>;}; separator="\n"
>
<[ruleDescriptor.ruleLabels,ruleDescriptor.ruleListLabels]
    :ruleLabelDef(label=it); separator="\n"
>
<[ruleDescriptor.allRuleRefsInAltsWithRewrites,ruleDescriptor.allTokenRefsInAltsWithRewrites]
    :{pANLTR3_LIST     list_<it>;}; separator="\n"
>
>>

ruleLabelInitializations() ::= <<
/* ruleLabelInitializations()
 */
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels]
    :{<it.label.text>       = NULL;}; separator="\n"
>
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels]
    :{list_<it.label.text>     = NULL;}; separator="\n"
>
<[ruleDescriptor.ruleLabels,ruleDescriptor.ruleListLabels]
    :ruleLabelDef(label=it); separator="\n"
>
<[ruleDescriptor.allRuleRefsInAltsWithRewrites,ruleDescriptor.allTokenRefsInAltsWithRewrites]
    :{list_<it>=antlr3ListNew(ANTLR3_SIZE_HINT);}; separator="\n"
>
>>

ruleReturnValue() ::= <<
<if(ruleDescriptor.hasReturnValue)>
<if(ruleDescriptor.hasSingleReturnValue)>
<ruleDescriptor.singleValueReturnName>
<else>
retval
<endif>
<endif>
>>

ruleCleanUp() ::= <<
/* ruleCleanUp()
 */
<if(memoize)>
<if(backtracking)>
if ( backtracking>0 ) { memoize(input, <ruleDescriptor.index>, <ruleDescriptor.name>_StartIndex); }
<endif>
<endif>
goto rule<ruleDescriptor.name>Ex; /* Prevent compiler warnings */
rule<ruleDescriptor.name>Ex: ;
<ruleDescriptor.useScopes:{<scopePop(sname=it)>;}; separator="\n">
<ruleDescriptor.ruleScope:{<scopePop(sname=it.name)>;}; separator="\n">
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.stop = LT(-1);
<endif>

>>

/** How to generate a rule in the lexer; naked blocks are used for
 *  fragment rules, which do not produce tokens.
 */
lexerRule(ruleName,nakedBlock,ruleDescriptor,block) ::= <<
/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start <ruleName>
 *
 * Looks to match the chracters the constitute the token <ruleName>
 * from the attached input stream.
 *
 * Comes from: <block.description>
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void m<ruleName>(p<name> ctx<if(ruleDescriptor.parameterScope)>, <endif><ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{

    <if(trace)>System.out.println("enter <ruleName> '"+(char)LA(1)+"' line="+getLine()+":"+getCharPositionInLine()+" failed="+failed+" backtracking="+backtracking);<endif>
    <ruleDeclarations()>
        
<if(nakedBlock)>
    <ruleDescriptor.actions.init>
    <ruleMemoization(name=ruleName)>
        
    <block><\n>
<else>
    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    type		= <ruleName>;
    start		= getCharIndex();
    line		= getLine();
    charPosition	= getCharPositionInLine();
    channel		= ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    <ruleDescriptor.actions.init>
    <ruleMemoization(name=ruleName)>
    
    <block>
        
    if ( ltoken() == NULL && !hasException()) 
    {
	emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
    }
<endif>
        <if(trace)>System.out.println("exit <ruleName> '"+(char)LA(1)+"' line="+getLine()+":"+getCharPositionInLine()+" failed="+failed+" backtracking="+backtracking);<endif>
    <ruleCleanUp()>
}
// $ANTLR end <ruleName>
>>

/** How to generate code for the implicitly-defined lexer grammar rule
 *  that chooses between lexer rules.
 */
tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
/* tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor)
 */
/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(p<name> ctx)
{
    <block><\n>
    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}
>>

// S U B R U L E S

/** A (...) subrule with multiple alternatives */
block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<

/* block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
 *
 * <fileName>:<description>
 */
{
    int alt<decisionNumber>=<maxAlt>;
    <decls>
    <@predecision()>
    <decision>
    <@postdecision()>
    <@prebranch()>
    switch (alt<decisionNumber>) 
    {
	<alts:altSwitchCase()>
    }
    <@postbranch()>
}
>>

/** A rule block with multiple alternatives */
ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
{
    /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
    *
    * <fileName>:<description>
    */
    ANTLR3_UINT32 alt<decisionNumber>;

    alt<decisionNumber>=<maxAlt>;

    <decls>
    <@predecision()>
    <decision>
    <@postdecision()>
    switch (alt<decisionNumber>) 
    {
	<alts:altSwitchCase()>
    }
}
>>

ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
/* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
 * <fileName>:<description>
 */
<decls>
<@prealt()>
<alts>
<@postalt()>
>>

/** A special case of a (...) subrule with a single alternative */
blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
/* blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) 
 * <fileName>:<description>
 */
<decls>
<@prealt()>
<alts>
<@postalt()>
>>

/** A (..)+ block with 0 or more alternatives */
positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
/* positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) 
 * <fileName>:<description>
 */
{
    int cnt<decisionNumber>=0;
    <decls>
    <@preloop()>

    for (;;)
    {
        int alt<decisionNumber>=<maxAlt>;
	<@predecision()>
	<decision>
	<@postdecision()>
	switch (alt<decisionNumber>) 
	{
	    <alts:altSwitchCase()>
	    default:
	    
		if ( cnt<decisionNumber> >= 1 )
		{
		    goto loop<decisionNumber>; /* Ah well, generated code or I'd shoot myself */
		}
		<ruleBacktrackFailure()>
		<earlyExitEx()>
		<@earlyExitException()>
		goto rule<ruleDescriptor.name>Ex;
	}
	cnt<decisionNumber>++;
    }
    loop<decisionNumber>: ;	/* Jump to here if this rule does not match */
    <@postloop()>
}
>>

earlyExitEx() ::= <<
/* mismatchedSetEx()
 */
exConstruct();
theException()->type = ANTLR3_EARLY_EXIT_EXCEPTION;
theException()->name = ANTLR3_MISMATCHED_SET_NAME;
<\n>
>>
positiveClosureBlockSingleAlt ::= positiveClosureBlock

/** A (..)* block with 0 or more alternatives */
closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<

/* closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) 
 *
 * <fileName>:<description>
 */
<decls>

<@preloop()>
for (;;)
{
    int alt<decisionNumber>=<maxAlt>;
    <@predecision()>
    <decision>
    <@postdecision()>
    switch (alt<decisionNumber>) 
    {
	<alts:altSwitchCase()>
	default:
	    goto loop<decisionNumber>;	/* break out of the loop */
	    break;
    }
}
loop<decisionNumber>: ; /* Jump out to here if this rule does not match */
<@postloop()>
>>

closureBlockSingleAlt ::= closureBlock

/** Optional blocks (x)? are translated to (x|) by before code generation
 *  so we can just use the normal block template
 */
optionalBlock ::= block

optionalBlockSingleAlt ::= block

/** A case in a switch that jumps to an alternative given the alternative
 *  number.  A DFA predicts the alternative and then a simple switch
 *  does the jump to the code that actually matches that alternative.
 */
altSwitchCase() ::= <<
/* altSwitchCase()
 */
case <i>:
    <@prealt()>
    <it>
    break;<\n>
>>

/** An alternative is just a list of elements; at outermost level */
alt(elements,altNum,description,autoAST,outerAlt) ::= <<
/* alt(elements,altNum,description,autoAST,outerAlt)
 * <fileName>:<description>
 */
<@declarations()>
<elements:element()>
<@cleanup()>
>>

// E L E M E N T S

/** Dump the elements one per line */
element() ::= <<
/* element()
 */
<@prematch()>
<it.el><\n>
>>

/** match a token optionally with a label in front */
tokenRef(token,label,elementIndex) ::= <<
/* tokenRef(token,label,elementIndex)
 */
<if(label)>
<label> = (<labelType>)LT(1);<\n>
<endif>
tmatch(<token>, FOLLOW_<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
>>

/** ids+=ID */
tokenRefAndListLabel(token,label,elementIndex) ::= <<
/* tokenRefAndListLabel(token,label,elementIndex)
 */
<tokenRef(...)>
<listLabel(...)>
>>

listLabel(label) ::= <<
/* listLabel(label)
 */
if (list_<label> == NULL)
{
    list_<label>=antlr3NewList(ANTLR3_LIST_SIZE_HINT);
}
list_<label>->put(list_<label>, (ANTLR3_UINT64)<label>, NULL, NULL);<\n>
>>

/** match a character */
charRef(char,label) ::= <<
/* charRef(char,label)
 */
<if(label)>
<label> = LA(1);<\n>
<endif>
matchc(<char>); <checkRuleBacktrackFailure()>
>>

/** match a character range */
charRangeRef(a,b) ::= <<
/* charRangeRef(a,b)
 */
matchRange(<a>, <b>); <checkRuleBacktrackFailure()>
>>

/** For now, sets are interval tests and must be tested inline */
matchSet(s,label,elementIndex,postmatchCode="") ::= <<
/* matchSet(s,label,elementIndex,postmatchCode="")
 */
<if(label)>
<label>=(<labelType>)LT(1);<\n>
<endif>
if ( <s> ) 
{
    <postmatchCode>
    inputConsume();
<if(!LEXER)>
    perrorRecovery()=ANTLR3_FALSE;
<endif>
    <if(backtracking)>weFailed()=ANTLR3_FALSE;<endif>
}
else 
{
    <ruleBacktrackFailure()>
    <mismatchedSetEx()>
    <@mismatchedSetException()>
<if(LEXER)>
    lrecover();
<else>
    precoverFromMismatchedSet(FOLLOW_set_in_<ruleName><elementIndex>);
<endif>
    goto rule<ruleDescriptor.name>Ex;
}<\n>
>>

mismatchedSetEx() ::= <<
/* mismatchedSetEx()
 */
exConstruct();
theException()->type = ANTLR3_MISMATCHED_SET_EXCEPTION;
theException()->name = ANTLR3_MISMATCHED_SET_NAME;
>>

matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
/* matchSetAndListLabel(s,label,elementIndex,postmatchCode)
 */
<matchSet(...)>
<listLabel(...)>
>>

/** Match a string literal */
lexerStringRef(string,label) ::= <<
/* lexerStringRef(string,label)
 */
<if(label)>
int <label>Start = getCharIndex();
matchs(<string>); <checkRuleBacktrackFailure()>
<labelType> <label> = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, <label>Start, getCharIndex()-1);
<else>
matchs(<string>); <checkRuleBacktrackFailure()><\n>
<endif>
>>

wildcard(label,elementIndex) ::= <<
/* wildcard(label,elementIndex)
 */
<if(label)>
<label>=(<labelType>)LT(1);<\n>
<endif>
matchAny(input); <checkRuleBacktrackFailure()>
>>

wildcardAndListLabel(label,elementIndex) ::= <<
/* wildcardAndListLabel(label,elementIndex)
 */
<wildcard(...)>
<listLabel(...)>
>>

/** Match . wildcard in lexer */
wildcardChar(label, elementIndex) ::= <<
/* wildcardChar(label, elementIndex)
 */
<if(label)>
int <label> = LA(1);<\n>
<endif>
matchAny(); <checkRuleBacktrackFailure()>
>>

wildcardCharListLabel(label, elementIndex) ::= <<
/* wildcardCharListLabel(label, elementIndex)
 */
<wildcardChar(...)>
<listLabel(...)>
>>

/** Match a rule reference by invoking it possibly with arguments
 *  and a return value or values.
 */
ruleRef(rule,label,elementIndex,args) ::= <<
/* ruleRef(rule,label,elementIndex,args)
 */
followPush(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<if(label)>
<label>=<rule>(ctx<if(args)>, <args><endif>);<\n>
<else>
<rule>(ctx<if(args)>, <args><endif>);<\n>
<endif>
if  (hasException())
{
    goto rule<ruleDescriptor.name>Ex;
}
followPop();
<checkRuleBacktrackFailure()>
>>

/** ids+=ID */
ruleRefAndListLabel(rule,label,elementIndex,args) ::= <<
/* ruleRefAndListLabel(rule,label,elementIndex,args)
 */
<ruleRef(...)>
<listLabel(...)>
>>

/** A lexer rule reference */
lexerRuleRef(rule,label,args) ::= <<
/* lexerRuleRef(rule,label,args)
 * From: <description>
 */
<if(label)>
int <label>Start = getCharIndex();
m<rule>(ctx <if(args)>, <endif><args>); <checkRuleBacktrackFailure()>
<labelType> <label> = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, <label>Start, getCharIndex()-1);
<else>
m<rule>(ctx <if(args)>, <endif><args>); <checkRuleBacktrackFailure()>
<endif>
>>

/** EOF in the lexer */
lexerMatchEOF(label) ::= <<
/* lexerMatchEOF(label)
 */
<if(label)>
int <label>Start = getCharIndex();
matchc(ANTLR3_CHARSTREAM_EOF); <checkRuleBacktrackFailure()>
<labelType> <label> = new CommonToken(input, EOF, Token.DEFAULT_CHANNEL, <label>Start, getCharIndex()-1);
<else>
matchc(ANTLR3_CHARSTREAM_EOF); <checkRuleBacktrackFailure()>
<endif>
>>

/** match ^(root children) in tree parser */
tree(root, children) ::= <<
/* tree(root, children)
 */
<root:element()>
match(input, Token.DOWN, null); <checkRuleBacktrackFailure()>
<children:element()>
match(input, Token.UP, null); <checkRuleBacktrackFailure()>
>>

/** Every predicate is used as a validating predicate (even when it is
 *  also hoisted into a prediction expression).
 */
validateSemanticPredicate(pred,description) ::= <<
/* validateSemanticPredicate(pred,description) 
 */
if ( !(<evalPredicate(...)>) ) 
{
    <ruleBacktrackFailure()>
    <newFPE(...)>
}
>>

newFPE() ::= <<
    /* newNVException()
     */
    exConstruct();
    theException()->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
    theException()->message      = "<description>";
    theException()->ruleName	 = "<ruleName>";
    <\n>
>>

// F i x e d  D F A  (if-then-else)

dfaState(k,edges,eotPredictsAlt,description,stateNumber) ::= <<

/* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
 */
{
    int LA<decisionNumber>_<stateNumber> = LA(<k>);

    <edges; separator="\nelse ">
    else 
    {
<if(eotPredictsAlt)>
        alt<decisionNumber>=<eotPredictsAlt>;
<else>
        <ruleBacktrackFailure()>
    
        <newNVException()>    
        goto rule<ruleDescriptor.name>Ex;

<endif>
    }
}
>>

newNVException() ::= <<
/* newNVException()
 */
exConstruct();
theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
theException()->message      = "<description>";
theException()->decisionNum  = <decisionNumber>;
theException()->state        = <stateNumber>;
<@noViableAltException()>
<\n>
>>

/** Same as a normal DFA state except that we don't examine lookahead
 *  for the bypass alternative.  It delays error detection but this
 *  is faster, smaller, and more what people expect.  For (X)? people
 *  expect "if ( LA(1)==X ) match(X);" and that's it.
 */
dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
/* dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber)
 */
int LA<decisionNumber>_<stateNumber> = LA(<k>);
<edges; separator="\nelse ">
>>

/** A DFA state that is actually the loopback decision of a closure
 *  loop.  If end-of-token (EOT) predicts any of the targets then it
 *  should act like a default clause (i.e., no error can be generated).
 *  This is used only in the lexer so that for ('a')* on the end of a rule
 *  anything other than 'a' predicts exiting.
 */
dfaLoopbackStateDecls()::= <<
/* dfaLoopbackStateDecls(decisionNumber)
 */
ANTLR3_UINT32   LA<decisionNumber>_<stateNumber>;
>>
dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
{
   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber)
    */
    int LA<decisionNumber>_<stateNumber> = LA(<k>);
    <edges; separator="\nelse "><\n>
    <if(eotPredictsAlt)>
    else 
    {
	alt<decisionNumber>=<eotPredictsAlt>;
    }<\n>
    <endif>
}
>>

/** An accept state indicates a unique alternative has been predicted */
dfaAcceptState(alt) ::= "alt<decisionNumber>=<alt>; /* dfaAcceptState(alt) */"

/** A simple edge with an expression.  If the expression is satisfied,
 *  enter to the target state.  To handle gated productions, we may
 *  have to evaluate some predicates for this edge.
 */
dfaEdge(labelExpr, targetState, predicates) ::= <<
/* dfaEdge(labelExpr, targetState, predicates)
 */
if ( <labelExpr> <if(predicates)>&& <predicates><endif>) 
{
    <targetState>
}
>>

// F i x e d  D F A  (switch case)

/** A DFA state where a SWITCH may be generated.  The code generator
 *  decides if this is possible: CodeGenerator.canGenerateSwitch().
 */
dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
/* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber)
 */
switch ( LA(<k>) ) 
{
<edges; separator="\n">

default:
<if(eotPredictsAlt)>
    alt<decisionNumber>=<eotPredictsAlt>;
<else>
    <ruleBacktrackFailure()>
    <newNVException()>
    goto rule<ruleDescriptor.name>Ex;<\n>
<endif>
}<\n>
>>

dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
/* dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber)
 */
switch ( LA(<k>) ) 
{
    <edges; separator="\n">
}<\n>
>>

dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber) ::= <<
/* dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber)
 */
switch ( LA(<k>) ) 
{
<edges; separator="\n"><\n>
<if(eotPredictsAlt)>
default:
    alt<decisionNumber>=<eotPredictsAlt>;
    break;<\n>
<endif>
}<\n>
>>

dfaEdgeSwitch(labels, targetState) ::= <<
/* dfaEdgeSwitch(labels, targetState)
 */
<labels:{case <it>:}; separator="\n">
    <targetState>
    break;
>>

// C y c l i c  D F A

/** The code to initiate execution of a cyclic DFA; this is used
 *  in the rule to predict an alt just like the fixed DFA case.
 *  The <name> attribute is inherited via the parser, lexer, ...
 */
dfaDecision(decisionNumber,description) ::= <<
/* dfaDecision(decisionNumber,description)
 */
alt<decisionNumber> = dfa<decisionNumber>Predict(ctx); <checkRuleBacktrackFailure()>
>>

cyclicDFADeclare(decisionNumber,states) ::= <<
/* Prediction routine for DFA #<decisionNumber>
 */
static ANTLR3_UINT32 dfa<decisionNumber>Predict(p<name> ctx);
<states:{state | <DFAStateDeclare(decisionNumber=dfa.decisionNumber,state=state)>}>
>>
DFAStateDeclare(decisionNumber,state) ::= <<
static ANTLR3_DFASTATE dfa<decisionNumber>S<state.stateNumber> (p<name>, pANTLR3_UINT32);<\n>
>>

/** The overall cyclic DFA chunk; contains all the DFA states */
cyclicDFA(className,ruleName,ruleDescriptor,decisionNumber,states,description) ::= <<
/* cyclicDFA(className,ruleName,ruleDescriptor,decisionNumber,states,description)
 */
/** Local function to evalute the static states and predict the
 *  alternative states from decision #<decisionNumber>
 *  cf: <description>
 */
static ANTLR3_UINT32 dfa<decisionNumber>Predict(p<name> ctx)
{
    ANTLR3_UINT32	alt;	    /* Alternate that is transitioned and finally selected */
    ANTLR3_DFASTATE	next;	    /* Where to go next if we don't predict an alt */
    ANTLR3_UINT64	mark;	    /* So we can rewind if we predict successfully  */
    
    alt	    = 0;		/* Nothing predicted yet    */
    next    = NULL;
    
    mark    = markMyWords();	/* Stamp the input */
    
    /* Call state 0 and see where we end up!
     */
    next    = (ANTLR3_DFASTATE)dfa<decisionNumber>S0;
    do
    {
	next    = (ANTLR3_DFASTATE)(*next)(ctx, &alt); 
	
	if  (next == NULL || hasException())
	{
	    /* Nothing predicted - select alt 1 */
	    return  1;
	}
	
	if  (alt \<= 0)
	{
	    inputConsume();
	}
    }
    while
	(alt \<= 0 && !hasException());

    return alt;		/* May be invalid if an exception is outstanding. */
}

/* DFA state functions for DFA #<decisionNumber>
 */
<states>
>>

/** A state in a cyclic DFA */
cyclicDFAState(stateNumber,edges,needErrorClause) ::= <<
/* cyclicDFAState(stateNumber,edges,needErrorClause)
 */
static ANTLR3_DFASTATE
dfa<decisionNumber>S<stateNumber>(p<name> ctx, pANTLR3_UINT32 alt)
{
    

    ANTLR3_INT32    LA<decisionNumber>_<stateNumber> = LA(1);
    
    <edges>
    <if(needErrorClause)>
    <if(backtracking)>
    if (backtracking>0)
    {
	failedFlag()=ANTLR3_TRUE; 
	return (ANTLR3_DFASTATE)NULL;
    }
    <endif>
    <newNVException(...)>
    <@noViableAltException()>
    return (ANTLR3_DFASTATE)NULL;
    <endif>
}<\n>
>>

/** An accept state for a cyclic DFA */
cyclicDFAAcceptState(stateNumber,predictAlt) ::= <<
/* cyclicDFAAcceptState(stateNumber,predictAlt)
 */
static ANTLR3_DFASTATE
dfa<decisionNumber>S<stateNumber>(p<name> ctx, pANTLR3_UINT32 alt)
{
    *alt = <predictAlt>;
    
    /* This dfa is at an end, we will pick that up from the fact 
     * that we set an alt. We return ourselves as NULL singifies a
     * backtracking or other error.
     */
    return  (ANTLR3_DFASTATE)dfa<decisionNumber>S<stateNumber>;
};<\n>
>>

/** Just like a fixed DFA edge, test the lookahead and indicate what
 *  state to jump to next if successful.
 */
cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
/* cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates)
 */
if ( <labelExpr> <if(predicates)>&& <predicates><endif>)
{
    return (ANTLR3_DFASTATE)dfa<decisionNumber>S<targetStateNumber>;
}<\n>
>>

/** An edge pointing at end-of-token; essentially matches any char;
 *  always jump to the target.
 */
eotDFAEdge(targetStateNumber,edgeNumber, predicates) ::= <<
return (ANTLR3_DFASTATE)dfa<decisionNumber>S<targetStateNumber>; /* eotDFAEdge(targetStateNumber,edgeNumber, predicates) */<\n>
>>

// C y c l i c  S W I T C H

/* A repetition of the cyclic DFA states, but using switches instead
 * of if-then-else sequences.
 */

cyclicDFAStateSwitch(stateNumber,labels,edges,
                     needErrorClause,EOTTargetStateNumber) ::= <<
/* cyclicDFAStateSwitch(stateNumber,labels,edges,
 *                   needErrorClause,EOTTargetStateNumber)
 */
static ANTLR3_DFASTATE
dfa<decisionNumber>S<stateNumber>(p<name> ctx, pANTLR3_UINT32 alt)
{
    switch (LA(1))
    {
	<edges; separator="\n">
    
	default:
<if(needErrorClause)>
	    <if(backtracking)>
	    if (backtracking>0) 
	    {
		failedFlag()	= ANTLR3_TRUE;
		return (ANTLR3_DFASTATE)NULL;
		break;
	    }
	    <endif>
	    <newNVException(...)>
	    <@noViableAltException()>
	    return (ANTLR3_DFASTATE)NULL;<\n>
	    break;
<else>
	    return dfa<decisionNumber>S<EOTTargetStateNumber>;
	    break;<\n>
<endif>
    }
}<\n>
>>

cyclicDFAEdgeSwitch(labels, targetStateNumber, edgeNumber) ::= <<
/* cyclicDFAEdgeSwitch(labels, targetStateNumber, edgeNumber)
 */
<labels:{case <it>:}; separator="\n">
    return (ANTLR3_DFASTATE)dfa<decisionNumber>S<targetStateNumber>;<\n>
>>

// D F A  E X P R E S S I O N S

andPredicates(left,right) ::= "( <left> && <right> )"

orPredicates(left,right) ::= "( <left> || <right> )"

notPredicate(pred) ::= "!( <evalPredicate(...)> )"

evalPredicate(pred,description) ::= "<pred>"

evalSynPredicate(pred,description) ::= 
  "synpred(input, <pred>)"

lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber> == <atom>"

/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
 *  somewhere.  Must ask for the lookahead directly.
 */
isolatedLookaheadTest(atom,k,atomAsInt) ::= "LA(<k>) == <atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <<
(LA<decisionNumber>_<stateNumber> \>= <lower> && LA<decisionNumber>_<stateNumber> \<= <upper>)
>>

isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(LA(<k>) \>= <lower> && LA(<k>) \<= <upper>)"

setTest(ranges) ::= "<ranges; separator=\" || \">"

// A T T R I B U T E S

makeScopeSet() ::= <<
/* makeScopeSet() 
 */
 /** Definition of the <scope.name> scope variable tracking
 *  structure. An instance of this structure is created by calling
 *  <name>_<scope.name>Push().
 */
typedef struct  <scopeStruct(sname=scope.name)>_struct
{
    /** Function that the user may provide to be called when the
     *  scope is destroyed (so you can free pANTLR3_HASH_TABLES and so on)
     *
     * \param POinter to an instance of this typedef/struct
     */
    void    (*free)	(struct <scopeStruct(sname=scope.name)>_struct * frame);
    
    /* =============================================================================
     * Programmer defined variables...
     */
    <scope.attributes:{<it.decl>;}; separator="\n">

    /* End of programmer defined variables
     * =============================================================================
     */
} 
    * <scopeType(sname=scope.name)>;

>>

globalAttributeScopeDecl(scope) ::= <<
<if(scope.attributes)>
/* globalAttributeScopeDecl(scope)
 */
<makeScopeSet(...)>
<endif>
>>

ruleAttributeScopeDecl(scope) ::= <<
<if(scope.attributes)>
/* ruleAttributeScopeDecl(scope)
 */
<makeScopeSet(...)>
<endif>
>>

globalAttributeScopeFuncDecl(scope) ::= 
<<
/* globalAttributeScopeFuncDecl(scope)
 */
<if(scope.attributes)>
/* -----------------------------------------------------------------------------
 * Function declaration for creating a <name>_<scope.name> scope set 
 */
static <scopeType(sname=scope.name)>   <scopePushName(sname=scope.name)>(p<name> ctx);
/* ----------------------------------------------------------------------------- */

<endif>
>>

globalAttributeScopeFuncMacro(scope) ::= <<
<if(scope.attributes)>
/* globalAttributeScopeFuncMacro(scope)
 */
/** Macro for popping the top value from a <scopeStack(sname=scope.name)>
 */
#define <scopePopName(sname=scope.name)>()  ctx-><scopeStack(sname=scope.name)>->pop(ctx-><scopeStack(sname=scope.name)>)

<endif>
>>

ruleAttributeScopeFuncDecl(scope) ::= <<
<if(scope.attributes)>
/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a <name>_<scope.name> scope set 
 */
static <scopeType(sname=scope.name)>   <scopePushName(sname=scope.name)>(p<name> ctx);
/* ----------------------------------------------------------------------------- */

<endif>
>>

ruleAttributeScopeFuncMacro(scope) ::= <<
<if(scope.attributes)>
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Macro for popping the top value from a <scopeStack(sname=scope.name)>
 */
#define <scopePopName(sname=scope.name)>()  ctx-><scopeStack(sname=scope.name)>->pop(ctx-><scopeStack(sname=scope.name)>)

<endif>
>>
globalAttributeScopeDef(scope) ::= 
<<
/* globalAttributeScopeDef(scope)
 */
<if(scope.attributes)>
/** Pointer to the  <scope.name> stack for use by <scopePushName(sname=scope.name)>()
 *  and <scopePopName(sname=scope.name)>()
 */
pANTLR3_STACK <scopeStack(sname=scope.name)>;
/** Pointer to the top of the stack for the global scope <scopeStack(sname=scope.name)>
 */
<scopeType(sname=scope.name)>    <scopeTopDecl(sname=scope.name)>;
<scopeType(sname=scope.name)>    <scopePushName(sname=scope.name)>(struct <name>_Ctx_struct * ctx);
<endif>
>>

ruleAttributeScopeDef(scope) ::= <<
<if(scope.attributes)>
/* ruleAttributeScopeDef(scope)
 */
/** Pointer to the  <scope.name> stack for use by <scopePushName(sname=scope.name)>()
 *  and <scopePopName(sname=scope.name)>()
 */
pANTLR3_STACK <scopeStack(sname=scope.name)>;
<scopeType(sname=scope.name)>   (*<scopePushName(sname=scope.name)>)(struct <name>_Ctx_struct * ctx);
<scopeType(sname=scope.name)>   <scopeTopDecl(sname=scope.name)>;
<endif>
>>

globalAttributeScopeFuncs(scope) ::= <<
<if(scope.attributes)>
/* globalAttributeScopeFuncs(scope)
 */
<attributeFuncs(scope)>
<endif>
>>

ruleAttributeScopeFuncs(scope) ::= <<
<if(scope.attributes)>
/* ruleAttributeScopeFuncs(scope)
 */
<attributeFuncs(scope)>
<endif>
>>

globalAttributeScope(scope) ::= <<
<if(scope.attributes)>
/* globalAttributeScope(scope)  
 */
ctx-><scopePushName(sname=scope.name)>     = <scopePushName(sname=scope.name)>;
ctx-><scopeStack(sname=scope.name)>    = antlr3StackNew(ANTLR3_SIZE_HINT);
<scopeTop(sname=scope.name)>      = NULL;
<endif>
>>

ruleAttributeScope(scope) ::= 
<<
<if(scope.attributes)>
/* ruleAttributeScope(scope)
 */
ctx-><scopePushName(sname=scope.name)>     = <scopePushName(sname=scope.name)>;
ctx-><scopeStack(sname=scope.name)>    = antlr3StackNew(ANTLR3_SIZE_HINT);
<scopeTop(sname=scope.name)>      = NULL;
<endif>
>>

scopeTopDecl(sname) ::= <<
p<sname>Top
>>

scopeTop(sname) ::= <<
ctx-><scopeTopDecl(sname)>
>>

scopePop(sname) ::= <<
<scopePopName(sname=sname)>();
>>

scopePush(sname) ::= <<
p<sname>Push(ctx)
>>

scopePopName(sname) ::= <<
p<sname>Pop
>>

scopePushName(sname) ::= <<
p<sname>Push
>>

scopeType(sname) ::= <<
p<sname>_SCOPE
>>

scopeStruct(sname) ::= <<
p<sname>_SCOPE
>>

scopeStack(sname) ::= <<
p<sname>Stack
>>

attributeFuncs(scope) ::= <<
<if(scope.attributes)>
/* attributeFuncs(scope)
 */
 
/** \brief Allocate initial memory for a <name> <scope.name> scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   <scopeTop(sname=scope.name)>->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void myfunc( <scopeType(sname=scope.name)> ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE, not free()
 * then free the entry it is given with: 
 * \code
 *   ANTLR3_FREE(ptr);
 * \endcode
 * 
 */ 
static <scopeType(sname=scope.name)>
<scopePushName(sname=scope.name)>(p<name> ctx)
{
    /* Pointer used to create a new set of attributes
     */
    <scopeType(sname=scope.name)>      newAttributes;

    /* Allocate the memory for a new structure
     */
    newAttributes = (<scopeType(sname=scope.name)>) ANTLR3_MALLOC(sizeof(<scopeStruct(sname=scope.name)>));

    if  (newAttributes != NULL)
    {
	/* Standard ANTLR3 library implementation
	 */
	ctx-><scopeStack(sname=scope.name)>->push(ctx-><scopeStack(sname=scope.name)>, newAttributes, NULL);
	
	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
	 */
    }
 
    /* Calling routine will throw an exeception if this
     * fails and this pointer is NULL.
     */
    return  newAttributes;
}<\n>
<endif>
>>

returnType() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
<ruleDescriptor.name>_return
<else>
<if(ruleDescriptor.hasSingleReturnValue)>
<ruleDescriptor.singleValueReturnType>
<else>
void
<endif>
<endif>
>>

/** Generate the Java type associated with a single or multiple return
 *  values.
 */
ruleLabelType(referencedRule) ::= <<
<if(referencedRule.hasMultipleReturnValues)>
<referencedRule.name>_return
<else>
<if(referencedRule.hasSingleReturnValue)>
<referencedRule.singleValueReturnType>
<else>
void
<endif>
<endif>
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<cTypeInitMap.(typeName)>
>>

/** Define a rule label including default value */
ruleLabelDef(label) ::= <<
<ruleLabelType(referencedRule=label.referencedRule)> <label.label.text> = <initValue(typeName=ruleLabelType(referencedRule=label.referencedRule))>;<\n>
>>

/** Define a return struct for a rule if the code needs to access its
 *  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
 *  subgroups to stick in members.
 */
returnScope(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
typedef struct <returnType()>_struct
{
    /** Generic return elements for ANTLR3 rules
     */
<if(TREE_PARSER)>
    ANTLR3_TREE_RULE_RETURN_SCOPE   antlr3ReturnScope;
<endif>
<if(PARSER)>
    ANTLR3_RULE_RETURN_SCOPE        antlr3ReturnScope;
<endif>

    <scope.attributes:{<it.decl>;}; separator="\n">
    <@ruleReturnMembers()>   
}
    * <returnType()>;
<endif>
>>

parameterScope(scope) ::= <<
<scope.attributes:{<it.decl>}; separator=", ">
>>

/** Used in codegen.g to translate $x.y references.
 *  I could have left actions as StringTemplates to be inserted in
 *  the output (so they could use attributes inherited from surrounding
 *  templates), but really wanted to pass in AttributeScope and Attribute
 *  objects so this translation could query them.  So, translation of
 *  $x.y to executable code occurs before recognizerST.toString() occurs.
 *  I.e., actions are just text strings during final code generation.
globalAttributeRef(scope,attr) ::= <<
(ctx-><scopeTop(sname=scope)>)-><attr.name>
>>
 */

parameterAttributeRef(attr) ::= "<attr.name>"

scopeAttributeRef(scope,attr,index,negIndex) ::= <<
<if(negIndex)>
((<scope>_scope)<scope>_stack.elementAt(<scope>_stack.size()<negIndex>-1))-><attr.name>
<else>
<if(index)>
((<scopeType(sname=scope)>)ctx-><scopeStack(sname=scope)>->get(ctx-><scopeStack(sname=scope)>, (ANTLR3_UINT64)<index>))-><attr.name>
<else>
<scopeTop(sname=scope)>-><attr.name>
<endif>
<endif>
>>

/** $x is either global scope or x is rule with dynamic scope; refers
 *  to stack itself not top of stack.  This is useful for predicates
 *  like {$function.size()>0 && $function::name.equals("foo")}?
 */
isolatedDynamicScopeRef(scope) ::= "<scope>_stack"

/** reference an attribute of rule; might only have single return value */
ruleLabelRef(referencedRule,scope,attr) ::= <<
<if(referencedRule.hasMultipleReturnValues)>
<scope>.<attr.name>
<else>
<scope>
<endif>
>>

returnAttributeRef(ruleDescriptor,attr) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
retval-<attr.name> :___FIX this how to escape it
<else>
<attr.name>
<endif>
>>

/** How to translate $tokenLabel */
tokenLabelRef(label) ::= "<label>"

/** ids+=ID {$ids} or e+=expr {$e} */
listLabelRef(label) ::= "list_<label>"


// not sure the next are the right approach; and they are evaluated early;
// they cannot see TREE_PARSER or PARSER attributes for example. :(

tokenLabelPropertyRef_text(scope,attr) ::= "<scope>->getText(<scope>)->text"
tokenLabelPropertyRef_type(scope,attr) ::= "<scope>.getType()"
tokenLabelPropertyRef_line(scope,attr) ::= "<scope>.getLine()"
tokenLabelPropertyRef_pos(scope,attr) ::= "<scope>.getCharPositionInLine()"
tokenLabelPropertyRef_channel(scope,attr) ::= "<scope>.getChannel()"
tokenLabelPropertyRef_index(scope,attr) ::= "<scope>.getTokenIndex()"
tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"

ruleLabelPropertyRef_start(scope,attr) ::= "<scope>.start"
ruleLabelPropertyRef_stop(scope,attr) ::= "<scope>.stop"
ruleLabelPropertyRef_tree(scope,attr) ::= "<scope>.tree"
ruleLabelPropertyRef_text(scope,attr) ::= "input.toString(<scope>.start,<scope>.stop)"
ruleLabelPropertyRef_st(scope,attr) ::= "<scope>.st"

/** Isolated $RULE ref ok in lexer as it's a Token */
lexerRuleLabel(label) ::= "<label>"

lexerRuleLabelPropertyRef_type(scope,attr) ::= "<scope>->getType()"
lexerRuleLabelPropertyRef_line(scope,attr) ::= "<scope>->getLine()"
lexerRuleLabelPropertyRef_pos(scope,attr) ::= "<scope>->getCharPositionInLine()"
lexerRuleLabelPropertyRef_channel(scope,attr) ::= "<scope>->getChannel()"
lexerRuleLabelPropertyRef_index(scope,attr) ::= "<scope>->getTokenIndex()"
lexerRuleLabelPropertyRef_text(scope,attr) ::= "<scope>->getText()"

// Somebody may ref $template or $tree or $stop within a rule:
rulePropertyRef_start(scope,attr) ::= "retval->start"
rulePropertyRef_stop(scope,attr) ::= "retval->stop"
rulePropertyRef_tree(scope,attr) ::= "retval->tree"
rulePropertyRef_text(scope,attr) ::= "input->toString(retval.start,LT(-1))"
rulePropertyRef_st(scope,attr) ::= "retval->st"


/** How to execute an action */
execAction(action) ::= <<
/* execAction(action)
 */
<if(backtracking)>
if ( backtracking == 0 ) 
{
  <action>
}
<else>
<action>
<endif>
>>

/*
// L E X E R  A C T I O N S

emit(type) ::= "emit(<type>);"

setType(type) ::= "setType(<type>);"
*/

// M I S C (properties, etc...)

bitsetDeclare(name, words64) ::= <<

/**
 * Bitset defining follow set for error recovery in
 * rule state: <name>
 */
static  pANTLR3_BITSET <name>;
static  ANTLR3_UINT64 <name>_bits[] = { <words64:{<it>}; separator=", "> };
>>

bitset(name, words64) ::= <<
/* bitset(name, words64)
 */
<name> = antlr3BitsetLoad((sizeof(<name>_bits)/sizeof(ANTLR3_UINT64)), <name>_bits);<\n>
>>




codeFileExtension() ::= ".c"

true() ::= "ANTLR3_TRUE"
false() ::= "ANTLR3_FALSE"
