/** \file
 *
 * [The "BSD licence"]
 * Copyright (c) 2005 Terence Parr
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This code generating snarf blargle template thingy was cobbled together
 * by Jim "Any relation to Eric?" Idle. If it does cause the destruction of the
 * UniVerse, it will be pretty cool so long as I am in a different one at the
 * time. 
 */
group C;

cTypeInitMap ::= [
	"int"       : "0",              // Integers     start out being 0
	"long"      : "0",              // Longs        start out being 0
	"float"     : "0.0",            // Floats       start out being 0
	"double"    : "0.0",            // Doubles      start out being 0
	"boolean"   : "ANTLR3_FALSE",   // Booleans     start out being Antlr C for false
	"byte"      : "0",              // Bytes        start out being 0
	"short"     : "0",              // Shorts       start out being 0
	"char"      : "0",              // Chars        start out being 0
	default     : "NULL"            // Anything other than an atomic type (above) is a NULL (probably NULL pointer).
]

/** The overall file structure of a recognizer; stores methods for rules
 *  and cyclic DFAs plus support code.
 */
outputFile(
            LEXER,
            PARSER,
            TREE_PARSER, 
            headerAction, 
            docComment, 
            recognizer,
            name, 
            tokens, 
            tokenNames, 
            rules, 
            cyclicDFAs, 
            bitsets,
            buildTemplate, 
            profile,
            fileName, 
            ANTLRVersion, 
            generatedTimestamp
            ) ::=
<<
/** \file
 * 
 *         This file was generated by : $ANTLR version <ANTLRVersion>
 * From the lexer grammar source file : <fileName>
 *                                 On : <generatedTimestamp>
 *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim "Any relation to Eric?" Idle - "jimi" at idledotws
 *
 * Edit this file with tabs set to 8 (:set ts=8 in gvim) and indent at 4 (:set sw=4 in gvim)
 */

/* This is what the grammar programmer asked us to put at the top of every file.
 * It is known as the Header action...
 * =============================================================================
 */
<headerAction>

/* End of Header action.
 * =============================================================================
 */

<@includes>

<if(TREE_PARSER)>

/* If this is a tree parser then we need the generic include file for that.
 * Later on I will think through the inheritence thingy and come up with
 * a cunning plan that cannot fail! So, if you see this comment, you are using an
 * early access prototype, as unless I forget, this comment will be taken out once
 * I have swizzled tree node types and so on.
 */

/* Runtime definitions for the generic tree parser
 * =============================================================================
 */
#include \<antlr3/c/treeparser.h>

/* End of runtime definitions for the generic tree parser.
 * =============================================================================
 */
<endif>

/* Standard antlr3 C runtime definitions
 * =============================================================================
 */
#include    \<antlr3/c/antlr3.h>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */
<@end>

<docComment>

/* Start of recognizer
 * =============================================================================
 */
<recognizer>

/* End of recognizer
 * =============================================================================
 */
>>

// This is the template that generates a lexer.
//
lexer(  name,               // Name associated with this lexer
        tokens,             // The token set that this lexer is to work with
        globalAction,       // The global action for the lexer
        rules,              // The programmer defined rule set for the lexer
        cyclicDFAs          // The generated DFAs that drive the lexer
        ) ::= <<

/** \brief Token definitions for the lexer.
 *
 * These are the tokens that this lexer is able to spit out.
 * =============================================================================
 * \{
 */

<tokens:{ANTLR3_UNIT32 <it.name>=<it.type>;}; separator="\n">

/* End of token set that this lexer provides
 */
 
/**  \}  */
 
/** \defgroup globalActions
 *
 * The global action is defined in the lexer grammer and must be callable from
 * anywhere... more later on this...
 *
 * \{
 */

<globalAction>

/* End of global action
 * =============================================================================
 */
/**  \}  */


/** \brief This function should be called to create a new instance of <name>Lexer.
 *
 * \param[in] input pointer to an inpt strea structure
 * 
 * \return 
 *     - Upon success : Pointer to a lexing context for a <name>Lexer, which can be passed to a parser.
 *     - Upon failure : NULL
 */
ANTLR3_API pANTLR3_LEXER <name>_new(pANTLR3_CHARSTREAM    input) 
{
    /** Pointer to the lexer context for a <name> lexer.
     */
    pANTLR3_LEXER   lexerContext;
    
    /* First, we need to allocate a new structure for the lexer context, assuming
     * that there is enough memory to do so.
     */
    lexerContext    = (pANTLR3_LEXER)ANTRL3_CALLOC(1, sizeof(pANTLR3_LEXER));
    
    /* Did we have enough memory to create a new one?
     */
    if  (lexerContext == NULL)
    {
        return NULL;
    }
    
    /* Now, we might have to initialize the input stream. The input stream initializer
     * function is defined as returning ANTLR3_FALSE if it fails, or ANTLR3_TRUE if it
     * succeeds.
     */  
    if  (   input->initialized == ANTLR3_FALSE
         && input->initFunc    != NULL)
    {
        if  ( ( *(input->initFunc) )(input) != ANTLR3_TRUE)
        {
            /* Input stream errored out, so we need to free our lexer context.
             */
            ANTLR3_FREE(pANTLR3_LEXER);
            
            /* Indicate failure and certain death to the caller
             */
            return  NULL;
        }
    }
    
    /* We now have a new lexer context nicely allocated, and now we can
     * initialize it.
     */
    
    /* Store the input stream context pointer
     */
    lexerContext->inputStream   = input;
    
    /* Store the function that returns the next lexer token
     */
    lexerContext->nextToken     = <name>_nextToken;
    
    /* Store the function that tears down the lexer context itself
     */
    lexerContext->delete        = <name>_delete;
    
    /* There will be more to go here.
     */
    
    /* Return the lexer context. From here, it is up to the caller to 
     * destroy this structure by calling the delete function via the context
     * pointer: 
     * \code
     *              lexerContext->delete(lexerContext);
     * \endcode
     */
    return  lexerContext;
}

/** \brief Return the next token in the input stream of the <name> lexer.
 *
 * \return
 *      - Success: Pointer to a token structure
 *      - Fail: (as in no more tokens to be had) NULL
 */
ANTLR3_API ANTLR3_RESULT <name>_nextToken(pANTLR3_LEXER lexerContext) 
{
    pANTLR3_TOKEN   token;
    
    /* Assume a NULL token to start out with
     */
    lexerContext->token   = NULL;
    
    /* Enter the token recognizing loop until we receive either the end of
     * the token stream, or a valid token.
     */
    while   (lexerContext->token != EOF_TOKEN)
    {
        if ( lexerContext->input->LA(1) == ANTLR3_CHARSTREAM_EOF ) 
        {
            lexerContext->token     =   EOF_TOKEN;
        }
        else
        {
            /* Try to determine the next token and store it in lexerContext->token
             * if we have a recognition exception, then we will get that as a return
             * code and the lexerContext->re will be configured for the error reporting
             * function (which may be overridden by the programmer) and the recovery
             * function.
             */
            if  (<name>_mTokens(lexerContext) == ANTLR3_RECOGNITION_EXCEPTION)
            {
                /* Lexer threw a recognition exception, so we must report this using
                 * either our built in error reporter or the programmer supplied one.
                 */
                <name>Lexer_reportError(lexerContext);
                <name>Lexer_recover(lexerContext);
            }
            /* lexerContext->token is now set. */
        }
    }
    
    return ANTLR3_SUCCESS;
}

/* Programmer defined rules for this lexer
 * =============================================================================
 */
 
<rules; separator="\n\n">

/* End of programmer defined rules
 * =============================================================================
 */
 
/**
 * Cyclic DFA's to drive this lexer
 * =============================================================================
 * \{
 */
<cyclicDFAs:{dfa | protected DFA<dfa.decisionNumber> dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>();}>
<cyclicDFAs>

/* End of Cyclic DFAs
 * =============================================================================
 */
/** \} */

/* =============================================================================
 * End of lexer definition for <name>Lexer   
 * =============================================================================
 */
>>

/** 
 * How to generate a parser 
 */
genericParser(  name, 
                scopes, 
                tokens,
                tokenNames,
                globalAction, 
                rules,
                cyclicDFAs,
                bitsets,
                inputStreamType,
                superClass,
                ASTLabelType="Object", 
                labelType) ::= <<
                
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_WCHAR   <name>TokenNames[]
     = {
        "\<invalid>",       /* String to print to indicate an invalid token */
        "\<EOR>",
        "\<DOWN>", 
        "\<UP>", 
        <tokenNames; separator=",\n">
       };

/** \brief Symbolic definitions of all the tokens that the parser will work with.
 *
 * =============================================================================
 * \{
 */    
<tokens:{#define <it.name>      <it.type>}; separator="\n">
   
/* End of token definitions for <name>Parser
 * =============================================================================
 */
/** \} */

<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
    
<@members>

/** \brief Create a new instance of a <name>Parser and return a context handle for it.
 *
 * \param[in] input The supplier of the intput stream for the parser, which in this
 *                  case is a <inputStreamType>
 * \return
 *     - Failure : NULL - Unable to create a new parser
 *     - Success : pANTLR3_PARSER - Pointer to a new context handle for a <name>Parser
 */
ANTLR3_API pANTLR3_PARSER <name>Parser_new(<inputStreamType> input) 
{
    pANTLR3_PARSER  <name>Parserctx;

    /* Allocate the memory for the parser context 
     */
    <name>ParserCtx = (pANTLR3_PARSER)ANTLR3_MALLOC(sizeof(ANTLR3_PARSER));
    
    if  (<name>ParserCtx != NULL)
    {
        /* Initialize the input stream 
         */
        input->initialize(<name>ParserCtx);

        /* Store the input stream context
         */
        <name>ParserCtx->input  = input;
    }

    /* More to do here probably */

    return  ctx<name>Parser;
}<\n>
    
<@end>

typedef struct RuleReturnStruct
{
    <labelType> start;
    <labelType> stop;
    <@ruleReturnMembers()>
}
    * pRULE_RETURN;

ANTLR3_API ANTLR3_WCHAR getTokenNames() 
{ 
    return <name>tokenNames; 
}

<globalAction>

<rules; separator="\n/* ============================================ */\n">

<! define a singleton instance for each cyclic DFA then define DFAs !>

/* =============================================================================
 */
/** \brief Cyclic DFAs for this parser:
 * 
 * \{
 */
<cyclicDFAs:{dfa | static pDFA<dfa.decisionNumber> dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>();}>
<cyclicDFAs>
/** \} */

/* =============================================================================
 */
/** \brief Bitsets in use by this parser
 * \{
 */
<bitsets:bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
                    words64=it.bits)>
/** \}
>>

parser(name, scopes, tokens, tokenNames, globalAction, rules, cyclicDFAs, bitsets, ASTLabelType, superClass="Parser", labelType="Token") ::= <<
<genericParser(inputStreamType="TokenStream", ...)>
>>

/** How to generate a tree parser; same as parser except the input
 *  stream is a different type.
 */
treeParser(name, scopes, tokens, tokenNames, globalAction, rules, cyclicDFAs, bitsets, labelType={<ASTLabelType>}, ASTLabelType="Object", superClass="TreeParser") ::= <<
<genericParser(inputStreamType="TreeNodeStream", ...)>
>>

/** How to generate code for a rule.  This includes any return type
 *  data aggregates required for multiple return values.
 */
rule(ruleName,ruleDescriptor,initAction,block,emptyRule,description) ::= <<
<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>
<returnScope(scope=ruleDescriptor.returnScope)>

/* Comes from:
 * $ANTLR start <ruleName>
 * <fileName>:<description>
 */
ANTLR3_API <returnType()> <name>_<ruleName>(pANTLR3_PARSER parserCtx, <ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{   
    <ruleDeclarations()>
    <ruleLabelDefs()>
    <initAction>
    <@preamble()>
<if(emptyRule)>
    <block>
    <ruleCleanUp()>
<else>
    <block>
    <ruleCleanUp()>
   
/* As much as goto is not the greatest codign technique when coding by hand,
 * here we are generating code that is somewhat readable but not meant to be maintained
 * The goto targets are simple and shuold be easy enough to follow with the eye.
 */ 
reportError:
    /* Report the error with either the default error reporter or
     * the user supplied error reporter.
     */
    <name>_reportError(parserCte);

    /* Recover the parse state so we can attempt to proceed after this error
     */
    <name>_recover(parserCtx);

    goto ruleEnd;
<endif>
    <@postamble()>
    <ruleReturnValue()>
}
// $ANTLR end <ruleName>
>>

ruleDeclarations() ::= <<

/* Declarations */
<if(ruleDescriptor.hasMultipleReturnValues)>
<returnType()> retval;
<endif>
<if(ruleDescriptor.singleValueReturnType)>
<returnType()> <ruleDescriptor.singleValueReturnName>;
<endif>

/* Initializations */
<if(ruleDescriptor.hasMultipleReturnValues)>
retval       = <returnType()>_new(parserCtx);
retval.start = (<labelType>)parserCtx->input.LT(1);<\n>
<endif>
<ruleDescriptor.useScopes:{<it>Stack_push(parserCtx);}; separator="\n">
<ruleDescriptor.ruleScope:{<it.name>Stack_push(parserCtx);}; separator="\n">
>>

ruleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels]
    :{<labelType> <it.label.text>=null;}; separator="\n"
>
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels]
    :{List list_<it.label.text>=null;}; separator="\n"
>
<[ruleDescriptor.ruleLabels,ruleDescriptor.ruleListLabels]
    :ruleLabelDef(label=it); separator="\n"
>
<[ruleDescriptor.allRuleRefsInAltsWithRewrites,ruleDescriptor.allTokenRefsInAltsWithRewrites]
    :{List list_<it>=new ArrayList();}; separator="\n"
>
>>

ruleReturnValue() ::= <<
<if(ruleDescriptor.hasReturnValue)>
    if  (parserCtx->recognitionException == ANTLR3_TRUE)
    {
        /* Not in error so we can return the rule value or structure
         * that the programmer defined.
         */
<if(ruleDescriptor.singleValueReturnType)>
        return <ruleDescriptor.singleValueReturnName>;<\n>
<else>
        return retval;<\n>
<endif>
    }
    else
    {
        return  NULL;
    }
<endif>
>>

ruleCleanUp() ::= <<
<ruleDescriptor.useScopes:{<it>_stack.pop();}; separator="\n">
<ruleDescriptor.ruleScope:{<it.name>_stack.pop();}; separator="\n">
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.stop = (<labelType>)input.LT(-1);
<endif>
>>

/** How to generate a rule in the lexer; naked blocks are used for
 *  fragment rules.
 */
lexerRule(ruleName, nakedBlock, ruleDescriptor, initAction, block) ::= <<
ANTLR3_LEX_RESULT m<ruleName>(pANTLR3_LEXER lexerContext<if(ruleDescriptor)>, <ruleDescriptor.parameterScope:parameterScope(scope=it)><endif>)
{
<if(nakedBlock)>
    <initAction>
    <block><\n>
<else>
    ANTLR3_UINT32   type;
    ANTLR3_UINT32   start;
    ANTLR3_UINT32   line;
    ANTLR3_UINT32   charPosition;
    ANTLR3_UINT32   channel;

    <initAction>

    type            = <ruleName>;
    start           = lexerContext->getCharIndex();
    line            = lexerContext->getLine();
    charPosition    = lexerContext->getCharPositionInLine();
    channel         = ANTLR3_DEFAULT_CHANNEL;

    <block>

    if ( lexerContext->token == NULL ) 
    {
        antrl3_emit(type, line, charPosition, channel, start, lexerContext->getCharIndex()-1);
    }<\n>
<endif>
}
>>

/** How to generate code for the implicitly-defined lexer grammar rule
 *  that chooses between lexer rules.
 */
tokensRule(ruleName,nakedBlock,args,block) ::= <<
ANTLR3_LEX_RESULT <name>mTokens(pANTLR3_LEXER lexerContext)
{
    <block><\n>
}
>>

// S U B R U L E S

/** A (...) subrule with multiple alternatives */
block(  alts,
        decls,
        decision,
        enclosingBlockLevel,
        blockLevel,
        decisionNumber,
        maxK,
        maxAlt,
        description) ::= <<
/* From: <fileName>:<description>
 */
ANTLR3_UINT32 alt<decisionNumber>=<maxAlt>;
<decls>
<@predecision()>
<decision>
<@postdecision()>
<@prebranch()>
switch (alt<decisionNumber>) {
    <alts:altSwitchCase()>
}
<@postbranch()>
>>

/** A rule block with multiple alternatives */
ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
/* From: <fileName>:<description>
 */
int alt<decisionNumber>;
<decls>
alt<decisionNumber> = <maxAlt>;
<@predecision()>
<decision>
<@postdecision()>
switch (alt<decisionNumber>) {
    <alts:altSwitchCase()>
}
>>

ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
/* From: <fileName>:<description>
 */
<decls>
<@prealt()>
<alts>
<@postalt()>
>>

/** A special case of a (...) subrule with a single alternative */
blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
/* From: <fileName>:<description>
 */
<decls>
<@prealt()>
<alts>
<@postalt()>
>>

/** A (..)+ block with 0 or more alternatives */
positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
/* From: <fileName>:<description>
 */
int cnt<decisionNumber>=0;
<decls>
<@preloop()>
loop<decisionNumber>:
do {
    int alt<decisionNumber>=<maxAlt>;
    <@predecision()>
    <decision>
    <@postdecision()>
    switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
	default :
	    if ( cnt<decisionNumber> >= 1 ) break loop<decisionNumber>;
            EarlyExitException eee =
                new EarlyExitException(<decisionNumber>, input);
            <@earlyExitException()>
            throw eee;
    }
    cnt<decisionNumber>++;
} while (true);
<@postloop()>
>>

positiveClosureBlockSingleAlt ::= positiveClosureBlock

/** A (..)* block with 0 or more alternatives */
closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
/* From: <fileName>:<description>
 */
<decls>
<@preloop()>
loop<decisionNumber>:
do {
    int alt<decisionNumber>=<maxAlt>;
    <@predecision()>
    <decision>
    <@postdecision()>
    switch (alt<decisionNumber>) {
	<alts:altSwitchCase()>
	default :
	    break loop<decisionNumber>;
    }
} while (true);
<@postloop()>
>>

closureBlockSingleAlt ::= closureBlock

/** Optional blocks (x)? are translated to (x|) by before code generation
 *  so we can just use the normal block template
 */
optionalBlock ::= block

optionalBlockSingleAlt ::= block

/** A case in a switch that jumps to an alternative given the alternative
 *  number.  A DFA predicts the alternative and then a simple switch
 *  does the jump to the code that actually matches that alternative.
 */
altSwitchCase() ::= <<
case <i> :
    <@prealt()>
    <it>
    break;<\n>
>>

/** An alternative is just a list of elements; at outermost level */
alt(elements,altNum,description,autoAST,outerAlt) ::= <<
/* From: <fileName>:<description>
 */
{
<@declarations()>
<elements:element()>
<@cleanup()>
}
>>

// E L E M E N T S

/** Dump the elements one per line */
element() ::= <<
<@prematch()>
<it.el><\n>
>>

/** match a token optionally with a label in front */
tokenRef(token,label,elementIndex) ::= <<
<if(label)>
<label>=input.LT(1);<\n>
<endif>
match(input,<token>,FOLLOW_<token>_in_<ruleName><elementIndex>);
>>

/** ids+=ID */
tokenRefAndListLabel(token,label,elementIndex) ::= <<
<tokenRef(...)>
<listLabel(...)>
>>

listLabel(label) ::= <<
if (list_<label>==null) list_<label>=new ArrayList();
list_<label>.add(<label>);<\n>
>>

/** match a character */
charRef(char,label) ::= <<
<if(label)>
int <label> = input.LA(1);<\n>
<endif>
    lexerContext->match(<char>);    /* Single character */
>>

/** match a character range */
charRangeRef(a,b) ::= "matchRange(<a>,<b>);"

/** For now, sets are interval tests and must be tested inline */
matchSet(s,label,elementIndex,postmatchCode="") ::= <<
<if(label)>
<label>=input.LT(1);<\n>
<endif>
if ( <s> ) {
    <postmatchCode>
    input.consume();
}
else {
    MismatchedSetException mse =
        new MismatchedSetException(null,input);
    <@mismatchedSetException()>
<if(LEXER)>
    recover(mse);
<else>
    recoverFromMismatchedSet(input,mse,FOLLOW_set_in_<ruleName><elementIndex>);
<endif>
    throw mse;
}<\n>
>>

matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
<matchSet(...)>
<listLabel(...)>
>>

/** Match a string literal */
lexerStringRef(string,label) ::= <<
<if(label)>
int <label>Start = getCharIndex();
match(<string>);
pANTLR3_TOKEN <label> = w CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, <label>Start, getCharIndex()-1);
<else>
match(<string>);<\n>
<endif>
>>

wildcard(label,elementIndex) ::= <<
<if(label)>
<label>=input.LT(1);<\n>
<endif>
matchAny(input);
>>

wildcardAndListLabel(label,elementIndex) ::= <<
<wildcard(...)>
<listLabel(...)>
>>

/** Match . wildcard in lexer */
wildcardChar(label, elementIndex) ::= <<
<if(label)>
int <label> = input.LA(1);<\n>
<endif>
matchAny();
>>

wildcardCharListLabel(label, elementIndex) ::= <<
<wildcardChar(...)>
<listLabel(...)>
>>

/** Match a rule reference by invoking it possibly with arguments
 *  and a return value or values.
 */
ruleRef(rule,label,elementIndex,args) ::= <<
following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<if(label)>
<label>=<rule>(<args>);<\n>
<else>
<rule>(<args>);<\n>
<endif>
following.pop();
>>


/** 
 * A lexer rule reference 
 */
lexerRuleRef(rule,label,args) ::= <<
<if(label)>
int <label>Start = getCharIndex();
m<rule>(<args>);
Token <label> = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, <label>Start, getCharIndex()-1);
<else>
m<rule>(<args>);
<endif>
>>

/** match ^(root children) in tree parser */
tree(root, children) ::= <<
<root:element()>
match(input, Token.DOWN, null);
<children:element()>
match(input, Token.UP, null);
>>

/** Every predicate is used as a validating predicate (even when it is
 *  also hoisted into a prediction expression).
 */
validateSemanticPredicate(pred) ::= <<
if ( !(<evalPredicate(...)>) ) {
    throw new FailedPredicateException(input, "<ruleName>", "<pred>");
}
>>

// F i x e d  D F A  (if-then-else)

dfaState(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
int LA<decisionNumber>_<stateNumber> = input.LA(<k>);
<edges; separator="\nelse ">
else {
<if(eotPredictsAlt)>
    alt<decisionNumber>=<eotPredictsAlt>;
<else>
    NoViableAltException nvae =
        new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
    <@noViableAltException()>
    throw nvae;<\n>
<endif>
}
>>

/** Same as a normal DFA state except that we don't examine lookahead
 *  for the bypass alternative.  It delays error detection but this
 *  is faster, smaller, and more what people expect.  For (X)? people
 *  expect "if ( LA(1)==X ) match(X);" and that's it.
 */
dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
int LA<decisionNumber>_<stateNumber> = input.LA(<k>);
<edges; separator="\nelse ">
>>

/** A DFA state that is actually the loopback decision of a closure
 *  loop.  If end-of-token (EOT) predicts any of the targets then it
 *  should act like a default clause (i.e., no error can be generated).
 *  This is used only in the lexer so that for ('a')* on the end of a rule
 *  anything other than 'a' predicts exiting.
 */
dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
int LA<decisionNumber>_<stateNumber> = input.LA(<k>);
<edges; separator="\nelse "><\n>
<if(eotPredictsAlt)>
else {
    alt<decisionNumber>=<eotPredictsAlt>;
}<\n>
<endif>
>>

/** An accept state indicates a unique alternative has been predicted */
dfaAcceptState(alt) ::= "alt<decisionNumber>=<alt>;"

/** A simple edge with an expression.  If the expression is satisfied,
 *  enter to the target state.
 */
dfaEdge(labelExpr, targetState) ::= <<
if ( <labelExpr> ) {
    <targetState>
}
>>

// F i x e d  D F A  (switch case)

/** A DFA state where a SWITCH may be generated.  The code generator
 *  decides if this is possible: CodeGenerator.canGenerateSwitch().
 */
dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
switch ( input.LA(<k>) ) {
<edges; separator="\n">
default:
<if(eotPredictsAlt)>
    alt<decisionNumber>=<eotPredictsAlt>;
<else>
    NoViableAltException nvae =
        new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
    <@noViableAltException()>
    throw nvae;<\n>
<endif>
}<\n>
>>

dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber) ::= <<
switch ( input.LA(<k>) ) {
    <edges; separator="\n">
}<\n>
>>

dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber) ::= <<
switch ( input.LA(<k>) ) {
<edges; separator="\n"><\n>
<if(eotPredictsAlt)>
default:
    alt<decisionNumber>=<eotPredictsAlt>;
    break;<\n>
<endif>
}<\n>
>>

dfaEdgeSwitch(labels, targetState) ::= <<
<labels:{case <it>:}; separator="\n">
    <targetState>
    break;
>>

// C y c l i c  D F A

/** The code to initiate execution of a cyclic DFA; this is used
 *  in the rule to predict an alt just like the fixed DFA case.
 *  The <name> attribute is inherited via the parser, lexer, ...
 */
dfaDecision(decisionNumber,description) ::= <<
alt<decisionNumber> = dfa<decisionNumber>.predict(input);
>>

/** The overall cyclic DFA chunk; contains all the DFA states */
cyclicDFA(className,decisionNumber,states,description) ::= <<
class DFA<decisionNumber> extends DFA {
    public int predict(IntStream input) throws RecognitionException {
        return predict(input, s0);
    }
    <states>
}
>>

/** A state in a cyclic DFA */
cyclicDFAState(stateNumber,edges,needErrorClause) ::= <<
DFA.State s<stateNumber> = new DFA.State() {
    public DFA.State transition(IntStream input) throws RecognitionException {
        int LA<decisionNumber>_<stateNumber> = input.LA(1);
        <edges>
        <if(needErrorClause)>
        NoViableAltException nvae =
	    new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
        <@noViableAltException()>
        throw nvae;
        <endif>
    }
};<\n>
>>

/** An accept state for a cyclic DFA */
cyclicDFAAcceptState(stateNumber,predictAlt) ::= <<
DFA.State s<stateNumber> = new DFA.State() {{alt=<predictAlt>;}};<\n>
>>

/** Just like a fixed DFA edge, test the lookahead and indicate what
 *  state to jump to next if successful.
 */
cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber) ::= <<
if ( <labelExpr> ) {return s<targetStateNumber>;}<\n>
>>

/** An edge pointing at end-of-token; essentially matches any char;
 *  always jump to the target.
 */
eotDFAEdge(targetStateNumber,edgeNumber) ::= <<
return s<targetStateNumber>;<\n>
>>

// C y c l i c  S W I T C H

/* A repetition of the cyclic DFA states, but using switches instead
 * of if-then-else sequences.
 */

cyclicDFAStateSwitch(stateNumber,labels,edges,
                     needErrorClause,EOTTargetStateNumber) ::= <<
DFA.State s<stateNumber> = new DFA.State() {
    public DFA.State transition(IntStream input) throws RecognitionException {
        switch ( input.LA(1) ) {
        <edges; separator="\n">
        default:
<if(needErrorClause)>
            NoViableAltException nvae =
                new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
            throw nvae;
<else>
            return s<EOTTargetStateNumber>;<\n>	
<endif>
        }
    }
};<\n>
>>

cyclicDFAEdgeSwitch(labels, targetStateNumber, edgeNumber) ::= <<
<labels:{case <it>:}; separator="\n">
    return s<targetStateNumber>;<\n>
>>

// D F A  E X P R E S S I O N S

andPredicates(left,right) ::= " (<left> && <right>) "

orPredicates(left,right) ::= " (<left> || <right>) "

notPredicate(pred) ::= " !(<evalPredicate(...)>) "

evalPredicate(pred) ::= " <pred> "

lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber> == <atom>"

/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
 *  somewhere.  Must ask for the lookahead directly.
 */
isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <<
( (LA<decisionNumber>_<stateNumber>\> = <lower>) && LA<decisionNumber>_<stateNumber> \<= <upper> )
>>

isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= " ((input.LA(<k>)\> = <lower>) && input.LA(<k>) \<= <upper>) "

setTest(ranges) ::= "<ranges; separator=\" || \">"

// A T T R I B U T E S
//
makeScopeSet() ::= <<
/** Definition of the global attribute scop variable tracking
 *  structure. An instance of this structure is created by calling
 *  <scope.name>Stack_new().
 */
typedef struct  <scope.name>_SCOPE_STRUCT
{
    /** ANTLR3 C runtime scope controlling structure included
     *  in all scope stacked structures.
     */
    ANTLR3_SCOPE    scopeTracker;

    /* Programmer defined variables...
     * =============================================================================
     */
    <scope.attributes:{<it.decl>;}; separator="\n">

    /* End of programmer defined variables
     * =============================================================================
     */
} 
    * pANTLR3_<scope.name>_SCOPE;

/** \brief Tracking pointer for the <scope.name> stack.
 */
static  pANTLR3_<scope.name>_SCOPE  <scope.name>Stack;

/** \brief Allocate initial memory for a <scope.name> scope variable stack entry and
 *         add it to the top of the stack.
 */ 
pANTLR3_<scope.name>_SCOPE <scope.name>Stack_push()
{
    /* Pointer used to create a new set of attributes
     */
    pANTLR3_<scope.name>_SCOPE      newAttributes;

    /* Allocate the memory for a new structure
     */
    
    /* Call the ANTLR3 C runtime code to initialize the new
     * scope stack.
     */
    return  (pANTLR3_<scope.name>_SCOPE) antrl3Stack_add();
 pANTLR3_<scope.name>_SCOPE <scope.name>_stack = antrl3Stack_new();<\n>
}
>>

globalAttributeScope(scope) ::= <<
<if(scope.attributes)>
<makeScopeSet(...)>
<endif>
>>

ruleAttributeScope(scope) ::= <<
<if(scope.attributes)>
<makeScopeSet(...)>
<endif>
>>

returnType() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
<ruleDescriptor.name>_return
<else>
<if(ruleDescriptor.singleValueReturnType)>
<ruleDescriptor.singleValueReturnType>
<else>
void
<endif>
<endif>
>>

/** Generate the Java type associated with a single or multiple return
 *  values.
 */
ruleLabelType(referencedRule) ::= <<
<if(referencedRule.hasMultipleReturnValues)>
<referencedRule.name>_return
<else>
<if(referencedRule.singleValueReturnType)>
<referencedRule.singleValueReturnType>
<else>
void
<endif>
<endif>
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<javaTypeInitMap.(typeName)>
>>

/** Define a rule label including default value */
ruleLabelDef(label) ::= <<
<ruleLabelType(referencedRule=label.referencedRule)> <label.label.text> = <initValue(typeName=ruleLabelType(referencedRule=label.referencedRule))>;<\n>
>>

/** Define a return struct for a rule if the code needs to access its
 *  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
 *  subgroups to stick in members.
 */
returnScope(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
public static class <returnType()> extends RuleReturn {
    <scope.attributes:{<it.decl>;}; separator="\n">
};
<endif>
>>

parameterScope(scope) ::= <<
<scope.attributes:{<it.decl>}; separator=", ">
>>

/** Used in codegen.g to translate $x.y references.
 *  I could have left actions as StringTemplates to be inserted in
 *  the output (so they could use attributes inherited from surrounding
 *  templates), but really wanted to pass in AttributeScope and Attribute
 *  objects so this translation could query them.  So, translation of
 *  $x.y to executable code occurs before recognizerST.toString() occurs.
 *  I.e., actions are just text strings during final code generation.
 */
globalAttributeRef(scope,attr) ::= <<
((<scope>)<scope>_stack.peek()).<attr.name>
>>

parameterAttributeRef(attr) ::= "<attr.name>"

ruleScopeAttributeRef(scope,attr) ::=
    "((<scope>_scope)<scope>_stack.peek()).<attr.name>"

/** reference an attribute of rule; might only have single return value */
ruleLabelRef(referencedRule,scope,attr) ::= <<
<if(referencedRule.singleValueReturnType)>
<scope>
<else>
<scope>.<attr.name>
<endif>
>>

returnAttributeRef(ruleDescriptor,attr) ::= <<
<if(ruleDescriptor.singleValueReturnType)>
<attr.name>
<else>
retval.<attr.name>
<endif>
>>

/** How to translate $tokenLabel */
tokenLabelRef(label) ::= "<label>"

/** ids+=ID {$ids} or e+=expr {$e} */
listLabelRef(label) ::= "list_<label>"


// not sure the next are the right approach; and they are evaluated early;
// they cannot see TREE_PARSER or PARSER attributes for example. :(

tokenLabelPropertyRef_text(scope,attr) ::= "<scope>.getText()"
tokenLabelPropertyRef_type(scope,attr) ::= "<scope>.getType()"
tokenLabelPropertyRef_line(scope,attr) ::= "<scope>.getLine()"
tokenLabelPropertyRef_pos(scope,attr) ::= "<scope>.getCharPositionInLine()"
tokenLabelPropertyRef_channel(scope,attr) ::= "<scope>.getChannel()"
tokenLabelPropertyRef_index(scope,attr) ::= "<scope>.getTokenIndex()"
tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"

ruleLabelPropertyRef_start(scope,attr) ::= "<scope>.start"
ruleLabelPropertyRef_stop(scope,attr) ::= "<scope>.stop"
ruleLabelPropertyRef_tree(scope,attr) ::= "<scope>.tree"
ruleLabelPropertyRef_text(scope,attr) ::= "input.toString(<scope>.start,<scope>.stop)"

// A C T I O N S

emit(type) ::= "emit(<type>);"

setType(type) ::= "setType(<type>);"

// M I S C (properties, etc...)

bitset(name, words64) ::= <<
static  ANTLR3_BITSET <name>_bitset = {<words64:{<it>L};separator=",">};<\n>
>>

codeFileExtension() ::= ".c"
