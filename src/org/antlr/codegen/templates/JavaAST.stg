group JavaAST;

// MODIFIED ELEMENTS

alt_declarations() ::= <<
<if(outerAlt)>
root_0 = (<ASTLabelType>)adaptor.nil();<\n>
<else>
<ASTLabelType> root_<blockLevel> = (<ASTLabelType>)adaptor.nil();<\n>
<endif>
>>

alt_cleanup() ::= <<
<if(!outerAlt)>
adaptor.addChild(root_<enclosingBlockLevel>, root_<blockLevel>);<\n>
<endif>
>>

// TOKEN AST STUFF

/** ID! and output=AST (same as plain tokenRef) */
tokenRefASTBang(token,label,elementIndex) ::= "<super.tokenRef(...)>"

/** ID and output=AST */
tokenRefAST(token,label,elementIndex) ::= <<
<super.tokenRef(...)>
<label>_tree = adaptor.create(<label>);
adaptor.addChild(root_<blockLevel>, <label>_tree);
>>

/** ID^ and output=AST */
tokenRefASTRoot(token,label,elementIndex) ::= <<
<super.tokenRef(...)>
<label>_tree = adaptor.create(<label>);
root_<blockLevel> = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_<blockLevel>);
>>

/** ID^^ and output=AST */
tokenRefASTRuleRoot(token,label,elementIndex) ::= <<
<super.tokenRef(...)>
<label>_tree = adaptor.create(<label>);
root_0 = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_0);
>>

/** ids+=ID! is same as tokenRefAndListLabel */
tokenRefASTBangAndListLabel(token,label,elementIndex) ::= "<super.tokenRefAndListLabel(...)>"

/** label+=TOKEN when output=AST but not rewrite alt */
tokenRefASTAndListLabel(token,label,elementIndex) ::= <<
<tokenRefAST(...)>
<listLabel(...)>
>>

/** Match label+=TOKEN^ when output=AST but not rewrite alt */
tokenRefASTRootAndListLabel(token,label,elementIndex) ::= <<
<tokenRefASTRoot(...)>
<listLabel(...)>
>>

/** Match label+=TOKEN^^ when output=AST but not rewrite alt */
tokenRefASTRuleRootAndListLabel(token,label,elementIndex) ::= <<
<tokenRefASTRuleRoot(...)>
<listLabel(...)>
>>

/** ID but track it for use in a rewrite rule */
tokenRefASTTrack(token,label,elementIndex) ::= <<
<super.tokenRef(...)>
list_<token>.add(<label>);<\n>
>>

/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
 *  to the tracking list list_ID for use in the rewrite.
 */
tokenRefASTTrackAndListLabel(token,label,elementIndex) ::= <<
<tokenRefASTTrack(...)>
<listLabel(...)>
>>

// SET AST

matchSetAST(s,label,elementIndex) ::= <<
<label>=input.LT(1);
if ( <s> ) {
    adaptor.addChild(root_<blockLevel>, adaptor.create(<label>));
    input.consume();
}
else {
    MismatchedSetException mse =
        new MismatchedSetException(null,input);
<if(debug)>
    dbg.recognitionException(mse);<\n>
<endif>
    recoverFromMismatchedSet(input,mse,FOLLOW_set_in_<ruleName><elementIndex>);
    throw mse;
}<\n>
>>

matchSetASTRoot(s,label,elementIndex) ::= <<
<label>=input.LT(1);
if ( <s> ) {
    root_<blockLevel> = (<ASTLabelType>)adaptor.becomeRoot(adaptor.create(<label>), root_<blockLevel>);
    input.consume();
}
else {
    MismatchedSetException mse =
        new MismatchedSetException(null,input);
<if(debug)>
    dbg.recognitionException(mse);<\n>
<endif>
    recoverFromMismatchedSet(input,mse,FOLLOW_set_in_<ruleName><elementIndex>);
    throw mse;
}<\n>
>>

matchSetASTRuleRoot(s,label,elementIndex) ::= <<
<label>=input.LT(1);<\n>
if ( <s> ) {
    root_0 = (<ASTLabelType>)adaptor.becomeRoot(adaptor.create(<label>), root_0);
    input.consume();
}
else {
    MismatchedSetException mse =
        new MismatchedSetException(null,input);
<if(debug)>
    dbg.recognitionException(mse);<\n>
<endif>
    recoverFromMismatchedSet(input,mse,FOLLOW_set_in_<ruleName><elementIndex>);
    throw mse;
}<\n>
>>

// RULE REF AST

ruleRefASTBang(rule,label,elementIndex,args) ::= "<super.ruleRef(...)>"

ruleRefASTTrack(rule,label,elementIndex,args) ::= <<
following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<label>=<rule>(<args>);
list_<rule>.add(<label>.tree);
following.pop();
>>

ruleRefASTTrackAndListLabel(rule,label,elementIndex,args) ::= <<
following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<label>=<rule>(<args>);
list_<rule>.add(<label>.tree);<\n>
if (list_<label>==null) list_<label>=new ArrayList();
list_<label>.add(<label>.tree);
following.pop();
>>

/** x+=rule when output=AST */
ruleRefASTAndListLabel(rule,label,elementIndex,args) ::= <<
following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<label>=<rule>(<args>);
adaptor.addChild(root_<blockLevel>, <label>.tree);<\n>
if (list_<label>==null) list_<label>=new ArrayList();
list_<label>.add(<label>.tree);
following.pop();
>>

/** x+=rule! is same as ruleRefAndListLabel */
ruleRefASTBangAndListLabel ::= ruleRefASTAndListLabel

/** rule when buildAST */
ruleRefAST(rule,label,elementIndex,args) ::= <<
following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<label>=<rule>(<args>);
adaptor.addChild(root_<blockLevel>, <label>.tree);
following.pop();
>>

/** rule^ */
ruleRefASTRoot(rule,label,elementIndex,args) ::= <<
following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<label>=<rule>(<args>);
root_<blockLevel> = (<ASTLabelType>)adaptor.becomeRoot(<label>.tree, root_<blockLevel>);
following.pop();
>>

/** x+=rule^^ */
ruleRefASTRootAndListLabel(rule,label,elementIndex,args) ::= <<
following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<label>=<rule>(<args>);
root_<blockLevel> = (<ASTLabelType>)adaptor.becomeRoot(<label>.tree, root_<blockLevel>);<\n>
if (list_<label>==null) list_<label>=new ArrayList();
list_<label>.add(<label>.tree);
following.pop();
>>

/** rule^^ */
ruleRefASTRuleRoot(rule,label,elementIndex,args) ::= <<
following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<label>=<rule>(<args>);
root_0 = (<ASTLabelType>)adaptor.becomeRoot(<label>.tree, root_0);
following.pop();
>>

/** x+=rule^^ */
ruleRefASTRuleRootAndListLabel(rule,label,elementIndex,args) ::= <<
following.push(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<label>=<rule>(<args>);
root_0 = (<ASTLabelType>)adaptor.becomeRoot(<label>.tree, root_0);<\n>
if (list_<label>==null) list_<label>=new ArrayList();
list_<label>.add(<label>.tree);<\n>
following.pop();
>>

// WILDCARD AST

wildcardAST(label,elementIndex) ::= <<
<label>=input.LT(1);
matchAny(input);
<label>_tree = adaptor.create(<label>);
adaptor.addChild(root_<blockLevel>, <label>_tree);
>>

wildcardASTRoot(label,elementIndex) ::= <<
<label>=input.LT(1);
matchAny(input);
<label>_tree = adaptor.create(<label>);
root_<blockLevel> = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_<blockLevel>);
>>

wildcardASTRuleRoot(label,elementIndex) ::= <<
<label>=input.LT(1);
matchAny(input);
<label>_tree = adaptor.create(<label>);
root_0 = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_0);
>>
