/** \file
 *  This C source file was generated by $ANTLR version 3.0b4
 *
 *     -  From the grammar source file : c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g
 *     -                            On : 2006-08-18 16:05:54
 *     -                 for the lexer : cmqlLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim "Any relation to Eric?" Idle - "jimi" at idledotws
 *
 * View this file with tabs set to 8 (:set ts=8 in gvim) and indent at 4 (:set sw=4 in gvim)
 *
*/
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    <cmqlLexer.h>

/* ----------------------------------------- */


/** String literals used by cmqlLexer that we must do things like matchs() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x41, 0x4e, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x41, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x41, 0x53, 0x53, 0x4f, 0x43,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x61, 0x73, 0x73, 0x6f, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x57, 0x49, 0x54, 0x48,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x41, 0x54, 0x54, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x61, 0x74, 0x74, 0x72, 0x38,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x61, 0x74, 0x74, 0x72, 0x6e, 0x6f,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x41, 0x56, 0x45, 0x52, 0x41, 0x47, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x62, 0x69, 0x74, 0x6d, 0x61, 0x70,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x62, 0x69, 0x74, 0x73, 0x6c, 0x69, 0x63, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x42, 0x45, 0x54, 0x57, 0x45, 0x45, 0x4e,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x62, 0x6f, 0x64, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x42, 0x52, 0x45, 0x41, 0x4b, 0x2e, 0x4f, 0x4e,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x42, 0x52, 0x45, 0x41, 0x4b, 0x2e, 0x53, 0x55, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x42, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x42, 0x59, 0x2e, 0x44, 0x53, 0x4e, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x42, 0x59, 0x2e, 0x45, 0x58, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x42, 0x59, 0x2e, 0x45, 0x58, 0x50, 0x2e, 0x44, 0x53, 0x4e, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x42, 0x59, 0x2e, 0x45, 0x58, 0x50, 0x2e, 0x53, 0x55, 0x42,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x42, 0x59, 0x2e, 0x45, 0x58, 0x50, 0x2e, 0x53, 0x55, 0x42, 0x2e, 0x44, 0x53, 0x4e, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x43, 0x4f, 0x4c, 0x2e, 0x48, 0x44, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x43, 0x41, 0x4c, 0x43,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x43, 0x4f, 0x4c, 0x2e, 0x48, 0x44, 0x52, 0x2e, 0x53, 0x55, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x43, 0x4f, 0x4c, 0x2e, 0x53, 0x50, 0x41, 0x43, 0x45, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x43, 0x4f, 0x4c, 0x2e, 0x53, 0x55, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x63, 0x6f, 0x6c, 0x6e, 0x6f,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x63, 0x6f, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x43, 0x4f, 0x4e, 0x56,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x63, 0x6f, 0x6e, 0x76,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x43, 0x4f, 0x55, 0x4e, 0x54, 0x2e, 0x53, 0x55, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x44, 0x41, 0x54, 0x41, 0x53, 0x54, 0x52, 0x45, 0x41, 0x4d,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x44, 0x42, 0x4c, 0x2e, 0x53, 0x50, 0x41, 0x43, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x44, 0x45, 0x54, 0x2e, 0x53, 0x55, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x64, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x72, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x4c, 0x49, 0x4b, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x45, 0x41, 0x43, 0x48,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x45, 0x56, 0x45, 0x52, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x45, 0x4e, 0x55, 0x4d,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x45, 0x51,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x45, 0x56, 0x41, 0x4c,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x66, 0x61, 0x6c, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x66, 0x69, 0x6c, 0x65, 0x74, 0x79, 0x70, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x46, 0x4d, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x46, 0x4f, 0x4f, 0x54, 0x49, 0x4e, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x46, 0x52, 0x4f, 0x4d,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x47, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x47, 0x52, 0x41, 0x4e, 0x44, 0x2e, 0x54, 0x4f, 0x54, 0x41, 0x4c,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x47, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x41, 0x46, 0x54, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_57[]  = { 0x48, 0x44, 0x52, 0x2e, 0x53, 0x55, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_58[]  = { 0x68, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_59[]  = { 0x48, 0x45, 0x41, 0x44, 0x49, 0x4e, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_60[]  = { 0x49, 0x44, 0x2e, 0x53, 0x55, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_61[]  = { 0x49, 0x44, 0x4c, 0x49, 0x53, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_62[]  = { 0x49, 0x4e, 0x51, 0x55, 0x49, 0x52, 0x49, 0x4e, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_63[]  = { 0x69, 0x6e, 0x64, 0x65, 0x78,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_64[]  = { 0x69, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_65[]  = { 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_66[]  = { 0x49, 0x53, 0x2e, 0x4e, 0x55, 0x4c, 0x4c,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_67[]  = { 0x49, 0x53, 0x2e, 0x4e, 0x4f, 0x54, 0x2e, 0x4e, 0x55, 0x4c, 0x4c,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_68[]  = { 0x6f, 0x72, 0x64, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_69[]  = { 0x69, 0x74, 0x79, 0x70, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_70[]  = { 0x49, 0x54, 0x45, 0x4d, 0x53, 0x54, 0x52, 0x45, 0x41, 0x4d,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_71[]  = { 0x6a, 0x75, 0x73, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_72[]  = { 0x4c, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_73[]  = { 0x4d, 0x41, 0x54, 0x43, 0x48, 0x45, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_74[]  = { 0x4d, 0x41, 0x54, 0x43, 0x48, 0x49, 0x4e, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_75[]  = { 0x4c, 0x50, 0x54, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_76[]  = { 0x4c, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_77[]  = { 0x42, 0x45, 0x46, 0x4f, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_78[]  = { 0x4d, 0x41, 0x52, 0x47, 0x49, 0x4e,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_79[]  = { 0x4d, 0x41, 0x58,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_80[]  = { 0x4d, 0x49, 0x4e,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_81[]  = { 0x4d, 0x55, 0x4c, 0x54, 0x49, 0x2e, 0x56, 0x41, 0x4c, 0x55, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_82[]  = { 0x6d, 0x76,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_83[]  = { 0x6e, 0x61, 0x6d, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_84[]  = { 0x4e, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_85[]  = { 0x4e, 0x4f,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_86[]  = { 0x4e, 0x4f, 0x44, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_87[]  = { 0x4e, 0x4f, 0x2e, 0x49, 0x4e, 0x44, 0x45, 0x58,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_88[]  = { 0x4e, 0x4f, 0x2e, 0x4e, 0x55, 0x4c, 0x4c, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_89[]  = { 0x4e, 0x4f, 0x50, 0x41, 0x47, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_90[]  = { 0x4e, 0x4f, 0x53, 0x50, 0x4c, 0x49, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_91[]  = { 0x4e, 0x4f, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_92[]  = { 0x4f, 0x4e, 0x4c, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_93[]  = { 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_94[]  = { 0x4f, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_95[]  = { 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_96[]  = { 0x50, 0x45, 0x52, 0x43, 0x45, 0x4e, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_97[]  = { 0x70, 0x72, 0x69, 0x6e, 0x74, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_98[]  = { 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x6f, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_99[]  = { 0x71, 0x75, 0x65, 0x72, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_100[]  = { 0x72, 0x65, 0x66, 0x6e, 0x6f,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_101[]  = { 0x72, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_102[]  = { 0x52, 0x45, 0x47, 0x55, 0x4c, 0x41, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_103[]  = { 0x52, 0x45, 0x51, 0x55, 0x49, 0x52, 0x45, 0x2e, 0x49, 0x4e, 0x44, 0x45, 0x58,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_104[]  = { 0x52, 0x45, 0x51, 0x55, 0x49, 0x52, 0x45, 0x2e, 0x53, 0x45, 0x4c, 0x45, 0x43, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_105[]  = { 0x53, 0x41, 0x49, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_106[]  = { 0x53, 0x50, 0x4f, 0x4b, 0x45, 0x4e,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_107[]  = { 0x53, 0x41, 0x4d, 0x50, 0x4c, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_108[]  = { 0x53, 0x41, 0x4d, 0x50, 0x4c, 0x45, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_109[]  = { 0x53, 0x41, 0x56, 0x49, 0x4e, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_110[]  = { 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6c, 0x69, 0x73, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_111[]  = { 0x53, 0x49, 0x4e, 0x47, 0x4c, 0x45, 0x2e, 0x56, 0x41, 0x4c, 0x55, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_112[]  = { 0x73, 0x6f, 0x72, 0x74, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_113[]  = { 0x53, 0x54, 0x41, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_114[]  = { 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_115[]  = { 0x53, 0x55, 0x4d,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_116[]  = { 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x4c,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_117[]  = { 0x54, 0x4f,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_118[]  = { 0x54, 0x4f, 0x54, 0x41, 0x4c,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_119[]  = { 0x54, 0x52, 0x41, 0x4e, 0x53, 0x50, 0x4f, 0x52, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_120[]  = { 0x74, 0x72, 0x75, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_121[]  = { 0x74, 0x79, 0x70, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_122[]  = { 0x55, 0x4e, 0x49, 0x51, 0x55, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_123[]  = { 0x55, 0x4e, 0x4c, 0x49, 0x4b, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_124[]  = { 0x4e, 0x4f, 0x54, 0x2e, 0x4d, 0x41, 0x54, 0x43, 0x48, 0x49, 0x4e, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_125[]  = { 0x55, 0x51, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_126[]  = { 0x56, 0x45, 0x52, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_127[]  = { 0x57, 0x48, 0x45, 0x4e,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_128[]  = { 0x77, 0x69, 0x64, 0x74, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_129[]  = { 0x57, 0x48, 0x45, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_130[]  = { 0x57, 0x49, 0x54, 0x48, 0x49, 0x4e,  ANTLR3_STRING_TERMINATOR};

/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

/* Forward declare the locally static matching functions we have generated.
 */
static void	mWS    (pcmqlLexer ctx);
static void	mSTRING    (pcmqlLexer ctx);
static void	mIDSTRING    (pcmqlLexer ctx);
static void	mESCAPE_SEQUENCE    (pcmqlLexer ctx);
static void	mQUOTE    (pcmqlLexer ctx);
static void	mLBRACE    (pcmqlLexer ctx);
static void	mRBRACE    (pcmqlLexer ctx);
static void	mSEMI    (pcmqlLexer ctx);
static void	mLPAREN    (pcmqlLexer ctx);
static void	mRPAREN    (pcmqlLexer ctx);
static void	mCOMMA    (pcmqlLexer ctx);
static void	mATTRIBUTEVALUE    (pcmqlLexer ctx);
static void	mNUMBER    (pcmqlLexer ctx);
static void	mDIGIT    (pcmqlLexer ctx);
static void	mAT    (pcmqlLexer ctx);
static void	mAND    (pcmqlLexer ctx);
static void	mAS    (pcmqlLexer ctx);
static void	mASSOC    (pcmqlLexer ctx);
static void	mASSOC_WITH    (pcmqlLexer ctx);
static void	mATTR    (pcmqlLexer ctx);
static void	mATTR8    (pcmqlLexer ctx);
static void	mATTRNO    (pcmqlLexer ctx);
static void	mAVERAGE    (pcmqlLexer ctx);
static void	mBITMAP    (pcmqlLexer ctx);
static void	mBITSLICE    (pcmqlLexer ctx);
static void	mBETWEEN    (pcmqlLexer ctx);
static void	mBODY    (pcmqlLexer ctx);
static void	mBREAK_ON    (pcmqlLexer ctx);
static void	mBREAK_SUP    (pcmqlLexer ctx);
static void	mBY    (pcmqlLexer ctx);
static void	mBY_DSND    (pcmqlLexer ctx);
static void	mBY_EXP    (pcmqlLexer ctx);
static void	mBY_EXP_DSND    (pcmqlLexer ctx);
static void	mBY_EXP_SUB    (pcmqlLexer ctx);
static void	mBY_EXP_SUB_DSND    (pcmqlLexer ctx);
static void	mCOL_HDG    (pcmqlLexer ctx);
static void	mCALC    (pcmqlLexer ctx);
static void	mCOL_HDR_SUPP    (pcmqlLexer ctx);
static void	mCOL_SPACES    (pcmqlLexer ctx);
static void	mCOL_SUPP    (pcmqlLexer ctx);
static void	mCOLNO    (pcmqlLexer ctx);
static void	mCOLLATED    (pcmqlLexer ctx);
static void	mCOMMAND    (pcmqlLexer ctx);
static void	mCONV    (pcmqlLexer ctx);
static void	mCOUNT_SUPP    (pcmqlLexer ctx);
static void	mDATASTREAM    (pcmqlLexer ctx);
static void	mDBL_SPACE    (pcmqlLexer ctx);
static void	mDET_SUPP    (pcmqlLexer ctx);
static void	mDICTIONARY    (pcmqlLexer ctx);
static void	mDISPLAY_LIKE    (pcmqlLexer ctx);
static void	mEACH    (pcmqlLexer ctx);
static void	mELEMENT    (pcmqlLexer ctx);
static void	mENUM    (pcmqlLexer ctx);
static void	mEQ    (pcmqlLexer ctx);
static void	mEVAL    (pcmqlLexer ctx);
static void	mBFALSE    (pcmqlLexer ctx);
static void	mFILENAME    (pcmqlLexer ctx);
static void	mFILETYPE    (pcmqlLexer ctx);
static void	mFMT    (pcmqlLexer ctx);
static void	mFOOTING    (pcmqlLexer ctx);
static void	mFORMAT    (pcmqlLexer ctx);
static void	mFROM    (pcmqlLexer ctx);
static void	mGE    (pcmqlLexer ctx);
static void	mGLOBAL    (pcmqlLexer ctx);
static void	mGRAND_TOTAL    (pcmqlLexer ctx);
static void	mGT    (pcmqlLexer ctx);
static void	mHDR_SUPP    (pcmqlLexer ctx);
static void	mHEADING    (pcmqlLexer ctx);
static void	mID_SUPP    (pcmqlLexer ctx);
static void	mIDLIST    (pcmqlLexer ctx);
static void	mINQUIRING    (pcmqlLexer ctx);
static void	mINDEX    (pcmqlLexer ctx);
static void	mINDEXES    (pcmqlLexer ctx);
static void	mINTERNAL    (pcmqlLexer ctx);
static void	mISNULL    (pcmqlLexer ctx);
static void	mISNOTNULL    (pcmqlLexer ctx);
static void	mORDER    (pcmqlLexer ctx);
static void	mITYPE    (pcmqlLexer ctx);
static void	mITEMSTREAM    (pcmqlLexer ctx);
static void	mJUSTIFICATION    (pcmqlLexer ctx);
static void	mLE    (pcmqlLexer ctx);
static void	mLIKE    (pcmqlLexer ctx);
static void	mOPT_LPTR    (pcmqlLexer ctx);
static void	mOP_LT    (pcmqlLexer ctx);
static void	mMARGIN    (pcmqlLexer ctx);
static void	mMAX    (pcmqlLexer ctx);
static void	mMIN    (pcmqlLexer ctx);
static void	mMULTI_VALUE    (pcmqlLexer ctx);
static void	mMV    (pcmqlLexer ctx);
static void	mNAME    (pcmqlLexer ctx);
static void	mNE    (pcmqlLexer ctx);
static void	mNO    (pcmqlLexer ctx);
static void	mNODE    (pcmqlLexer ctx);
static void	mNO_INDEX    (pcmqlLexer ctx);
static void	mNO_NULLS    (pcmqlLexer ctx);
static void	mNOPAGE    (pcmqlLexer ctx);
static void	mNOSPLIT    (pcmqlLexer ctx);
static void	mNOT    (pcmqlLexer ctx);
static void	mONLY    (pcmqlLexer ctx);
static void	mOPTIONS    (pcmqlLexer ctx);
static void	mOR    (pcmqlLexer ctx);
static void	mLIST_SPEC    (pcmqlLexer ctx);
static void	mPERCENT    (pcmqlLexer ctx);
static void	mPRINTER    (pcmqlLexer ctx);
static void	mPROCESSOR    (pcmqlLexer ctx);
static void	mQUERY    (pcmqlLexer ctx);
static void	mREFNO    (pcmqlLexer ctx);
static void	mREGULAR    (pcmqlLexer ctx);
static void	mREQUIRE_INDEX    (pcmqlLexer ctx);
static void	mREQUIRE_SELECT    (pcmqlLexer ctx);
static void	mSAID    (pcmqlLexer ctx);
static void	mSAMPLE    (pcmqlLexer ctx);
static void	mSAMPLED    (pcmqlLexer ctx);
static void	mSAVING    (pcmqlLexer ctx);
static void	mSELECTLIST    (pcmqlLexer ctx);
static void	mSINGLE_VALUE    (pcmqlLexer ctx);
static void	mSORTED    (pcmqlLexer ctx);
static void	mSTAT    (pcmqlLexer ctx);
static void	mSTORAGE    (pcmqlLexer ctx);
static void	mSUM    (pcmqlLexer ctx);
static void	mTERMINAL    (pcmqlLexer ctx);
static void	mTO    (pcmqlLexer ctx);
static void	mTOTAL    (pcmqlLexer ctx);
static void	mTRANSPORT    (pcmqlLexer ctx);
static void	mBTRUE    (pcmqlLexer ctx);
static void	mTYPE    (pcmqlLexer ctx);
static void	mUNIQUE    (pcmqlLexer ctx);
static void	mUNLIKE    (pcmqlLexer ctx);
static void	mUQS    (pcmqlLexer ctx);
static void	mVERT    (pcmqlLexer ctx);
static void	mWHEN    (pcmqlLexer ctx);
static void	mWIDTH    (pcmqlLexer ctx);
static void	mWITH    (pcmqlLexer ctx);
static void	mWITHIN    (pcmqlLexer ctx);
static void	mTokens    (pcmqlLexer ctx);
static void	cmqlLexerFree(pcmqlLexer ctx);



static void
cmqlLexerFree  (pcmqlLexer ctx)
{
    lexr->free(lexr->me);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the gramar file that generated this code
 */
static unsigned char fileName[] = "c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static unsigned char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called cmqlLexer
 *
 * \param[in] instream Pointer to an initialized input stream
 *
 * \return 
 *     - Success pcmqlLexer initialized for the lex start
 *     - Fail (pcmqlLexer)(ANTLR3_ERR_NOMEM)
 */
ANTLR3_API pcmqlLexer cmqlLexerNew         (pANTLR3_INPUT_STREAM     instream)
{
    pcmqlLexer lexCtx; /* Context structure we will build and return   */

    lexCtx = (pcmqlLexer) ANTLR3_MALLOC(sizeof(cmqlLexer));

    if  (lexCtx == NULL)
    {
        /* Failed to allocate memory for lexer context */
        return  (pcmqlLexer)ANTLR3_ERR_NOMEM;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We intialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in cmqlLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    lexCtx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream);

    /* Check that we allocated the memory correctly
     */
    if	(lexCtx->pLexer == (pANTLR3_LEXER)ANTLR3_ERR_NOMEM)
    {
	ANTLR3_FREE(lexCtx);
	return  (pcmqlLexer)ANTLR3_ERR_NOMEM;
    }
    /* Install the implementation of our cmqlLexer interface
     */
    lexCtx->mWS	= mWS;
    lexCtx->mSTRING	= mSTRING;
    lexCtx->mIDSTRING	= mIDSTRING;
    lexCtx->mESCAPE_SEQUENCE	= mESCAPE_SEQUENCE;
    lexCtx->mQUOTE	= mQUOTE;
    lexCtx->mLBRACE	= mLBRACE;
    lexCtx->mRBRACE	= mRBRACE;
    lexCtx->mSEMI	= mSEMI;
    lexCtx->mLPAREN	= mLPAREN;
    lexCtx->mRPAREN	= mRPAREN;
    lexCtx->mCOMMA	= mCOMMA;
    lexCtx->mATTRIBUTEVALUE	= mATTRIBUTEVALUE;
    lexCtx->mNUMBER	= mNUMBER;
    lexCtx->mDIGIT	= mDIGIT;
    lexCtx->mAT	= mAT;
    lexCtx->mAND	= mAND;
    lexCtx->mAS	= mAS;
    lexCtx->mASSOC	= mASSOC;
    lexCtx->mASSOC_WITH	= mASSOC_WITH;
    lexCtx->mATTR	= mATTR;
    lexCtx->mATTR8	= mATTR8;
    lexCtx->mATTRNO	= mATTRNO;
    lexCtx->mAVERAGE	= mAVERAGE;
    lexCtx->mBITMAP	= mBITMAP;
    lexCtx->mBITSLICE	= mBITSLICE;
    lexCtx->mBETWEEN	= mBETWEEN;
    lexCtx->mBODY	= mBODY;
    lexCtx->mBREAK_ON	= mBREAK_ON;
    lexCtx->mBREAK_SUP	= mBREAK_SUP;
    lexCtx->mBY	= mBY;
    lexCtx->mBY_DSND	= mBY_DSND;
    lexCtx->mBY_EXP	= mBY_EXP;
    lexCtx->mBY_EXP_DSND	= mBY_EXP_DSND;
    lexCtx->mBY_EXP_SUB	= mBY_EXP_SUB;
    lexCtx->mBY_EXP_SUB_DSND	= mBY_EXP_SUB_DSND;
    lexCtx->mCOL_HDG	= mCOL_HDG;
    lexCtx->mCALC	= mCALC;
    lexCtx->mCOL_HDR_SUPP	= mCOL_HDR_SUPP;
    lexCtx->mCOL_SPACES	= mCOL_SPACES;
    lexCtx->mCOL_SUPP	= mCOL_SUPP;
    lexCtx->mCOLNO	= mCOLNO;
    lexCtx->mCOLLATED	= mCOLLATED;
    lexCtx->mCOMMAND	= mCOMMAND;
    lexCtx->mCONV	= mCONV;
    lexCtx->mCOUNT_SUPP	= mCOUNT_SUPP;
    lexCtx->mDATASTREAM	= mDATASTREAM;
    lexCtx->mDBL_SPACE	= mDBL_SPACE;
    lexCtx->mDET_SUPP	= mDET_SUPP;
    lexCtx->mDICTIONARY	= mDICTIONARY;
    lexCtx->mDISPLAY_LIKE	= mDISPLAY_LIKE;
    lexCtx->mEACH	= mEACH;
    lexCtx->mELEMENT	= mELEMENT;
    lexCtx->mENUM	= mENUM;
    lexCtx->mEQ	= mEQ;
    lexCtx->mEVAL	= mEVAL;
    lexCtx->mBFALSE	= mBFALSE;
    lexCtx->mFILENAME	= mFILENAME;
    lexCtx->mFILETYPE	= mFILETYPE;
    lexCtx->mFMT	= mFMT;
    lexCtx->mFOOTING	= mFOOTING;
    lexCtx->mFORMAT	= mFORMAT;
    lexCtx->mFROM	= mFROM;
    lexCtx->mGE	= mGE;
    lexCtx->mGLOBAL	= mGLOBAL;
    lexCtx->mGRAND_TOTAL	= mGRAND_TOTAL;
    lexCtx->mGT	= mGT;
    lexCtx->mHDR_SUPP	= mHDR_SUPP;
    lexCtx->mHEADING	= mHEADING;
    lexCtx->mID_SUPP	= mID_SUPP;
    lexCtx->mIDLIST	= mIDLIST;
    lexCtx->mINQUIRING	= mINQUIRING;
    lexCtx->mINDEX	= mINDEX;
    lexCtx->mINDEXES	= mINDEXES;
    lexCtx->mINTERNAL	= mINTERNAL;
    lexCtx->mISNULL	= mISNULL;
    lexCtx->mISNOTNULL	= mISNOTNULL;
    lexCtx->mORDER	= mORDER;
    lexCtx->mITYPE	= mITYPE;
    lexCtx->mITEMSTREAM	= mITEMSTREAM;
    lexCtx->mJUSTIFICATION	= mJUSTIFICATION;
    lexCtx->mLE	= mLE;
    lexCtx->mLIKE	= mLIKE;
    lexCtx->mOPT_LPTR	= mOPT_LPTR;
    lexCtx->mOP_LT	= mOP_LT;
    lexCtx->mMARGIN	= mMARGIN;
    lexCtx->mMAX	= mMAX;
    lexCtx->mMIN	= mMIN;
    lexCtx->mMULTI_VALUE	= mMULTI_VALUE;
    lexCtx->mMV	= mMV;
    lexCtx->mNAME	= mNAME;
    lexCtx->mNE	= mNE;
    lexCtx->mNO	= mNO;
    lexCtx->mNODE	= mNODE;
    lexCtx->mNO_INDEX	= mNO_INDEX;
    lexCtx->mNO_NULLS	= mNO_NULLS;
    lexCtx->mNOPAGE	= mNOPAGE;
    lexCtx->mNOSPLIT	= mNOSPLIT;
    lexCtx->mNOT	= mNOT;
    lexCtx->mONLY	= mONLY;
    lexCtx->mOPTIONS	= mOPTIONS;
    lexCtx->mOR	= mOR;
    lexCtx->mLIST_SPEC	= mLIST_SPEC;
    lexCtx->mPERCENT	= mPERCENT;
    lexCtx->mPRINTER	= mPRINTER;
    lexCtx->mPROCESSOR	= mPROCESSOR;
    lexCtx->mQUERY	= mQUERY;
    lexCtx->mREFNO	= mREFNO;
    lexCtx->mREGULAR	= mREGULAR;
    lexCtx->mREQUIRE_INDEX	= mREQUIRE_INDEX;
    lexCtx->mREQUIRE_SELECT	= mREQUIRE_SELECT;
    lexCtx->mSAID	= mSAID;
    lexCtx->mSAMPLE	= mSAMPLE;
    lexCtx->mSAMPLED	= mSAMPLED;
    lexCtx->mSAVING	= mSAVING;
    lexCtx->mSELECTLIST	= mSELECTLIST;
    lexCtx->mSINGLE_VALUE	= mSINGLE_VALUE;
    lexCtx->mSORTED	= mSORTED;
    lexCtx->mSTAT	= mSTAT;
    lexCtx->mSTORAGE	= mSTORAGE;
    lexCtx->mSUM	= mSUM;
    lexCtx->mTERMINAL	= mTERMINAL;
    lexCtx->mTO	= mTO;
    lexCtx->mTOTAL	= mTOTAL;
    lexCtx->mTRANSPORT	= mTRANSPORT;
    lexCtx->mBTRUE	= mBTRUE;
    lexCtx->mTYPE	= mTYPE;
    lexCtx->mUNIQUE	= mUNIQUE;
    lexCtx->mUNLIKE	= mUNLIKE;
    lexCtx->mUQS	= mUQS;
    lexCtx->mVERT	= mVERT;
    lexCtx->mWHEN	= mWHEN;
    lexCtx->mWIDTH	= mWIDTH;
    lexCtx->mWITH	= mWITH;
    lexCtx->mWITHIN	= mWITHIN;
    lexCtx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    lexCtx->pLexer->ctx	    = lexCtx;
    
    /** Install the token matching function
     */
    lexCtx->pLexer->mTokens = mTokens;
    
    lexCtx->getGrammarFileName	= getGrammarFileName;
    lexCtx->free		= cmqlLexerFree;
    
    /* Return the newly built lexer to the caller
     */
    return  lexCtx;
}

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the chracters the constitute the token WS
 * from the attached input stream.
 *
 * Comes from: 719:8: ( ( ' ' | '\\t' | '\\f' | ('\\r'|'\\n'))+ )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mWS(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = WS;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:719:8: ( ( ' ' | '\\t' | '\\f' | ('\\r'|'\\n'))+ )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:719:8: ( ' ' | '\\t' | '\\f' | ('\\r'|'\\n'))+
     */
    {
        /* element()
         */
        /* positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) 
         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:719:8: ( ' ' | '\\t' | '\\f' | ('\\r'|'\\n'))+
         */
        {
            int cnt1=0;
        
            for (;;)
            {
                int alt1=5;
        	/* dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState)
        	 */
        	switch ( LA(1) ) 
        	{
        	/* dfaEdgeSwitch(labels, targetState)
        	 */
        	case ' ':
        	    alt1=1; /* dfaAcceptState(alt) */
        	    break;
        	/* dfaEdgeSwitch(labels, targetState)
        	 */
        	case '\t':
        	    alt1=2; /* dfaAcceptState(alt) */
        	    break;
        	/* dfaEdgeSwitch(labels, targetState)
        	 */
        	case '\f':
        	    alt1=3; /* dfaAcceptState(alt) */
        	    break;
        	/* dfaEdgeSwitch(labels, targetState)
        	 */
        	case '\n':
        	case '\r':
        	    alt1=4; /* dfaAcceptState(alt) */
        	    break;
        	
        	}
        
        	switch (alt1) 
        	{
        	    /* altSwitchCase()
        	     */
        	    case 1:
        	        /* alt(elements,altNum,description,autoAST,outerAlt)
        	         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:719:10: ' '
        	         */
        	        {
        	            /* element()
        	             */
        	            /* charRef(char,label)
        	             */
        	            matchc(' '); 
        	        
        	        }
        	        break;
        	    /* altSwitchCase()
        	     */
        	    case 2:
        	        /* alt(elements,altNum,description,autoAST,outerAlt)
        	         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:720:5: '\\t'
        	         */
        	        {
        	            /* element()
        	             */
        	            /* charRef(char,label)
        	             */
        	            matchc('\t'); 
        	        
        	        }
        	        break;
        	    /* altSwitchCase()
        	     */
        	    case 3:
        	        /* alt(elements,altNum,description,autoAST,outerAlt)
        	         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:721:5: '\\f'
        	         */
        	        {
        	            /* element()
        	             */
        	            /* charRef(char,label)
        	             */
        	            matchc('\f'); 
        	        
        	        }
        	        break;
        	    /* altSwitchCase()
        	     */
        	    case 4:
        	        /* alt(elements,altNum,description,autoAST,outerAlt)
        	         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:723:5: ('\\r'|'\\n')
        	         */
        	        {
        	            /* element()
        	             */
        	            /* matchSet(s,label,elementIndex,postmatchCode="")
        	             */
        	            if ( LA(1) == '\n' || LA(1) == '\r' ) 
        	            {
        	                inputConsume();
        	            
        	            }
        	            else 
        	            {
        	                /* mismatchedSetEx()
        	                 */
        	                exConstruct();
        	                theException()->type = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                theException()->name = ANTLR3_MISMATCHED_SET_NAME;
        	                lrecover();    goto ruleWSEx;
        	            }

        	        
        	        }
        	        break;
        
        	    default:
        	    
        		if ( cnt1 >= 1 )
        		{
        		    goto loop1; /* Ah well, generated code or I'd shoot myself */
        		}
        		/* mismatchedSetEx()
        		 */
        		exConstruct();
        		theException()->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		theException()->name = ANTLR3_MISMATCHED_SET_NAME;

        
        		goto ruleWSEx;
        	}
        	cnt1++;
            }
            loop1: ;	/* Jump to here if this rule does not match */
        }
        /* element()
         */
        /* execAction(action)
         */
         channel=99; /* Throw away whitespace */ 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;


}
// $ANTLR end WS

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING
 *
 * Looks to match the chracters the constitute the token STRING
 * from the attached input stream.
 *
 * Comes from: 732:7: ( '\"' (~ ('\\\"'|'\\\\') | ESCAPE_SEQUENCE )* '\\\"' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSTRING(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = STRING;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:732:7: ( '\"' (~ ('\\\"'|'\\\\') | ESCAPE_SEQUENCE )* '\\\"' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:732:7: '\"' (~ ('\\\"'|'\\\\') | ESCAPE_SEQUENCE )* '\\\"'
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc('"'); 
        /* element()
         */
        
        /* closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) 
         *
         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:732:11: (~ ('\\\"'|'\\\\') | ESCAPE_SEQUENCE )*
         */
        
        for (;;)
        {
            int alt2=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA2_0 = LA(1);
                /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( ((LA2_0 >= 0x0000 && LA2_0 <= '!') || (LA2_0 >= '#' && LA2_0 <= '[') || (LA2_0 >= ']' && LA2_0 <= 0xFFFE)) ) 
                {
                    alt2=1; /* dfaAcceptState(alt) */
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA2_0 == '\\') ) 
                {
                    alt2=2; /* dfaAcceptState(alt) */
                }
            
            }
            switch (alt2) 
            {
        	/* altSwitchCase()
        	 */
        	case 1:
        	    /* alt(elements,altNum,description,autoAST,outerAlt)
        	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:732:13: ~ ('\\\"'|'\\\\')
        	     */
        	    {
        	        /* element()
        	         */
        	        /* matchSet(s,label,elementIndex,postmatchCode="")
        	         */
        	        if ( (LA(1) >= 0x0000 && LA(1) <= '!') || (LA(1) >= '#' && LA(1) <= '[') || (LA(1) >= ']' && LA(1) <= 0xFFFE) ) 
        	        {
        	            inputConsume();
        	        
        	        }
        	        else 
        	        {
        	            /* mismatchedSetEx()
        	             */
        	            exConstruct();
        	            theException()->type = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            theException()->name = ANTLR3_MISMATCHED_SET_NAME;
        	            lrecover();    goto ruleSTRINGEx;
        	        }

        	    
        	    }
        	    break;
        	/* altSwitchCase()
        	 */
        	case 2:
        	    /* alt(elements,altNum,description,autoAST,outerAlt)
        	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:732:30: ESCAPE_SEQUENCE
        	     */
        	    {
        	        /* element()
        	         */
        	        /* lexerRuleRef(rule,label,args)
        	         * From: 732:30: ESCAPE_SEQUENCE
        	         */
        	        mESCAPE_SEQUENCE(ctx ); 
        	    
        	    }
        	    break;
        
        	default:
        	    goto loop2;	/* break out of the loop */
        	    break;
            }
        }
        loop2: ; /* Jump out to here if this rule does not match */

        /* element()
         */
        /* charRef(char,label)
         */
        matchc('\"'); 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSTRINGEx; /* Prevent compiler warnings */
    ruleSTRINGEx: ;


}
// $ANTLR end STRING

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IDSTRING
 *
 * Looks to match the chracters the constitute the token IDSTRING
 * from the attached input stream.
 *
 * Comes from: 736:7: ( '\\'' (~ ('\\''|'\\\\') | ESCAPE_SEQUENCE )* '\\'' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mIDSTRING(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = IDSTRING;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:736:7: ( '\\'' (~ ('\\''|'\\\\') | ESCAPE_SEQUENCE )* '\\'' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:736:7: '\\'' (~ ('\\''|'\\\\') | ESCAPE_SEQUENCE )* '\\''
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc('\''); 
        /* element()
         */
        
        /* closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) 
         *
         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:736:12: (~ ('\\''|'\\\\') | ESCAPE_SEQUENCE )*
         */
        
        for (;;)
        {
            int alt3=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA3_0 = LA(1);
                /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( ((LA3_0 >= 0x0000 && LA3_0 <= '&') || (LA3_0 >= '(' && LA3_0 <= '[') || (LA3_0 >= ']' && LA3_0 <= 0xFFFE)) ) 
                {
                    alt3=1; /* dfaAcceptState(alt) */
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA3_0 == '\\') ) 
                {
                    alt3=2; /* dfaAcceptState(alt) */
                }
            
            }
            switch (alt3) 
            {
        	/* altSwitchCase()
        	 */
        	case 1:
        	    /* alt(elements,altNum,description,autoAST,outerAlt)
        	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:736:14: ~ ('\\''|'\\\\')
        	     */
        	    {
        	        /* element()
        	         */
        	        /* matchSet(s,label,elementIndex,postmatchCode="")
        	         */
        	        if ( (LA(1) >= 0x0000 && LA(1) <= '&') || (LA(1) >= '(' && LA(1) <= '[') || (LA(1) >= ']' && LA(1) <= 0xFFFE) ) 
        	        {
        	            inputConsume();
        	        
        	        }
        	        else 
        	        {
        	            /* mismatchedSetEx()
        	             */
        	            exConstruct();
        	            theException()->type = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            theException()->name = ANTLR3_MISMATCHED_SET_NAME;
        	            lrecover();    goto ruleIDSTRINGEx;
        	        }

        	    
        	    }
        	    break;
        	/* altSwitchCase()
        	 */
        	case 2:
        	    /* alt(elements,altNum,description,autoAST,outerAlt)
        	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:736:31: ESCAPE_SEQUENCE
        	     */
        	    {
        	        /* element()
        	         */
        	        /* lexerRuleRef(rule,label,args)
        	         * From: 736:31: ESCAPE_SEQUENCE
        	         */
        	        mESCAPE_SEQUENCE(ctx ); 
        	    
        	    }
        	    break;
        
        	default:
        	    goto loop3;	/* break out of the loop */
        	    break;
            }
        }
        loop3: ; /* Jump out to here if this rule does not match */

        /* element()
         */
        /* charRef(char,label)
         */
        matchc('\''); 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleIDSTRINGEx; /* Prevent compiler warnings */
    ruleIDSTRINGEx: ;


}
// $ANTLR end IDSTRING

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESCAPE_SEQUENCE
 *
 * Looks to match the chracters the constitute the token ESCAPE_SEQUENCE
 * from the attached input stream.
 *
 * Comes from: 741:7: ( '\\\\' '\\\"' | '\\\\' '\\'' | '\\\\' '\\\\' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mESCAPE_SEQUENCE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ctx->pLexer->ruleNestingLevel++;
        
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:741:7: ( '\\\\' '\\\"' | '\\\\' '\\'' | '\\\\' '\\\\' )
        */
        ANTLR3_UINT32 alt4;
    
        alt4=3;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA4_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA4_0 == '\\') ) 
            {
                /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                 */
                switch ( LA(2) ) 
                {
                /* dfaEdgeSwitch(labels, targetState)
                 */
                case '\'':
                    alt4=2; /* dfaAcceptState(alt) */
                    break;
                /* dfaEdgeSwitch(labels, targetState)
                 */
                case '\\':
                    alt4=3; /* dfaAcceptState(alt) */
                    break;
                /* dfaEdgeSwitch(labels, targetState)
                 */
                case '"':
                    alt4=1; /* dfaAcceptState(alt) */
                    break;
                
                default:
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "739:1: fragment ESCAPE_SEQUENCE : ( '\\\\' '\\\"' | '\\\\' '\\'' | '\\\\' '\\\\' );";
                    theException()->decisionNum  = 4;
                    theException()->state        = 1;

                
                    goto ruleESCAPE_SEQUENCEEx;
                }
            
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "739:1: fragment ESCAPE_SEQUENCE : ( '\\\\' '\\\"' | '\\\\' '\\'' | '\\\\' '\\\\' );";
                theException()->decisionNum  = 4;
                theException()->state        = 0;

            
                goto ruleESCAPE_SEQUENCEEx;
            }
        }
        switch (alt4) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:741:7: '\\\\' '\\\"'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* charRef(char,label)
    	         */
    	        matchc('\\'); 
    	        /* element()
    	         */
    	        /* charRef(char,label)
    	         */
    	        matchc('\"'); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:742:9: '\\\\' '\\''
    	     */
    	    {
    	        /* element()
    	         */
    	        /* charRef(char,label)
    	         */
    	        matchc('\\'); 
    	        /* element()
    	         */
    	        /* charRef(char,label)
    	         */
    	        matchc('\''); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 3:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:743:9: '\\\\' '\\\\'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* charRef(char,label)
    	         */
    	        matchc('\\'); 
    	        /* element()
    	         */
    	        /* charRef(char,label)
    	         */
    	        matchc('\\'); 
    	    
    	    }
    	    break;
    
        }
    }
    ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleESCAPE_SEQUENCEEx; /* Prevent compiler warnings */
    ruleESCAPE_SEQUENCEEx: ;


}
// $ANTLR end ESCAPE_SEQUENCE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUOTE
 *
 * Looks to match the chracters the constitute the token QUOTE
 * from the attached input stream.
 *
 * Comes from: 747:10: ( '_' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mQUOTE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = QUOTE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:747:10: ( '_' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:747:10: '_'
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc('_'); 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleQUOTEEx; /* Prevent compiler warnings */
    ruleQUOTEEx: ;


}
// $ANTLR end QUOTE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LBRACE
 *
 * Looks to match the chracters the constitute the token LBRACE
 * from the attached input stream.
 *
 * Comes from: 748:11: ( '{' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mLBRACE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = LBRACE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:748:11: ( '{' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:748:11: '{'
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc('{'); 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleLBRACEEx; /* Prevent compiler warnings */
    ruleLBRACEEx: ;


}
// $ANTLR end LBRACE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RBRACE
 *
 * Looks to match the chracters the constitute the token RBRACE
 * from the attached input stream.
 *
 * Comes from: 749:11: ( '}' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mRBRACE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = RBRACE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:749:11: ( '}' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:749:11: '}'
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc('}'); 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleRBRACEEx; /* Prevent compiler warnings */
    ruleRBRACEEx: ;


}
// $ANTLR end RBRACE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEMI
 *
 * Looks to match the chracters the constitute the token SEMI
 * from the attached input stream.
 *
 * Comes from: 750:9: ( ';' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSEMI(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = SEMI;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:750:9: ( ';' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:750:9: ';'
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc(';'); 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSEMIEx; /* Prevent compiler warnings */
    ruleSEMIEx: ;


}
// $ANTLR end SEMI

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAREN
 *
 * Looks to match the chracters the constitute the token LPAREN
 * from the attached input stream.
 *
 * Comes from: 751:11: ( '(' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mLPAREN(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = LPAREN;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:751:11: ( '(' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:751:11: '('
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc('('); 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleLPARENEx; /* Prevent compiler warnings */
    ruleLPARENEx: ;


}
// $ANTLR end LPAREN

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAREN
 *
 * Looks to match the chracters the constitute the token RPAREN
 * from the attached input stream.
 *
 * Comes from: 752:11: ( ')' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mRPAREN(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = RPAREN;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:752:11: ( ')' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:752:11: ')'
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc(')'); 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleRPARENEx; /* Prevent compiler warnings */
    ruleRPARENEx: ;


}
// $ANTLR end RPAREN

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMA
 *
 * Looks to match the chracters the constitute the token COMMA
 * from the attached input stream.
 *
 * Comes from: 753:19: ( ',' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCOMMA(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = COMMA;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:753:19: ( ',' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:753:19: ','
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc(','); 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCOMMAEx; /* Prevent compiler warnings */
    ruleCOMMAEx: ;


}
// $ANTLR end COMMA

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ATTRIBUTEVALUE
 *
 * Looks to match the chracters the constitute the token ATTRIBUTEVALUE
 * from the attached input stream.
 *
 * Comes from: 756:4: ( '$' ( DIGIT )+ )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mATTRIBUTEVALUE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ATTRIBUTEVALUE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:756:4: ( '$' ( DIGIT )+ )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:756:4: '$' ( DIGIT )+
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc('$'); 
        /* element()
         */
        /* positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) 
         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:756:9: ( DIGIT )+
         */
        {
            int cnt5=0;
        
            for (;;)
            {
                int alt5=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA5_0 = LA(1);
        	    /* dfaEdge(labelExpr, targetState, predicates)
        	     */
        	    if ( ((LA5_0 >= '0' && LA5_0 <= '9')) ) 
        	    {
        	        alt5=1; /* dfaAcceptState(alt) */
        	    }
        	
        	}
        	switch (alt5) 
        	{
        	    /* altSwitchCase()
        	     */
        	    case 1:
        	        /* alt(elements,altNum,description,autoAST,outerAlt)
        	         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:756:9: DIGIT
        	         */
        	        {
        	            /* element()
        	             */
        	            /* lexerRuleRef(rule,label,args)
        	             * From: 756:9: DIGIT
        	             */
        	            mDIGIT(ctx ); 
        	        
        	        }
        	        break;
        
        	    default:
        	    
        		if ( cnt5 >= 1 )
        		{
        		    goto loop5; /* Ah well, generated code or I'd shoot myself */
        		}
        		/* mismatchedSetEx()
        		 */
        		exConstruct();
        		theException()->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		theException()->name = ANTLR3_MISMATCHED_SET_NAME;

        
        		goto ruleATTRIBUTEVALUEEx;
        	}
        	cnt5++;
            }
            loop5: ;	/* Jump to here if this rule does not match */
        }
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleATTRIBUTEVALUEEx; /* Prevent compiler warnings */
    ruleATTRIBUTEVALUEEx: ;


}
// $ANTLR end ATTRIBUTEVALUE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NUMBER
 *
 * Looks to match the chracters the constitute the token NUMBER
 * from the attached input stream.
 *
 * Comes from: 759:9: ( ( '-' )? ( DIGIT )+ )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mNUMBER(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = NUMBER;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:759:9: ( ( '-' )? ( DIGIT )+ )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:759:9: ( '-' )? ( DIGIT )+
     */
    {
        /* element()
         */
        
        /* block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
         *
         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:759:9: ( '-' )?
         */
        {
            int alt6=2;
            /* dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,sempredState)
             */
            {
                int LA6_0 = LA(1);
                /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA6_0 == '-') ) 
                {
                    alt6=1; /* dfaAcceptState(alt) */
                }
            }
            switch (alt6) 
            {
        	/* altSwitchCase()
        	 */
        	case 1:
        	    /* alt(elements,altNum,description,autoAST,outerAlt)
        	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:759:9: '-'
        	     */
        	    {
        	        /* element()
        	         */
        	        /* charRef(char,label)
        	         */
        	        matchc('-'); 
        	    
        	    }
        	    break;
        
            }
        }
        /* element()
         */
        /* positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) 
         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:759:14: ( DIGIT )+
         */
        {
            int cnt7=0;
        
            for (;;)
            {
                int alt7=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA7_0 = LA(1);
        	    /* dfaEdge(labelExpr, targetState, predicates)
        	     */
        	    if ( ((LA7_0 >= '0' && LA7_0 <= '9')) ) 
        	    {
        	        alt7=1; /* dfaAcceptState(alt) */
        	    }
        	
        	}
        	switch (alt7) 
        	{
        	    /* altSwitchCase()
        	     */
        	    case 1:
        	        /* alt(elements,altNum,description,autoAST,outerAlt)
        	         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:759:14: DIGIT
        	         */
        	        {
        	            /* element()
        	             */
        	            /* lexerRuleRef(rule,label,args)
        	             * From: 759:14: DIGIT
        	             */
        	            mDIGIT(ctx ); 
        	        
        	        }
        	        break;
        
        	    default:
        	    
        		if ( cnt7 >= 1 )
        		{
        		    goto loop7; /* Ah well, generated code or I'd shoot myself */
        		}
        		/* mismatchedSetEx()
        		 */
        		exConstruct();
        		theException()->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		theException()->name = ANTLR3_MISMATCHED_SET_NAME;

        
        		goto ruleNUMBEREx;
        	}
        	cnt7++;
            }
            loop7: ;	/* Jump to here if this rule does not match */
        }
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleNUMBEREx; /* Prevent compiler warnings */
    ruleNUMBEREx: ;


}
// $ANTLR end NUMBER

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIGIT
 *
 * Looks to match the chracters the constitute the token DIGIT
 * from the attached input stream.
 *
 * Comes from: 762:8: ( '0' .. '9' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mDIGIT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ctx->pLexer->ruleNestingLevel++;
        
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:762:8: ( '0' .. '9' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:762:8: '0' .. '9'
     */
    {
        /* element()
         */
        /* charRangeRef(a,b)
         */
        matchRange('0', '9'); 
    
    }

    ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleDIGITEx; /* Prevent compiler warnings */
    ruleDIGITEx: ;


}
// $ANTLR end DIGIT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AT
 *
 * Looks to match the chracters the constitute the token AT
 * from the attached input stream.
 *
 * Comes from: 766:25: ( '@' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mAT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = AT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:766:25: ( '@' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:766:25: '@'
     */
    {
        /* element()
         */
        /* charRef(char,label)
         */
        matchc('@'); 
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleATEx; /* Prevent compiler warnings */
    ruleATEx: ;


}
// $ANTLR end AT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AND
 *
 * Looks to match the chracters the constitute the token AND
 * from the attached input stream.
 *
 * Comes from: 767:25: ( 'AND' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mAND(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = AND;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:767:25: ( 'AND' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:767:25: 'AND'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_1); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleANDEx; /* Prevent compiler warnings */
    ruleANDEx: ;


}
// $ANTLR end AND

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AS
 *
 * Looks to match the chracters the constitute the token AS
 * from the attached input stream.
 *
 * Comes from: 768:25: ( 'AS' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mAS(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = AS;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:768:25: ( 'AS' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:768:25: 'AS'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_2); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleASEx; /* Prevent compiler warnings */
    ruleASEx: ;


}
// $ANTLR end AS

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASSOC
 *
 * Looks to match the chracters the constitute the token ASSOC
 * from the attached input stream.
 *
 * Comes from: 769:19: ( 'ASSOC' | 'assoc' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mASSOC(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ASSOC;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:769:19: ( 'ASSOC' | 'assoc' )
        */
        ANTLR3_UINT32 alt8;
    
        alt8=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA8_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA8_0 == 'A') ) 
            {
                alt8=1; /* dfaAcceptState(alt) */
            }
            else /* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA8_0 == 'a') ) 
            {
                alt8=2; /* dfaAcceptState(alt) */
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "769:1: ASSOC : ( 'ASSOC' | 'assoc' );";
                theException()->decisionNum  = 8;
                theException()->state        = 0;

            
                goto ruleASSOCEx;
            }
        }
        switch (alt8) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:769:19: 'ASSOC'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_3); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:769:29: 'assoc'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_4); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleASSOCEx; /* Prevent compiler warnings */
    ruleASSOCEx: ;


}
// $ANTLR end ASSOC

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASSOC_WITH
 *
 * Looks to match the chracters the constitute the token ASSOC_WITH
 * from the attached input stream.
 *
 * Comes from: 770:14: ( 'ASSOC' 'WITH' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mASSOC_WITH(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ASSOC_WITH;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:770:14: ( 'ASSOC' 'WITH' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:770:14: 'ASSOC' 'WITH'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_3); 

        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_5); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleASSOC_WITHEx; /* Prevent compiler warnings */
    ruleASSOC_WITHEx: ;


}
// $ANTLR end ASSOC_WITH

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ATTR
 *
 * Looks to match the chracters the constitute the token ATTR
 * from the attached input stream.
 *
 * Comes from: 771:25: ( 'ATTR' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mATTR(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ATTR;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:771:25: ( 'ATTR' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:771:25: 'ATTR'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_6); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleATTREx; /* Prevent compiler warnings */
    ruleATTREx: ;


}
// $ANTLR end ATTR

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ATTR8
 *
 * Looks to match the chracters the constitute the token ATTR8
 * from the attached input stream.
 *
 * Comes from: 772:25: ( 'attr8' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mATTR8(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ATTR8;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:772:25: ( 'attr8' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:772:25: 'attr8'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_7); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleATTR8Ex; /* Prevent compiler warnings */
    ruleATTR8Ex: ;


}
// $ANTLR end ATTR8

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ATTRNO
 *
 * Looks to match the chracters the constitute the token ATTRNO
 * from the attached input stream.
 *
 * Comes from: 773:25: ( 'attrno' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mATTRNO(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ATTRNO;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:773:25: ( 'attrno' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:773:25: 'attrno'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_8); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleATTRNOEx; /* Prevent compiler warnings */
    ruleATTRNOEx: ;


}
// $ANTLR end ATTRNO

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AVERAGE
 *
 * Looks to match the chracters the constitute the token AVERAGE
 * from the attached input stream.
 *
 * Comes from: 774:25: ( 'AVERAGE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mAVERAGE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = AVERAGE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:774:25: ( 'AVERAGE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:774:25: 'AVERAGE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_9); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleAVERAGEEx; /* Prevent compiler warnings */
    ruleAVERAGEEx: ;


}
// $ANTLR end AVERAGE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITMAP
 *
 * Looks to match the chracters the constitute the token BITMAP
 * from the attached input stream.
 *
 * Comes from: 775:25: ( 'bitmap' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBITMAP(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BITMAP;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:775:25: ( 'bitmap' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:775:25: 'bitmap'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_10); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBITMAPEx; /* Prevent compiler warnings */
    ruleBITMAPEx: ;


}
// $ANTLR end BITMAP

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITSLICE
 *
 * Looks to match the chracters the constitute the token BITSLICE
 * from the attached input stream.
 *
 * Comes from: 776:25: ( 'bitslice' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBITSLICE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BITSLICE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:776:25: ( 'bitslice' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:776:25: 'bitslice'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_11); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBITSLICEEx; /* Prevent compiler warnings */
    ruleBITSLICEEx: ;


}
// $ANTLR end BITSLICE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BETWEEN
 *
 * Looks to match the chracters the constitute the token BETWEEN
 * from the attached input stream.
 *
 * Comes from: 777:25: ( 'BETWEEN' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBETWEEN(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BETWEEN;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:777:25: ( 'BETWEEN' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:777:25: 'BETWEEN'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_12); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBETWEENEx; /* Prevent compiler warnings */
    ruleBETWEENEx: ;


}
// $ANTLR end BETWEEN

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BODY
 *
 * Looks to match the chracters the constitute the token BODY
 * from the attached input stream.
 *
 * Comes from: 778:25: ( 'body' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBODY(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BODY;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:778:25: ( 'body' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:778:25: 'body'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_13); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBODYEx; /* Prevent compiler warnings */
    ruleBODYEx: ;


}
// $ANTLR end BODY

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BREAK_ON
 *
 * Looks to match the chracters the constitute the token BREAK_ON
 * from the attached input stream.
 *
 * Comes from: 779:25: ( 'BREAK.ON' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBREAK_ON(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BREAK_ON;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:779:25: ( 'BREAK.ON' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:779:25: 'BREAK.ON'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_14); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBREAK_ONEx; /* Prevent compiler warnings */
    ruleBREAK_ONEx: ;


}
// $ANTLR end BREAK_ON

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BREAK_SUP
 *
 * Looks to match the chracters the constitute the token BREAK_SUP
 * from the attached input stream.
 *
 * Comes from: 780:25: ( 'BREAK.SUP' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBREAK_SUP(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BREAK_SUP;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:780:25: ( 'BREAK.SUP' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:780:25: 'BREAK.SUP'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_15); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBREAK_SUPEx; /* Prevent compiler warnings */
    ruleBREAK_SUPEx: ;


}
// $ANTLR end BREAK_SUP

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BY
 *
 * Looks to match the chracters the constitute the token BY
 * from the attached input stream.
 *
 * Comes from: 781:25: ( 'BY' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBY(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BY;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:781:25: ( 'BY' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:781:25: 'BY'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_16); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBYEx; /* Prevent compiler warnings */
    ruleBYEx: ;


}
// $ANTLR end BY

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BY_DSND
 *
 * Looks to match the chracters the constitute the token BY_DSND
 * from the attached input stream.
 *
 * Comes from: 782:25: ( 'BY.DSND' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBY_DSND(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BY_DSND;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:782:25: ( 'BY.DSND' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:782:25: 'BY.DSND'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_17); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBY_DSNDEx; /* Prevent compiler warnings */
    ruleBY_DSNDEx: ;


}
// $ANTLR end BY_DSND

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BY_EXP
 *
 * Looks to match the chracters the constitute the token BY_EXP
 * from the attached input stream.
 *
 * Comes from: 783:25: ( 'BY.EXP' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBY_EXP(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BY_EXP;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:783:25: ( 'BY.EXP' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:783:25: 'BY.EXP'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_18); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBY_EXPEx; /* Prevent compiler warnings */
    ruleBY_EXPEx: ;


}
// $ANTLR end BY_EXP

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BY_EXP_DSND
 *
 * Looks to match the chracters the constitute the token BY_EXP_DSND
 * from the attached input stream.
 *
 * Comes from: 784:25: ( 'BY.EXP.DSND' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBY_EXP_DSND(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BY_EXP_DSND;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:784:25: ( 'BY.EXP.DSND' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:784:25: 'BY.EXP.DSND'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_19); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBY_EXP_DSNDEx; /* Prevent compiler warnings */
    ruleBY_EXP_DSNDEx: ;


}
// $ANTLR end BY_EXP_DSND

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BY_EXP_SUB
 *
 * Looks to match the chracters the constitute the token BY_EXP_SUB
 * from the attached input stream.
 *
 * Comes from: 785:25: ( 'BY.EXP.SUB' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBY_EXP_SUB(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BY_EXP_SUB;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:785:25: ( 'BY.EXP.SUB' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:785:25: 'BY.EXP.SUB'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_20); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBY_EXP_SUBEx; /* Prevent compiler warnings */
    ruleBY_EXP_SUBEx: ;


}
// $ANTLR end BY_EXP_SUB

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BY_EXP_SUB_DSND
 *
 * Looks to match the chracters the constitute the token BY_EXP_SUB_DSND
 * from the attached input stream.
 *
 * Comes from: 786:25: ( 'BY.EXP.SUB.DSND' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBY_EXP_SUB_DSND(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BY_EXP_SUB_DSND;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:786:25: ( 'BY.EXP.SUB.DSND' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:786:25: 'BY.EXP.SUB.DSND'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_21); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBY_EXP_SUB_DSNDEx; /* Prevent compiler warnings */
    ruleBY_EXP_SUB_DSNDEx: ;


}
// $ANTLR end BY_EXP_SUB_DSND

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COL_HDG
 *
 * Looks to match the chracters the constitute the token COL_HDG
 * from the attached input stream.
 *
 * Comes from: 787:19: ( 'COL.HDG' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCOL_HDG(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = COL_HDG;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:787:19: ( 'COL.HDG' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:787:19: 'COL.HDG'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_22); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCOL_HDGEx; /* Prevent compiler warnings */
    ruleCOL_HDGEx: ;


}
// $ANTLR end COL_HDG

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CALC
 *
 * Looks to match the chracters the constitute the token CALC
 * from the attached input stream.
 *
 * Comes from: 788:25: ( 'CALC' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCALC(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = CALC;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:788:25: ( 'CALC' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:788:25: 'CALC'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_23); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCALCEx; /* Prevent compiler warnings */
    ruleCALCEx: ;


}
// $ANTLR end CALC

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COL_HDR_SUPP
 *
 * Looks to match the chracters the constitute the token COL_HDR_SUPP
 * from the attached input stream.
 *
 * Comes from: 789:16: ( 'COL.HDR.SUP' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCOL_HDR_SUPP(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = COL_HDR_SUPP;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:789:16: ( 'COL.HDR.SUP' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:789:16: 'COL.HDR.SUP'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_24); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCOL_HDR_SUPPEx; /* Prevent compiler warnings */
    ruleCOL_HDR_SUPPEx: ;


}
// $ANTLR end COL_HDR_SUPP

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COL_SPACES
 *
 * Looks to match the chracters the constitute the token COL_SPACES
 * from the attached input stream.
 *
 * Comes from: 790:19: ( 'COL.SPACES' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCOL_SPACES(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = COL_SPACES;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:790:19: ( 'COL.SPACES' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:790:19: 'COL.SPACES'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_25); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCOL_SPACESEx; /* Prevent compiler warnings */
    ruleCOL_SPACESEx: ;


}
// $ANTLR end COL_SPACES

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COL_SUPP
 *
 * Looks to match the chracters the constitute the token COL_SUPP
 * from the attached input stream.
 *
 * Comes from: 791:12: ( 'COL.SUP' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCOL_SUPP(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = COL_SUPP;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:791:12: ( 'COL.SUP' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:791:12: 'COL.SUP'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_26); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCOL_SUPPEx; /* Prevent compiler warnings */
    ruleCOL_SUPPEx: ;


}
// $ANTLR end COL_SUPP

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COLNO
 *
 * Looks to match the chracters the constitute the token COLNO
 * from the attached input stream.
 *
 * Comes from: 792:25: ( 'colno' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCOLNO(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = COLNO;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:792:25: ( 'colno' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:792:25: 'colno'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_27); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCOLNOEx; /* Prevent compiler warnings */
    ruleCOLNOEx: ;


}
// $ANTLR end COLNO

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COLLATED
 *
 * Looks to match the chracters the constitute the token COLLATED
 * from the attached input stream.
 *
 * Comes from: 793:25: ( 'collated' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCOLLATED(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = COLLATED;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:793:25: ( 'collated' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:793:25: 'collated'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_28); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCOLLATEDEx; /* Prevent compiler warnings */
    ruleCOLLATEDEx: ;


}
// $ANTLR end COLLATED

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMAND
 *
 * Looks to match the chracters the constitute the token COMMAND
 * from the attached input stream.
 *
 * Comes from: 794:19: ( 'command' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCOMMAND(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = COMMAND;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:794:19: ( 'command' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:794:19: 'command'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_29); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCOMMANDEx; /* Prevent compiler warnings */
    ruleCOMMANDEx: ;


}
// $ANTLR end COMMAND

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONV
 *
 * Looks to match the chracters the constitute the token CONV
 * from the attached input stream.
 *
 * Comes from: 795:19: ( 'CONV' | 'conv' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCONV(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = CONV;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:795:19: ( 'CONV' | 'conv' )
        */
        ANTLR3_UINT32 alt9;
    
        alt9=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA9_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA9_0 == 'C') ) 
            {
                alt9=1; /* dfaAcceptState(alt) */
            }
            else /* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA9_0 == 'c') ) 
            {
                alt9=2; /* dfaAcceptState(alt) */
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "795:1: CONV : ( 'CONV' | 'conv' );";
                theException()->decisionNum  = 9;
                theException()->state        = 0;

            
                goto ruleCONVEx;
            }
        }
        switch (alt9) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:795:19: 'CONV'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_30); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:795:28: 'conv'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_31); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCONVEx; /* Prevent compiler warnings */
    ruleCONVEx: ;


}
// $ANTLR end CONV

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COUNT_SUPP
 *
 * Looks to match the chracters the constitute the token COUNT_SUPP
 * from the attached input stream.
 *
 * Comes from: 796:14: ( 'COUNT.SUP' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mCOUNT_SUPP(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = COUNT_SUPP;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:796:14: ( 'COUNT.SUP' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:796:14: 'COUNT.SUP'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_32); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleCOUNT_SUPPEx; /* Prevent compiler warnings */
    ruleCOUNT_SUPPEx: ;


}
// $ANTLR end COUNT_SUPP

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DATASTREAM
 *
 * Looks to match the chracters the constitute the token DATASTREAM
 * from the attached input stream.
 *
 * Comes from: 797:14: ( 'DATASTREAM' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mDATASTREAM(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = DATASTREAM;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:797:14: ( 'DATASTREAM' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:797:14: 'DATASTREAM'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_33); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleDATASTREAMEx; /* Prevent compiler warnings */
    ruleDATASTREAMEx: ;


}
// $ANTLR end DATASTREAM

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DBL_SPACE
 *
 * Looks to match the chracters the constitute the token DBL_SPACE
 * from the attached input stream.
 *
 * Comes from: 798:13: ( 'DBL.SPACE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mDBL_SPACE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = DBL_SPACE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:798:13: ( 'DBL.SPACE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:798:13: 'DBL.SPACE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_34); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleDBL_SPACEEx; /* Prevent compiler warnings */
    ruleDBL_SPACEEx: ;


}
// $ANTLR end DBL_SPACE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DET_SUPP
 *
 * Looks to match the chracters the constitute the token DET_SUPP
 * from the attached input stream.
 *
 * Comes from: 799:12: ( 'DET.SUP' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mDET_SUPP(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = DET_SUPP;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:799:12: ( 'DET.SUP' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:799:12: 'DET.SUP'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_35); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleDET_SUPPEx; /* Prevent compiler warnings */
    ruleDET_SUPPEx: ;


}
// $ANTLR end DET_SUPP

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DICTIONARY
 *
 * Looks to match the chracters the constitute the token DICTIONARY
 * from the attached input stream.
 *
 * Comes from: 800:25: ( 'dictionary' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mDICTIONARY(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = DICTIONARY;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:800:25: ( 'dictionary' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:800:25: 'dictionary'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_36); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleDICTIONARYEx; /* Prevent compiler warnings */
    ruleDICTIONARYEx: ;


}
// $ANTLR end DICTIONARY

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DISPLAY_LIKE
 *
 * Looks to match the chracters the constitute the token DISPLAY_LIKE
 * from the attached input stream.
 *
 * Comes from: 801:16: ( 'DISPLAY' 'LIKE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mDISPLAY_LIKE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = DISPLAY_LIKE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:801:16: ( 'DISPLAY' 'LIKE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:801:16: 'DISPLAY' 'LIKE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_37); 

        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_38); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleDISPLAY_LIKEEx; /* Prevent compiler warnings */
    ruleDISPLAY_LIKEEx: ;


}
// $ANTLR end DISPLAY_LIKE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EACH
 *
 * Looks to match the chracters the constitute the token EACH
 * from the attached input stream.
 *
 * Comes from: 802:25: ( 'EACH' | 'EVERY' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mEACH(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = EACH;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:802:25: ( 'EACH' | 'EVERY' )
        */
        ANTLR3_UINT32 alt10;
    
        alt10=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA10_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA10_0 == 'E') ) 
            {
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA10_1 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA10_1 == 'A') ) 
                    {
                        alt10=1; /* dfaAcceptState(alt) */
                    }
                    else /* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA10_1 == 'V') ) 
                    {
                        alt10=2; /* dfaAcceptState(alt) */
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "802:1: EACH : ( 'EACH' | 'EVERY' );";
                        theException()->decisionNum  = 10;
                        theException()->state        = 1;

                    
                        goto ruleEACHEx;
                    }
                }
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "802:1: EACH : ( 'EACH' | 'EVERY' );";
                theException()->decisionNum  = 10;
                theException()->state        = 0;

            
                goto ruleEACHEx;
            }
        }
        switch (alt10) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:802:25: 'EACH'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_39); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:802:34: 'EVERY'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_40); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleEACHEx; /* Prevent compiler warnings */
    ruleEACHEx: ;


}
// $ANTLR end EACH

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ELEMENT
 *
 * Looks to match the chracters the constitute the token ELEMENT
 * from the attached input stream.
 *
 * Comes from: 803:25: ( 'element' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mELEMENT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ELEMENT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:803:25: ( 'element' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:803:25: 'element'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_41); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleELEMENTEx; /* Prevent compiler warnings */
    ruleELEMENTEx: ;


}
// $ANTLR end ELEMENT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ENUM
 *
 * Looks to match the chracters the constitute the token ENUM
 * from the attached input stream.
 *
 * Comes from: 804:25: ( 'ENUM' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mENUM(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ENUM;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:804:25: ( 'ENUM' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:804:25: 'ENUM'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_42); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleENUMEx; /* Prevent compiler warnings */
    ruleENUMEx: ;


}
// $ANTLR end ENUM

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQ
 *
 * Looks to match the chracters the constitute the token EQ
 * from the attached input stream.
 *
 * Comes from: 805:25: ( 'EQ' | '=' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mEQ(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = EQ;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:805:25: ( 'EQ' | '=' )
        */
        ANTLR3_UINT32 alt11;
    
        alt11=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA11_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA11_0 == 'E') ) 
            {
                alt11=1; /* dfaAcceptState(alt) */
            }
            else /* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA11_0 == '=') ) 
            {
                alt11=2; /* dfaAcceptState(alt) */
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "805:1: EQ : ( 'EQ' | '=' );";
                theException()->decisionNum  = 11;
                theException()->state        = 0;

            
                goto ruleEQEx;
            }
        }
        switch (alt11) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:805:25: 'EQ'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_43); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:805:32: '='
    	     */
    	    {
    	        /* element()
    	         */
    	        /* charRef(char,label)
    	         */
    	        matchc('='); 
    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleEQEx; /* Prevent compiler warnings */
    ruleEQEx: ;


}
// $ANTLR end EQ

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EVAL
 *
 * Looks to match the chracters the constitute the token EVAL
 * from the attached input stream.
 *
 * Comes from: 806:25: ( 'EVAL' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mEVAL(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = EVAL;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:806:25: ( 'EVAL' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:806:25: 'EVAL'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_44); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleEVALEx; /* Prevent compiler warnings */
    ruleEVALEx: ;


}
// $ANTLR end EVAL

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BFALSE
 *
 * Looks to match the chracters the constitute the token BFALSE
 * from the attached input stream.
 *
 * Comes from: 807:26: ( 'false' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBFALSE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BFALSE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:807:26: ( 'false' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:807:26: 'false'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_45); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBFALSEEx; /* Prevent compiler warnings */
    ruleBFALSEEx: ;


}
// $ANTLR end BFALSE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FILENAME
 *
 * Looks to match the chracters the constitute the token FILENAME
 * from the attached input stream.
 *
 * Comes from: 808:19: ( 'filename' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mFILENAME(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = FILENAME;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:808:19: ( 'filename' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:808:19: 'filename'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_46); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleFILENAMEEx; /* Prevent compiler warnings */
    ruleFILENAMEEx: ;


}
// $ANTLR end FILENAME

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FILETYPE
 *
 * Looks to match the chracters the constitute the token FILETYPE
 * from the attached input stream.
 *
 * Comes from: 809:25: ( 'filetype' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mFILETYPE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = FILETYPE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:809:25: ( 'filetype' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:809:25: 'filetype'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_47); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleFILETYPEEx; /* Prevent compiler warnings */
    ruleFILETYPEEx: ;


}
// $ANTLR end FILETYPE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FMT
 *
 * Looks to match the chracters the constitute the token FMT
 * from the attached input stream.
 *
 * Comes from: 810:19: ( 'FMT' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mFMT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = FMT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:810:19: ( 'FMT' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:810:19: 'FMT'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_48); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleFMTEx; /* Prevent compiler warnings */
    ruleFMTEx: ;


}
// $ANTLR end FMT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOOTING
 *
 * Looks to match the chracters the constitute the token FOOTING
 * from the attached input stream.
 *
 * Comes from: 811:19: ( 'FOOTING' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mFOOTING(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = FOOTING;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:811:19: ( 'FOOTING' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:811:19: 'FOOTING'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_49); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleFOOTINGEx; /* Prevent compiler warnings */
    ruleFOOTINGEx: ;


}
// $ANTLR end FOOTING

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FORMAT
 *
 * Looks to match the chracters the constitute the token FORMAT
 * from the attached input stream.
 *
 * Comes from: 812:25: ( 'format' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mFORMAT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = FORMAT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:812:25: ( 'format' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:812:25: 'format'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_50); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleFORMATEx; /* Prevent compiler warnings */
    ruleFORMATEx: ;


}
// $ANTLR end FORMAT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FROM
 *
 * Looks to match the chracters the constitute the token FROM
 * from the attached input stream.
 *
 * Comes from: 813:19: ( 'FROM' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mFROM(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = FROM;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:813:19: ( 'FROM' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:813:19: 'FROM'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_51); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleFROMEx; /* Prevent compiler warnings */
    ruleFROMEx: ;


}
// $ANTLR end FROM

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GE
 *
 * Looks to match the chracters the constitute the token GE
 * from the attached input stream.
 *
 * Comes from: 814:25: ( 'GE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mGE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = GE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:814:25: ( 'GE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:814:25: 'GE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_52); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleGEEx; /* Prevent compiler warnings */
    ruleGEEx: ;


}
// $ANTLR end GE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GLOBAL
 *
 * Looks to match the chracters the constitute the token GLOBAL
 * from the attached input stream.
 *
 * Comes from: 815:25: ( 'global' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mGLOBAL(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = GLOBAL;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:815:25: ( 'global' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:815:25: 'global'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_53); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleGLOBALEx; /* Prevent compiler warnings */
    ruleGLOBALEx: ;


}
// $ANTLR end GLOBAL

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GRAND_TOTAL
 *
 * Looks to match the chracters the constitute the token GRAND_TOTAL
 * from the attached input stream.
 *
 * Comes from: 816:15: ( 'GRAND.TOTAL' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mGRAND_TOTAL(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = GRAND_TOTAL;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:816:15: ( 'GRAND.TOTAL' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:816:15: 'GRAND.TOTAL'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_54); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleGRAND_TOTALEx; /* Prevent compiler warnings */
    ruleGRAND_TOTALEx: ;


}
// $ANTLR end GRAND_TOTAL

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GT
 *
 * Looks to match the chracters the constitute the token GT
 * from the attached input stream.
 *
 * Comes from: 817:25: ( 'GT' | 'AFTER' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mGT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = GT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:817:25: ( 'GT' | 'AFTER' )
        */
        ANTLR3_UINT32 alt12;
    
        alt12=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA12_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA12_0 == 'G') ) 
            {
                alt12=1; /* dfaAcceptState(alt) */
            }
            else /* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA12_0 == 'A') ) 
            {
                alt12=2; /* dfaAcceptState(alt) */
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "817:1: GT : ( 'GT' | 'AFTER' );";
                theException()->decisionNum  = 12;
                theException()->state        = 0;

            
                goto ruleGTEx;
            }
        }
        switch (alt12) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:817:25: 'GT'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_55); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:817:31: 'AFTER'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_56); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleGTEx; /* Prevent compiler warnings */
    ruleGTEx: ;


}
// $ANTLR end GT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HDR_SUPP
 *
 * Looks to match the chracters the constitute the token HDR_SUPP
 * from the attached input stream.
 *
 * Comes from: 818:12: ( 'HDR.SUP' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mHDR_SUPP(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = HDR_SUPP;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:818:12: ( 'HDR.SUP' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:818:12: 'HDR.SUP'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_57); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleHDR_SUPPEx; /* Prevent compiler warnings */
    ruleHDR_SUPPEx: ;


}
// $ANTLR end HDR_SUPP

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEADING
 *
 * Looks to match the chracters the constitute the token HEADING
 * from the attached input stream.
 *
 * Comes from: 819:25: ( 'heading' | 'HEADING' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mHEADING(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = HEADING;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:819:25: ( 'heading' | 'HEADING' )
        */
        ANTLR3_UINT32 alt13;
    
        alt13=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA13_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA13_0 == 'h') ) 
            {
                alt13=1; /* dfaAcceptState(alt) */
            }
            else /* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA13_0 == 'H') ) 
            {
                alt13=2; /* dfaAcceptState(alt) */
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "819:1: HEADING : ( 'heading' | 'HEADING' );";
                theException()->decisionNum  = 13;
                theException()->state        = 0;

            
                goto ruleHEADINGEx;
            }
        }
        switch (alt13) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:819:25: 'heading'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_58); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:819:37: 'HEADING'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_59); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleHEADINGEx; /* Prevent compiler warnings */
    ruleHEADINGEx: ;


}
// $ANTLR end HEADING

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ID_SUPP
 *
 * Looks to match the chracters the constitute the token ID_SUPP
 * from the attached input stream.
 *
 * Comes from: 820:19: ( 'ID.SUP' ( 'P' )? )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mID_SUPP(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ID_SUPP;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:820:19: ( 'ID.SUP' ( 'P' )? )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:820:19: 'ID.SUP' ( 'P' )?
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_60); 

        /* element()
         */
        
        /* block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
         *
         * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:820:28: ( 'P' )?
         */
        {
            int alt14=2;
            /* dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,sempredState)
             */
            {
                int LA14_0 = LA(1);
                /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA14_0 == 'P') ) 
                {
                    alt14=1; /* dfaAcceptState(alt) */
                }
            }
            switch (alt14) 
            {
        	/* altSwitchCase()
        	 */
        	case 1:
        	    /* alt(elements,altNum,description,autoAST,outerAlt)
        	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:820:28: 'P'
        	     */
        	    {
        	        /* element()
        	         */
        	        /* charRef(char,label)
        	         */
        	        matchc('P'); 
        	    
        	    }
        	    break;
        
            }
        }
    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleID_SUPPEx; /* Prevent compiler warnings */
    ruleID_SUPPEx: ;


}
// $ANTLR end ID_SUPP

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IDLIST
 *
 * Looks to match the chracters the constitute the token IDLIST
 * from the attached input stream.
 *
 * Comes from: 821:17: ( 'IDLIST' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mIDLIST(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = IDLIST;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:821:17: ( 'IDLIST' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:821:17: 'IDLIST'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_61); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleIDLISTEx; /* Prevent compiler warnings */
    ruleIDLISTEx: ;


}
// $ANTLR end IDLIST

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INQUIRING
 *
 * Looks to match the chracters the constitute the token INQUIRING
 * from the attached input stream.
 *
 * Comes from: 822:25: ( 'INQUIRING' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mINQUIRING(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = INQUIRING;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:822:25: ( 'INQUIRING' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:822:25: 'INQUIRING'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_62); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleINQUIRINGEx; /* Prevent compiler warnings */
    ruleINQUIRINGEx: ;


}
// $ANTLR end INQUIRING

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INDEX
 *
 * Looks to match the chracters the constitute the token INDEX
 * from the attached input stream.
 *
 * Comes from: 823:25: ( 'index' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mINDEX(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = INDEX;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:823:25: ( 'index' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:823:25: 'index'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_63); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleINDEXEx; /* Prevent compiler warnings */
    ruleINDEXEx: ;


}
// $ANTLR end INDEX

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INDEXES
 *
 * Looks to match the chracters the constitute the token INDEXES
 * from the attached input stream.
 *
 * Comes from: 824:25: ( 'indexes' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mINDEXES(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = INDEXES;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:824:25: ( 'indexes' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:824:25: 'indexes'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_64); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleINDEXESEx; /* Prevent compiler warnings */
    ruleINDEXESEx: ;


}
// $ANTLR end INDEXES

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTERNAL
 *
 * Looks to match the chracters the constitute the token INTERNAL
 * from the attached input stream.
 *
 * Comes from: 825:25: ( 'INTERNAL' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mINTERNAL(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = INTERNAL;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:825:25: ( 'INTERNAL' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:825:25: 'INTERNAL'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_65); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleINTERNALEx; /* Prevent compiler warnings */
    ruleINTERNALEx: ;


}
// $ANTLR end INTERNAL

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ISNULL
 *
 * Looks to match the chracters the constitute the token ISNULL
 * from the attached input stream.
 *
 * Comes from: 826:11: ( 'IS.NULL' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mISNULL(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ISNULL;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:826:11: ( 'IS.NULL' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:826:11: 'IS.NULL'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_66); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleISNULLEx; /* Prevent compiler warnings */
    ruleISNULLEx: ;


}
// $ANTLR end ISNULL

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ISNOTNULL
 *
 * Looks to match the chracters the constitute the token ISNOTNULL
 * from the attached input stream.
 *
 * Comes from: 827:13: ( 'IS.NOT.NULL' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mISNOTNULL(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ISNOTNULL;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:827:13: ( 'IS.NOT.NULL' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:827:13: 'IS.NOT.NULL'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_67); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleISNOTNULLEx; /* Prevent compiler warnings */
    ruleISNOTNULLEx: ;


}
// $ANTLR end ISNOTNULL

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ORDER
 *
 * Looks to match the chracters the constitute the token ORDER
 * from the attached input stream.
 *
 * Comes from: 828:25: ( 'order' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mORDER(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ORDER;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:828:25: ( 'order' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:828:25: 'order'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_68); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleORDEREx; /* Prevent compiler warnings */
    ruleORDEREx: ;


}
// $ANTLR end ORDER

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ITYPE
 *
 * Looks to match the chracters the constitute the token ITYPE
 * from the attached input stream.
 *
 * Comes from: 829:25: ( 'itype' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mITYPE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ITYPE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:829:25: ( 'itype' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:829:25: 'itype'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_69); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleITYPEEx; /* Prevent compiler warnings */
    ruleITYPEEx: ;


}
// $ANTLR end ITYPE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ITEMSTREAM
 *
 * Looks to match the chracters the constitute the token ITEMSTREAM
 * from the attached input stream.
 *
 * Comes from: 830:14: ( 'ITEMSTREAM' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mITEMSTREAM(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ITEMSTREAM;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:830:14: ( 'ITEMSTREAM' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:830:14: 'ITEMSTREAM'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_70); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleITEMSTREAMEx; /* Prevent compiler warnings */
    ruleITEMSTREAMEx: ;


}
// $ANTLR end ITEMSTREAM

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start JUSTIFICATION
 *
 * Looks to match the chracters the constitute the token JUSTIFICATION
 * from the attached input stream.
 *
 * Comes from: 831:25: ( 'justification' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mJUSTIFICATION(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = JUSTIFICATION;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:831:25: ( 'justification' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:831:25: 'justification'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_71); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleJUSTIFICATIONEx; /* Prevent compiler warnings */
    ruleJUSTIFICATIONEx: ;


}
// $ANTLR end JUSTIFICATION

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LE
 *
 * Looks to match the chracters the constitute the token LE
 * from the attached input stream.
 *
 * Comes from: 832:25: ( 'LE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mLE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = LE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:832:25: ( 'LE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:832:25: 'LE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_72); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleLEEx; /* Prevent compiler warnings */
    ruleLEEx: ;


}
// $ANTLR end LE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LIKE
 *
 * Looks to match the chracters the constitute the token LIKE
 * from the attached input stream.
 *
 * Comes from: 833:19: ( 'LIKE' | 'MATCHES' | 'MATCHING' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mLIKE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = LIKE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:833:19: ( 'LIKE' | 'MATCHES' | 'MATCHING' )
        */
        ANTLR3_UINT32 alt15;
    
        alt15=3;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA15_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA15_0 == 'L') ) 
            {
                alt15=1; /* dfaAcceptState(alt) */
            }
            else /* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA15_0 == 'M') ) 
            {
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA15_2 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA15_2 == 'A') ) 
                    {
                        
                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                         */
                        {
                            int LA15_3 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA15_3 == 'T') ) 
                            {
                                
                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                 */
                                {
                                    int LA15_4 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                                     */
                                    if ( (LA15_4 == 'C') ) 
                                    {
                                        
                                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                         */
                                        {
                                            int LA15_5 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                             */
                                            if ( (LA15_5 == 'H') ) 
                                            {
                                                
                                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                 */
                                                {
                                                    int LA15_6 = LA(6);/* dfaEdge(labelExpr, targetState, predicates)
                                                     */
                                                    if ( (LA15_6 == 'I') ) 
                                                    {
                                                        alt15=3; /* dfaAcceptState(alt) */
                                                    }
                                                    else /* dfaEdge(labelExpr, targetState, predicates)
                                                     */
                                                    if ( (LA15_6 == 'E') ) 
                                                    {
                                                        alt15=2; /* dfaAcceptState(alt) */
                                                    }
                                                    else 
                                                    {
                                                    
                                                        /* newNVException()
                                                         */
                                                        exConstruct();
                                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        theException()->message      = "833:1: LIKE : ( 'LIKE' | 'MATCHES' | 'MATCHING' );";
                                                        theException()->decisionNum  = 15;
                                                        theException()->state        = 6;

                                                    
                                                        goto ruleLIKEEx;
                                                    }
                                                }
                                            }
                                            else 
                                            {
                                            
                                                /* newNVException()
                                                 */
                                                exConstruct();
                                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                theException()->message      = "833:1: LIKE : ( 'LIKE' | 'MATCHES' | 'MATCHING' );";
                                                theException()->decisionNum  = 15;
                                                theException()->state        = 5;

                                            
                                                goto ruleLIKEEx;
                                            }
                                        }
                                    }
                                    else 
                                    {
                                    
                                        /* newNVException()
                                         */
                                        exConstruct();
                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        theException()->message      = "833:1: LIKE : ( 'LIKE' | 'MATCHES' | 'MATCHING' );";
                                        theException()->decisionNum  = 15;
                                        theException()->state        = 4;

                                    
                                        goto ruleLIKEEx;
                                    }
                                }
                            }
                            else 
                            {
                            
                                /* newNVException()
                                 */
                                exConstruct();
                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                theException()->message      = "833:1: LIKE : ( 'LIKE' | 'MATCHES' | 'MATCHING' );";
                                theException()->decisionNum  = 15;
                                theException()->state        = 3;

                            
                                goto ruleLIKEEx;
                            }
                        }
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "833:1: LIKE : ( 'LIKE' | 'MATCHES' | 'MATCHING' );";
                        theException()->decisionNum  = 15;
                        theException()->state        = 2;

                    
                        goto ruleLIKEEx;
                    }
                }
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "833:1: LIKE : ( 'LIKE' | 'MATCHES' | 'MATCHING' );";
                theException()->decisionNum  = 15;
                theException()->state        = 0;

            
                goto ruleLIKEEx;
            }
        }
        switch (alt15) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:833:19: 'LIKE'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_38); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:833:28: 'MATCHES'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_73); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 3:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:833:40: 'MATCHING'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_74); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleLIKEEx; /* Prevent compiler warnings */
    ruleLIKEEx: ;


}
// $ANTLR end LIKE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OPT_LPTR
 *
 * Looks to match the chracters the constitute the token OPT_LPTR
 * from the attached input stream.
 *
 * Comes from: 834:23: ( 'LPTR' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mOPT_LPTR(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = OPT_LPTR;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:834:23: ( 'LPTR' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:834:23: 'LPTR'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_75); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleOPT_LPTREx; /* Prevent compiler warnings */
    ruleOPT_LPTREx: ;


}
// $ANTLR end OPT_LPTR

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OP_LT
 *
 * Looks to match the chracters the constitute the token OP_LT
 * from the attached input stream.
 *
 * Comes from: 835:28: ( 'LT' | 'BEFORE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mOP_LT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = OP_LT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:835:28: ( 'LT' | 'BEFORE' )
        */
        ANTLR3_UINT32 alt16;
    
        alt16=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA16_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA16_0 == 'L') ) 
            {
                alt16=1; /* dfaAcceptState(alt) */
            }
            else /* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA16_0 == 'B') ) 
            {
                alt16=2; /* dfaAcceptState(alt) */
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "835:1: OP_LT : ( 'LT' | 'BEFORE' );";
                theException()->decisionNum  = 16;
                theException()->state        = 0;

            
                goto ruleOP_LTEx;
            }
        }
        switch (alt16) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:835:28: 'LT'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_76); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:835:35: 'BEFORE'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_77); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleOP_LTEx; /* Prevent compiler warnings */
    ruleOP_LTEx: ;


}
// $ANTLR end OP_LT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MARGIN
 *
 * Looks to match the chracters the constitute the token MARGIN
 * from the attached input stream.
 *
 * Comes from: 836:19: ( 'MARGIN' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mMARGIN(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = MARGIN;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:836:19: ( 'MARGIN' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:836:19: 'MARGIN'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_78); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleMARGINEx; /* Prevent compiler warnings */
    ruleMARGINEx: ;


}
// $ANTLR end MARGIN

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MAX
 *
 * Looks to match the chracters the constitute the token MAX
 * from the attached input stream.
 *
 * Comes from: 837:25: ( 'MAX' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mMAX(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = MAX;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:837:25: ( 'MAX' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:837:25: 'MAX'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_79); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleMAXEx; /* Prevent compiler warnings */
    ruleMAXEx: ;


}
// $ANTLR end MAX

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MIN
 *
 * Looks to match the chracters the constitute the token MIN
 * from the attached input stream.
 *
 * Comes from: 838:25: ( 'MIN' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mMIN(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = MIN;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:838:25: ( 'MIN' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:838:25: 'MIN'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_80); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleMINEx; /* Prevent compiler warnings */
    ruleMINEx: ;


}
// $ANTLR end MIN

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MULTI_VALUE
 *
 * Looks to match the chracters the constitute the token MULTI_VALUE
 * from the attached input stream.
 *
 * Comes from: 839:15: ( 'MULTI.VALUE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mMULTI_VALUE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = MULTI_VALUE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:839:15: ( 'MULTI.VALUE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:839:15: 'MULTI.VALUE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_81); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleMULTI_VALUEEx; /* Prevent compiler warnings */
    ruleMULTI_VALUEEx: ;


}
// $ANTLR end MULTI_VALUE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MV
 *
 * Looks to match the chracters the constitute the token MV
 * from the attached input stream.
 *
 * Comes from: 840:25: ( 'mv' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mMV(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = MV;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:840:25: ( 'mv' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:840:25: 'mv'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_82); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleMVEx; /* Prevent compiler warnings */
    ruleMVEx: ;


}
// $ANTLR end MV

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NAME
 *
 * Looks to match the chracters the constitute the token NAME
 * from the attached input stream.
 *
 * Comes from: 841:25: ( 'name' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mNAME(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = NAME;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:841:25: ( 'name' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:841:25: 'name'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_83); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleNAMEEx; /* Prevent compiler warnings */
    ruleNAMEEx: ;


}
// $ANTLR end NAME

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NE
 *
 * Looks to match the chracters the constitute the token NE
 * from the attached input stream.
 *
 * Comes from: 842:25: ( 'NE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mNE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = NE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:842:25: ( 'NE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:842:25: 'NE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_84); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleNEEx; /* Prevent compiler warnings */
    ruleNEEx: ;


}
// $ANTLR end NE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NO
 *
 * Looks to match the chracters the constitute the token NO
 * from the attached input stream.
 *
 * Comes from: 843:25: ( 'NO' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mNO(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = NO;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:843:25: ( 'NO' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:843:25: 'NO'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_85); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleNOEx; /* Prevent compiler warnings */
    ruleNOEx: ;


}
// $ANTLR end NO

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NODE
 *
 * Looks to match the chracters the constitute the token NODE
 * from the attached input stream.
 *
 * Comes from: 844:25: ( 'NODE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mNODE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = NODE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:844:25: ( 'NODE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:844:25: 'NODE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_86); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleNODEEx; /* Prevent compiler warnings */
    ruleNODEEx: ;


}
// $ANTLR end NODE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NO_INDEX
 *
 * Looks to match the chracters the constitute the token NO_INDEX
 * from the attached input stream.
 *
 * Comes from: 845:12: ( 'NO.INDEX' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mNO_INDEX(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = NO_INDEX;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:845:12: ( 'NO.INDEX' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:845:12: 'NO.INDEX'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_87); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleNO_INDEXEx; /* Prevent compiler warnings */
    ruleNO_INDEXEx: ;


}
// $ANTLR end NO_INDEX

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NO_NULLS
 *
 * Looks to match the chracters the constitute the token NO_NULLS
 * from the attached input stream.
 *
 * Comes from: 846:25: ( 'NO.NULLS' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mNO_NULLS(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = NO_NULLS;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:846:25: ( 'NO.NULLS' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:846:25: 'NO.NULLS'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_88); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleNO_NULLSEx; /* Prevent compiler warnings */
    ruleNO_NULLSEx: ;


}
// $ANTLR end NO_NULLS

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOPAGE
 *
 * Looks to match the chracters the constitute the token NOPAGE
 * from the attached input stream.
 *
 * Comes from: 847:19: ( 'NOPAGE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mNOPAGE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = NOPAGE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:847:19: ( 'NOPAGE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:847:19: 'NOPAGE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_89); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleNOPAGEEx; /* Prevent compiler warnings */
    ruleNOPAGEEx: ;


}
// $ANTLR end NOPAGE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOSPLIT
 *
 * Looks to match the chracters the constitute the token NOSPLIT
 * from the attached input stream.
 *
 * Comes from: 848:19: ( 'NOSPLIT' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mNOSPLIT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = NOSPLIT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:848:19: ( 'NOSPLIT' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:848:19: 'NOSPLIT'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_90); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleNOSPLITEx; /* Prevent compiler warnings */
    ruleNOSPLITEx: ;


}
// $ANTLR end NOSPLIT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOT
 *
 * Looks to match the chracters the constitute the token NOT
 * from the attached input stream.
 *
 * Comes from: 849:25: ( 'NOT' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mNOT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = NOT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:849:25: ( 'NOT' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:849:25: 'NOT'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_91); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleNOTEx; /* Prevent compiler warnings */
    ruleNOTEx: ;


}
// $ANTLR end NOT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ONLY
 *
 * Looks to match the chracters the constitute the token ONLY
 * from the attached input stream.
 *
 * Comes from: 850:19: ( 'ONLY' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mONLY(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = ONLY;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:850:19: ( 'ONLY' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:850:19: 'ONLY'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_92); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleONLYEx; /* Prevent compiler warnings */
    ruleONLYEx: ;


}
// $ANTLR end ONLY

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OPTIONS
 *
 * Looks to match the chracters the constitute the token OPTIONS
 * from the attached input stream.
 *
 * Comes from: 851:25: ( 'options' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mOPTIONS(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = OPTIONS;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:851:25: ( 'options' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:851:25: 'options'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_93); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleOPTIONSEx; /* Prevent compiler warnings */
    ruleOPTIONSEx: ;


}
// $ANTLR end OPTIONS

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OR
 *
 * Looks to match the chracters the constitute the token OR
 * from the attached input stream.
 *
 * Comes from: 852:25: ( 'OR' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mOR(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = OR;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:852:25: ( 'OR' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:852:25: 'OR'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_94); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleOREx; /* Prevent compiler warnings */
    ruleOREx: ;


}
// $ANTLR end OR

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LIST_SPEC
 *
 * Looks to match the chracters the constitute the token LIST_SPEC
 * from the attached input stream.
 *
 * Comes from: 853:25: ( 'output' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mLIST_SPEC(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = LIST_SPEC;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:853:25: ( 'output' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:853:25: 'output'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_95); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleLIST_SPECEx; /* Prevent compiler warnings */
    ruleLIST_SPECEx: ;


}
// $ANTLR end LIST_SPEC

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PERCENT
 *
 * Looks to match the chracters the constitute the token PERCENT
 * from the attached input stream.
 *
 * Comes from: 854:25: ( 'PERCENT' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mPERCENT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = PERCENT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:854:25: ( 'PERCENT' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:854:25: 'PERCENT'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_96); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto rulePERCENTEx; /* Prevent compiler warnings */
    rulePERCENTEx: ;


}
// $ANTLR end PERCENT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PRINTER
 *
 * Looks to match the chracters the constitute the token PRINTER
 * from the attached input stream.
 *
 * Comes from: 855:25: ( 'printer' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mPRINTER(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = PRINTER;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:855:25: ( 'printer' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:855:25: 'printer'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_97); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto rulePRINTEREx; /* Prevent compiler warnings */
    rulePRINTEREx: ;


}
// $ANTLR end PRINTER

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PROCESSOR
 *
 * Looks to match the chracters the constitute the token PROCESSOR
 * from the attached input stream.
 *
 * Comes from: 856:25: ( 'processor' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mPROCESSOR(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = PROCESSOR;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:856:25: ( 'processor' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:856:25: 'processor'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_98); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto rulePROCESSOREx; /* Prevent compiler warnings */
    rulePROCESSOREx: ;


}
// $ANTLR end PROCESSOR

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUERY
 *
 * Looks to match the chracters the constitute the token QUERY
 * from the attached input stream.
 *
 * Comes from: 857:25: ( 'query' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mQUERY(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = QUERY;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:857:25: ( 'query' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:857:25: 'query'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_99); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleQUERYEx; /* Prevent compiler warnings */
    ruleQUERYEx: ;


}
// $ANTLR end QUERY

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REFNO
 *
 * Looks to match the chracters the constitute the token REFNO
 * from the attached input stream.
 *
 * Comes from: 858:25: ( 'refno' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mREFNO(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = REFNO;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:858:25: ( 'refno' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:858:25: 'refno'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_100); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleREFNOEx; /* Prevent compiler warnings */
    ruleREFNOEx: ;


}
// $ANTLR end REFNO

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REGULAR
 *
 * Looks to match the chracters the constitute the token REGULAR
 * from the attached input stream.
 *
 * Comes from: 859:12: ( 'regular' | 'REGULAR' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mREGULAR(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = REGULAR;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:859:12: ( 'regular' | 'REGULAR' )
        */
        ANTLR3_UINT32 alt17;
    
        alt17=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA17_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA17_0 == 'r') ) 
            {
                alt17=1; /* dfaAcceptState(alt) */
            }
            else /* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA17_0 == 'R') ) 
            {
                alt17=2; /* dfaAcceptState(alt) */
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "859:1: REGULAR : ( 'regular' | 'REGULAR' );";
                theException()->decisionNum  = 17;
                theException()->state        = 0;

            
                goto ruleREGULAREx;
            }
        }
        switch (alt17) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:859:12: 'regular'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_101); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:859:24: 'REGULAR'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_102); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleREGULAREx; /* Prevent compiler warnings */
    ruleREGULAREx: ;


}
// $ANTLR end REGULAR

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REQUIRE_INDEX
 *
 * Looks to match the chracters the constitute the token REQUIRE_INDEX
 * from the attached input stream.
 *
 * Comes from: 860:17: ( 'REQUIRE.INDEX' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mREQUIRE_INDEX(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = REQUIRE_INDEX;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:860:17: ( 'REQUIRE.INDEX' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:860:17: 'REQUIRE.INDEX'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_103); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleREQUIRE_INDEXEx; /* Prevent compiler warnings */
    ruleREQUIRE_INDEXEx: ;


}
// $ANTLR end REQUIRE_INDEX

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REQUIRE_SELECT
 *
 * Looks to match the chracters the constitute the token REQUIRE_SELECT
 * from the attached input stream.
 *
 * Comes from: 861:18: ( 'REQUIRE.SELECT' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mREQUIRE_SELECT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = REQUIRE_SELECT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:861:18: ( 'REQUIRE.SELECT' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:861:18: 'REQUIRE.SELECT'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_104); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleREQUIRE_SELECTEx; /* Prevent compiler warnings */
    ruleREQUIRE_SELECTEx: ;


}
// $ANTLR end REQUIRE_SELECT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAID
 *
 * Looks to match the chracters the constitute the token SAID
 * from the attached input stream.
 *
 * Comes from: 862:25: ( 'SAID' | 'SPOKEN' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSAID(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = SAID;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:862:25: ( 'SAID' | 'SPOKEN' )
        */
        ANTLR3_UINT32 alt18;
    
        alt18=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA18_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA18_0 == 'S') ) 
            {
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA18_1 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA18_1 == 'A') ) 
                    {
                        alt18=1; /* dfaAcceptState(alt) */
                    }
                    else /* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA18_1 == 'P') ) 
                    {
                        alt18=2; /* dfaAcceptState(alt) */
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "862:1: SAID : ( 'SAID' | 'SPOKEN' );";
                        theException()->decisionNum  = 18;
                        theException()->state        = 1;

                    
                        goto ruleSAIDEx;
                    }
                }
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "862:1: SAID : ( 'SAID' | 'SPOKEN' );";
                theException()->decisionNum  = 18;
                theException()->state        = 0;

            
                goto ruleSAIDEx;
            }
        }
        switch (alt18) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:862:25: 'SAID'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_105); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:862:34: 'SPOKEN'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_106); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSAIDEx; /* Prevent compiler warnings */
    ruleSAIDEx: ;


}
// $ANTLR end SAID

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAMPLE
 *
 * Looks to match the chracters the constitute the token SAMPLE
 * from the attached input stream.
 *
 * Comes from: 863:19: ( 'SAMPLE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSAMPLE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = SAMPLE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:863:19: ( 'SAMPLE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:863:19: 'SAMPLE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_107); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSAMPLEEx; /* Prevent compiler warnings */
    ruleSAMPLEEx: ;


}
// $ANTLR end SAMPLE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAMPLED
 *
 * Looks to match the chracters the constitute the token SAMPLED
 * from the attached input stream.
 *
 * Comes from: 864:19: ( 'SAMPLED' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSAMPLED(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = SAMPLED;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:864:19: ( 'SAMPLED' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:864:19: 'SAMPLED'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_108); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSAMPLEDEx; /* Prevent compiler warnings */
    ruleSAMPLEDEx: ;


}
// $ANTLR end SAMPLED

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAVING
 *
 * Looks to match the chracters the constitute the token SAVING
 * from the attached input stream.
 *
 * Comes from: 865:25: ( 'SAVING' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSAVING(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = SAVING;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:865:25: ( 'SAVING' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:865:25: 'SAVING'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_109); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSAVINGEx; /* Prevent compiler warnings */
    ruleSAVINGEx: ;


}
// $ANTLR end SAVING

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SELECTLIST
 *
 * Looks to match the chracters the constitute the token SELECTLIST
 * from the attached input stream.
 *
 * Comes from: 866:25: ( 'selectlist' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSELECTLIST(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = SELECTLIST;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:866:25: ( 'selectlist' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:866:25: 'selectlist'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_110); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSELECTLISTEx; /* Prevent compiler warnings */
    ruleSELECTLISTEx: ;


}
// $ANTLR end SELECTLIST

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SINGLE_VALUE
 *
 * Looks to match the chracters the constitute the token SINGLE_VALUE
 * from the attached input stream.
 *
 * Comes from: 867:16: ( 'SINGLE.VALUE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSINGLE_VALUE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = SINGLE_VALUE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:867:16: ( 'SINGLE.VALUE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:867:16: 'SINGLE.VALUE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_111); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSINGLE_VALUEEx; /* Prevent compiler warnings */
    ruleSINGLE_VALUEEx: ;


}
// $ANTLR end SINGLE_VALUE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SORTED
 *
 * Looks to match the chracters the constitute the token SORTED
 * from the attached input stream.
 *
 * Comes from: 868:25: ( 'sorted' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSORTED(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = SORTED;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:868:25: ( 'sorted' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:868:25: 'sorted'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_112); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSORTEDEx; /* Prevent compiler warnings */
    ruleSORTEDEx: ;


}
// $ANTLR end SORTED

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STAT
 *
 * Looks to match the chracters the constitute the token STAT
 * from the attached input stream.
 *
 * Comes from: 869:9: ( 'STAT' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSTAT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = STAT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:869:9: ( 'STAT' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:869:9: 'STAT'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_113); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSTATEx; /* Prevent compiler warnings */
    ruleSTATEx: ;


}
// $ANTLR end STAT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STORAGE
 *
 * Looks to match the chracters the constitute the token STORAGE
 * from the attached input stream.
 *
 * Comes from: 870:25: ( 'storage' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSTORAGE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = STORAGE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:870:25: ( 'storage' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:870:25: 'storage'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_114); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSTORAGEEx; /* Prevent compiler warnings */
    ruleSTORAGEEx: ;


}
// $ANTLR end STORAGE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SUM
 *
 * Looks to match the chracters the constitute the token SUM
 * from the attached input stream.
 *
 * Comes from: 871:8: ( 'SUM' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mSUM(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = SUM;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:871:8: ( 'SUM' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:871:8: 'SUM'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_115); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleSUMEx; /* Prevent compiler warnings */
    ruleSUMEx: ;


}
// $ANTLR end SUM

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TERMINAL
 *
 * Looks to match the chracters the constitute the token TERMINAL
 * from the attached input stream.
 *
 * Comes from: 872:25: ( 'TERMINAL' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mTERMINAL(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = TERMINAL;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:872:25: ( 'TERMINAL' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:872:25: 'TERMINAL'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_116); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleTERMINALEx; /* Prevent compiler warnings */
    ruleTERMINALEx: ;


}
// $ANTLR end TERMINAL

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TO
 *
 * Looks to match the chracters the constitute the token TO
 * from the attached input stream.
 *
 * Comes from: 873:25: ( 'TO' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mTO(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = TO;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:873:25: ( 'TO' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:873:25: 'TO'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_117); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleTOEx; /* Prevent compiler warnings */
    ruleTOEx: ;


}
// $ANTLR end TO

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TOTAL
 *
 * Looks to match the chracters the constitute the token TOTAL
 * from the attached input stream.
 *
 * Comes from: 874:25: ( 'TOTAL' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mTOTAL(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = TOTAL;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:874:25: ( 'TOTAL' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:874:25: 'TOTAL'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_118); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleTOTALEx; /* Prevent compiler warnings */
    ruleTOTALEx: ;


}
// $ANTLR end TOTAL

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TRANSPORT
 *
 * Looks to match the chracters the constitute the token TRANSPORT
 * from the attached input stream.
 *
 * Comes from: 875:25: ( 'TRANSPORT' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mTRANSPORT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = TRANSPORT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:875:25: ( 'TRANSPORT' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:875:25: 'TRANSPORT'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_119); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleTRANSPORTEx; /* Prevent compiler warnings */
    ruleTRANSPORTEx: ;


}
// $ANTLR end TRANSPORT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BTRUE
 *
 * Looks to match the chracters the constitute the token BTRUE
 * from the attached input stream.
 *
 * Comes from: 876:26: ( 'true' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mBTRUE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = BTRUE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:876:26: ( 'true' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:876:26: 'true'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_120); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleBTRUEEx; /* Prevent compiler warnings */
    ruleBTRUEEx: ;


}
// $ANTLR end BTRUE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TYPE
 *
 * Looks to match the chracters the constitute the token TYPE
 * from the attached input stream.
 *
 * Comes from: 877:19: ( 'type' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mTYPE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = TYPE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:877:19: ( 'type' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:877:19: 'type'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_121); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleTYPEEx; /* Prevent compiler warnings */
    ruleTYPEEx: ;


}
// $ANTLR end TYPE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNIQUE
 *
 * Looks to match the chracters the constitute the token UNIQUE
 * from the attached input stream.
 *
 * Comes from: 878:25: ( 'UNIQUE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mUNIQUE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = UNIQUE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:878:25: ( 'UNIQUE' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:878:25: 'UNIQUE'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_122); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleUNIQUEEx; /* Prevent compiler warnings */
    ruleUNIQUEEx: ;


}
// $ANTLR end UNIQUE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNLIKE
 *
 * Looks to match the chracters the constitute the token UNLIKE
 * from the attached input stream.
 *
 * Comes from: 879:25: ( 'UNLIKE' | 'NOT.MATCHING' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mUNLIKE(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = UNLIKE;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:879:25: ( 'UNLIKE' | 'NOT.MATCHING' )
        */
        ANTLR3_UINT32 alt19;
    
        alt19=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA19_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA19_0 == 'U') ) 
            {
                alt19=1; /* dfaAcceptState(alt) */
            }
            else /* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA19_0 == 'N') ) 
            {
                alt19=2; /* dfaAcceptState(alt) */
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "879:1: UNLIKE : ( 'UNLIKE' | 'NOT.MATCHING' );";
                theException()->decisionNum  = 19;
                theException()->state        = 0;

            
                goto ruleUNLIKEEx;
            }
        }
        switch (alt19) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:879:25: 'UNLIKE'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_123); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:879:36: 'NOT.MATCHING'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_124); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleUNLIKEEx; /* Prevent compiler warnings */
    ruleUNLIKEEx: ;


}
// $ANTLR end UNLIKE

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UQS
 *
 * Looks to match the chracters the constitute the token UQS
 * from the attached input stream.
 *
 * Comes from: 880:25: ( 'UQS' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mUQS(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = UQS;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:880:25: ( 'UQS' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:880:25: 'UQS'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_125); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleUQSEx; /* Prevent compiler warnings */
    ruleUQSEx: ;


}
// $ANTLR end UQS

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VERT
 *
 * Looks to match the chracters the constitute the token VERT
 * from the attached input stream.
 *
 * Comes from: 881:19: ( 'VERT' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mVERT(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = VERT;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:881:19: ( 'VERT' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:881:19: 'VERT'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_126); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleVERTEx; /* Prevent compiler warnings */
    ruleVERTEx: ;


}
// $ANTLR end VERT

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHEN
 *
 * Looks to match the chracters the constitute the token WHEN
 * from the attached input stream.
 *
 * Comes from: 882:25: ( 'WHEN' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mWHEN(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = WHEN;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:882:25: ( 'WHEN' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:882:25: 'WHEN'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_127); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleWHENEx; /* Prevent compiler warnings */
    ruleWHENEx: ;


}
// $ANTLR end WHEN

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WIDTH
 *
 * Looks to match the chracters the constitute the token WIDTH
 * from the attached input stream.
 *
 * Comes from: 883:25: ( 'width' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mWIDTH(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = WIDTH;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:883:25: ( 'width' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:883:25: 'width'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_128); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleWIDTHEx; /* Prevent compiler warnings */
    ruleWIDTHEx: ;


}
// $ANTLR end WIDTH

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WITH
 *
 * Looks to match the chracters the constitute the token WITH
 * from the attached input stream.
 *
 * Comes from: 884:25: ( 'WITH' | 'WHERE' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mWITH(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = WITH;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:884:25: ( 'WITH' | 'WHERE' )
        */
        ANTLR3_UINT32 alt20;
    
        alt20=2;
    
        
        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
         */
        {
            int LA20_0 = LA(1);/* dfaEdge(labelExpr, targetState, predicates)
             */
            if ( (LA20_0 == 'W') ) 
            {
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA20_1 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA20_1 == 'I') ) 
                    {
                        alt20=1; /* dfaAcceptState(alt) */
                    }
                    else /* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA20_1 == 'H') ) 
                    {
                        alt20=2; /* dfaAcceptState(alt) */
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "884:1: WITH : ( 'WITH' | 'WHERE' );";
                        theException()->decisionNum  = 20;
                        theException()->state        = 1;

                    
                        goto ruleWITHEx;
                    }
                }
            }
            else 
            {
            
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "884:1: WITH : ( 'WITH' | 'WHERE' );";
                theException()->decisionNum  = 20;
                theException()->state        = 0;

            
                goto ruleWITHEx;
            }
        }
        switch (alt20) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:884:25: 'WITH'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_5); 

    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:884:34: 'WHERE'
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerStringRef(string,label)
    	         */
    	        matchs(lit_129); 

    	    
    	    }
    	    break;
    
        }
    }

    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleWITHEx; /* Prevent compiler warnings */
    ruleWITHEx: ;


}
// $ANTLR end WITH

/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WITHIN
 *
 * Looks to match the chracters the constitute the token WITHIN
 * from the attached input stream.
 *
 * Comes from: 885:19: ( 'WITHIN' )
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void mWITHIN(pcmqlLexer ctx)
{

    /* ruleDeclarations()
     */


    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = WITHIN;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    
    /* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:885:19: ( 'WITHIN' )
     */
    /* alt(elements,altNum,description,autoAST,outerAlt)
     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:885:19: 'WITHIN'
     */
    {
        /* element()
         */
        /* lexerStringRef(string,label)
         */
        matchs(lit_130); 

    
    }


    /* execAction(action)
     */
         
        if ( ltoken() == NULL && !hasException()) 
        {
    		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
        }
    
            ctx->pLexer->ruleNestingLevel--;
    /* ruleCleanUp()
     */
    goto ruleWITHINEx; /* Prevent compiler warnings */
    ruleWITHINEx: ;


}
// $ANTLR end WITHIN

/* tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor)
 */
/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pcmqlLexer ctx)
{
    {
        /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
        *
        * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:10: ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN )
        */
        ANTLR3_UINT32 alt21;
    
        alt21=132;
    
        /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
         */
        switch ( LA(1) ) 
        {
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case ' ':
            alt21=1; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '"':
            alt21=2; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '\'':
            alt21=3; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '_':
            alt21=4; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '{':
            alt21=5; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '}':
            alt21=6; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case ';':
            alt21=7; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '(':
            alt21=8; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case ')':
            alt21=9; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case ',':
            alt21=10; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '$':
            alt21=11; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            alt21=12; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '@':
            alt21=13; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'A':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'S':
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA21_54 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_54 == 'S') ) 
                    {
                        
                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                         */
                        {
                            int LA21_125 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_125 == 'O') ) 
                            {
                                
                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                 */
                                {
                                    int LA21_167 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                     */
                                    if ( (LA21_167 == 'C') ) 
                                    {
                                        
                                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                         */
                                        {
                                            int LA21_188 = LA(6);/* dfaEdge(labelExpr, targetState, predicates)
                                             */
                                            if ( (LA21_188 == 'W') ) 
                                            {
                                                alt21=17; /* dfaAcceptState(alt) */
                                            }
                                            else 
                                            {
                                                alt21=16;    }
                                        }
                                    }
                                    else 
                                    {
                                    
                                        /* newNVException()
                                         */
                                        exConstruct();
                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                        theException()->decisionNum  = 21;
                                        theException()->state        = 167;

                                    
                                        goto ruleTokensEx;
                                    }
                                }
                            }
                            else 
                            {
                            
                                /* newNVException()
                                 */
                                exConstruct();
                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                theException()->decisionNum  = 21;
                                theException()->state        = 125;

                            
                                goto ruleTokensEx;
                            }
                        }
                    }
                    else 
                    {
                        alt21=15;    }
                }
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'N':
                alt21=14; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'F':
                alt21=64; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'T':
                alt21=18; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'V':
                alt21=21; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 14;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'a':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_15 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_15 == 't') ) 
                {
                    
                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                     */
                    {
                        int LA21_59 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_59 == 't') ) 
                        {
                            
                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                             */
                            {
                                int LA21_127 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                                 */
                                if ( (LA21_127 == 'r') ) 
                                {
                                    
                                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                     */
                                    {
                                        int LA21_168 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                         */
                                        if ( (LA21_168 == 'n') ) 
                                        {
                                            alt21=20; /* dfaAcceptState(alt) */
                                        }
                                        else /* dfaEdge(labelExpr, targetState, predicates)
                                         */
                                        if ( (LA21_168 == '8') ) 
                                        {
                                            alt21=19; /* dfaAcceptState(alt) */
                                        }
                                        else 
                                        {
                                        
                                            /* newNVException()
                                             */
                                            exConstruct();
                                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                            theException()->decisionNum  = 21;
                                            theException()->state        = 168;

                                        
                                            goto ruleTokensEx;
                                        }
                                    }
                                }
                                else 
                                {
                                
                                    /* newNVException()
                                     */
                                    exConstruct();
                                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                    theException()->decisionNum  = 21;
                                    theException()->state        = 127;

                                
                                    goto ruleTokensEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            /* newNVException()
                             */
                            exConstruct();
                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                            theException()->decisionNum  = 21;
                            theException()->state        = 59;

                        
                            goto ruleTokensEx;
                        }
                    }
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_15 == 's') ) 
                {
                    alt21=16; /* dfaAcceptState(alt) */
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 15;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'b':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_16 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_16 == 'i') ) 
                {
                    
                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                     */
                    {
                        int LA21_61 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_61 == 't') ) 
                        {
                            
                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                             */
                            {
                                int LA21_128 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                                 */
                                if ( (LA21_128 == 'm') ) 
                                {
                                    alt21=22; /* dfaAcceptState(alt) */
                                }
                                else /* dfaEdge(labelExpr, targetState, predicates)
                                 */
                                if ( (LA21_128 == 's') ) 
                                {
                                    alt21=23; /* dfaAcceptState(alt) */
                                }
                                else 
                                {
                                
                                    /* newNVException()
                                     */
                                    exConstruct();
                                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                    theException()->decisionNum  = 21;
                                    theException()->state        = 128;

                                
                                    goto ruleTokensEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            /* newNVException()
                             */
                            exConstruct();
                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                            theException()->decisionNum  = 21;
                            theException()->state        = 61;

                        
                            goto ruleTokensEx;
                        }
                    }
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_16 == 'o') ) 
                {
                    alt21=25; /* dfaAcceptState(alt) */
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 16;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'B':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'Y':
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA21_63 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_63 == '.') ) 
                    {
                        
                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                         */
                        {
                            int LA21_129 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_129 == 'D') ) 
                            {
                                alt21=29; /* dfaAcceptState(alt) */
                            }
                            else /* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_129 == 'E') ) 
                            {
                                
                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                 */
                                {
                                    int LA21_172 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                     */
                                    if ( (LA21_172 == 'X') ) 
                                    {
                                        
                                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                         */
                                        {
                                            int LA21_191 = LA(6);/* dfaEdge(labelExpr, targetState, predicates)
                                             */
                                            if ( (LA21_191 == 'P') ) 
                                            {
                                                
                                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                 */
                                                {
                                                    int LA21_204 = LA(7);/* dfaEdge(labelExpr, targetState, predicates)
                                                     */
                                                    if ( (LA21_204 == '.') ) 
                                                    {
                                                        
                                                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                         */
                                                        {
                                                            int LA21_213 = LA(8);/* dfaEdge(labelExpr, targetState, predicates)
                                                             */
                                                            if ( (LA21_213 == 'S') ) 
                                                            {
                                                                
                                                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                                 */
                                                                {
                                                                    int LA21_222 = LA(9);/* dfaEdge(labelExpr, targetState, predicates)
                                                                     */
                                                                    if ( (LA21_222 == 'U') ) 
                                                                    {
                                                                        
                                                                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                                         */
                                                                        {
                                                                            int LA21_225 = LA(10);/* dfaEdge(labelExpr, targetState, predicates)
                                                                             */
                                                                            if ( (LA21_225 == 'B') ) 
                                                                            {
                                                                                
                                                                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                                                 */
                                                                                {
                                                                                    int LA21_228 = LA(11);/* dfaEdge(labelExpr, targetState, predicates)
                                                                                     */
                                                                                    if ( (LA21_228 == '.') ) 
                                                                                    {
                                                                                        alt21=33; /* dfaAcceptState(alt) */
                                                                                    }
                                                                                    else 
                                                                                    {
                                                                                        alt21=32;    }
                                                                                }
                                                                            }
                                                                            else 
                                                                            {
                                                                            
                                                                                /* newNVException()
                                                                                 */
                                                                                exConstruct();
                                                                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                                                theException()->decisionNum  = 21;
                                                                                theException()->state        = 225;

                                                                            
                                                                                goto ruleTokensEx;
                                                                            }
                                                                        }
                                                                    }
                                                                    else 
                                                                    {
                                                                    
                                                                        /* newNVException()
                                                                         */
                                                                        exConstruct();
                                                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                                        theException()->decisionNum  = 21;
                                                                        theException()->state        = 222;

                                                                    
                                                                        goto ruleTokensEx;
                                                                    }
                                                                }
                                                            }
                                                            else /* dfaEdge(labelExpr, targetState, predicates)
                                                             */
                                                            if ( (LA21_213 == 'D') ) 
                                                            {
                                                                alt21=31; /* dfaAcceptState(alt) */
                                                            }
                                                            else 
                                                            {
                                                            
                                                                /* newNVException()
                                                                 */
                                                                exConstruct();
                                                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                                theException()->decisionNum  = 21;
                                                                theException()->state        = 213;

                                                            
                                                                goto ruleTokensEx;
                                                            }
                                                        }
                                                    }
                                                    else 
                                                    {
                                                        alt21=30;    }
                                                }
                                            }
                                            else 
                                            {
                                            
                                                /* newNVException()
                                                 */
                                                exConstruct();
                                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                theException()->decisionNum  = 21;
                                                theException()->state        = 191;

                                            
                                                goto ruleTokensEx;
                                            }
                                        }
                                    }
                                    else 
                                    {
                                    
                                        /* newNVException()
                                         */
                                        exConstruct();
                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                        theException()->decisionNum  = 21;
                                        theException()->state        = 172;

                                    
                                        goto ruleTokensEx;
                                    }
                                }
                            }
                            else 
                            {
                            
                                /* newNVException()
                                 */
                                exConstruct();
                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                theException()->decisionNum  = 21;
                                theException()->state        = 129;

                            
                                goto ruleTokensEx;
                            }
                        }
                    }
                    else 
                    {
                        alt21=28;    }
                }
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'R':
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA21_64 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_64 == 'E') ) 
                    {
                        
                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                         */
                        {
                            int LA21_131 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_131 == 'A') ) 
                            {
                                
                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                 */
                                {
                                    int LA21_173 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                     */
                                    if ( (LA21_173 == 'K') ) 
                                    {
                                        
                                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                         */
                                        {
                                            int LA21_192 = LA(6);/* dfaEdge(labelExpr, targetState, predicates)
                                             */
                                            if ( (LA21_192 == '.') ) 
                                            {
                                                
                                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                 */
                                                {
                                                    int LA21_205 = LA(7);/* dfaEdge(labelExpr, targetState, predicates)
                                                     */
                                                    if ( (LA21_205 == 'O') ) 
                                                    {
                                                        alt21=26; /* dfaAcceptState(alt) */
                                                    }
                                                    else /* dfaEdge(labelExpr, targetState, predicates)
                                                     */
                                                    if ( (LA21_205 == 'S') ) 
                                                    {
                                                        alt21=27; /* dfaAcceptState(alt) */
                                                    }
                                                    else 
                                                    {
                                                    
                                                        /* newNVException()
                                                         */
                                                        exConstruct();
                                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                        theException()->decisionNum  = 21;
                                                        theException()->state        = 205;

                                                    
                                                        goto ruleTokensEx;
                                                    }
                                                }
                                            }
                                            else 
                                            {
                                            
                                                /* newNVException()
                                                 */
                                                exConstruct();
                                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                theException()->decisionNum  = 21;
                                                theException()->state        = 192;

                                            
                                                goto ruleTokensEx;
                                            }
                                        }
                                    }
                                    else 
                                    {
                                    
                                        /* newNVException()
                                         */
                                        exConstruct();
                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                        theException()->decisionNum  = 21;
                                        theException()->state        = 173;

                                    
                                        goto ruleTokensEx;
                                    }
                                }
                            }
                            else 
                            {
                            
                                /* newNVException()
                                 */
                                exConstruct();
                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                theException()->decisionNum  = 21;
                                theException()->state        = 131;

                            
                                goto ruleTokensEx;
                            }
                        }
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                        theException()->decisionNum  = 21;
                        theException()->state        = 64;

                    
                        goto ruleTokensEx;
                    }
                }
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'E':
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA21_65 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_65 == 'F') ) 
                    {
                        alt21=82; /* dfaAcceptState(alt) */
                    }
                    else /* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_65 == 'T') ) 
                    {
                        alt21=24; /* dfaAcceptState(alt) */
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                        theException()->decisionNum  = 21;
                        theException()->state        = 65;

                    
                        goto ruleTokensEx;
                    }
                }
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 17;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'C':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_18 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_18 == 'O') ) 
                {
                    /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                     */
                    switch ( LA(3) ) 
                    {
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case 'L':
                        
                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                         */
                        {
                            int LA21_133 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_133 == '.') ) 
                            {
                                
                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                 */
                                {
                                    int LA21_174 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                     */
                                    if ( (LA21_174 == 'H') ) 
                                    {
                                        
                                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                         */
                                        {
                                            int LA21_193 = LA(6);/* dfaEdge(labelExpr, targetState, predicates)
                                             */
                                            if ( (LA21_193 == 'D') ) 
                                            {
                                                
                                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                 */
                                                {
                                                    int LA21_206 = LA(7);/* dfaEdge(labelExpr, targetState, predicates)
                                                     */
                                                    if ( (LA21_206 == 'G') ) 
                                                    {
                                                        alt21=34; /* dfaAcceptState(alt) */
                                                    }
                                                    else /* dfaEdge(labelExpr, targetState, predicates)
                                                     */
                                                    if ( (LA21_206 == 'R') ) 
                                                    {
                                                        alt21=36; /* dfaAcceptState(alt) */
                                                    }
                                                    else 
                                                    {
                                                    
                                                        /* newNVException()
                                                         */
                                                        exConstruct();
                                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                        theException()->decisionNum  = 21;
                                                        theException()->state        = 206;

                                                    
                                                        goto ruleTokensEx;
                                                    }
                                                }
                                            }
                                            else 
                                            {
                                            
                                                /* newNVException()
                                                 */
                                                exConstruct();
                                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                theException()->decisionNum  = 21;
                                                theException()->state        = 193;

                                            
                                                goto ruleTokensEx;
                                            }
                                        }
                                    }
                                    else /* dfaEdge(labelExpr, targetState, predicates)
                                     */
                                    if ( (LA21_174 == 'S') ) 
                                    {
                                        
                                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                         */
                                        {
                                            int LA21_194 = LA(6);/* dfaEdge(labelExpr, targetState, predicates)
                                             */
                                            if ( (LA21_194 == 'U') ) 
                                            {
                                                alt21=38; /* dfaAcceptState(alt) */
                                            }
                                            else /* dfaEdge(labelExpr, targetState, predicates)
                                             */
                                            if ( (LA21_194 == 'P') ) 
                                            {
                                                alt21=37; /* dfaAcceptState(alt) */
                                            }
                                            else 
                                            {
                                            
                                                /* newNVException()
                                                 */
                                                exConstruct();
                                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                theException()->decisionNum  = 21;
                                                theException()->state        = 194;

                                            
                                                goto ruleTokensEx;
                                            }
                                        }
                                    }
                                    else 
                                    {
                                    
                                        /* newNVException()
                                         */
                                        exConstruct();
                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                        theException()->decisionNum  = 21;
                                        theException()->state        = 174;

                                    
                                        goto ruleTokensEx;
                                    }
                                }
                            }
                            else 
                            {
                            
                                /* newNVException()
                                 */
                                exConstruct();
                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                theException()->decisionNum  = 21;
                                theException()->state        = 133;

                            
                                goto ruleTokensEx;
                            }
                        }
                        break;
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case 'U':
                        alt21=43; /* dfaAcceptState(alt) */
                        break;
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case 'N':
                        alt21=42; /* dfaAcceptState(alt) */
                        break;
                    
                    default:
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                        theException()->decisionNum  = 21;
                        theException()->state        = 66;

                    
                        goto ruleTokensEx;
                    }
                
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_18 == 'A') ) 
                {
                    alt21=35; /* dfaAcceptState(alt) */
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 18;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'c':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_19 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_19 == 'o') ) 
                {
                    /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                     */
                    switch ( LA(3) ) 
                    {
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case 'm':
                        alt21=41; /* dfaAcceptState(alt) */
                        break;
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case 'l':
                        
                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                         */
                        {
                            int LA21_137 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_137 == 'n') ) 
                            {
                                alt21=39; /* dfaAcceptState(alt) */
                            }
                            else /* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_137 == 'l') ) 
                            {
                                alt21=40; /* dfaAcceptState(alt) */
                            }
                            else 
                            {
                            
                                /* newNVException()
                                 */
                                exConstruct();
                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                theException()->decisionNum  = 21;
                                theException()->state        = 137;

                            
                                goto ruleTokensEx;
                            }
                        }
                        break;
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case 'n':
                        alt21=42; /* dfaAcceptState(alt) */
                        break;
                    
                    default:
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                        theException()->decisionNum  = 21;
                        theException()->state        = 68;

                    
                        goto ruleTokensEx;
                    }
                
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 19;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'D':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'B':
                alt21=45; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'I':
                alt21=48; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'E':
                alt21=46; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'A':
                alt21=44; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 20;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'd':
            alt21=47; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'E':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'A':
                alt21=49; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'Q':
                alt21=52; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'V':
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA21_74 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_74 == 'A') ) 
                    {
                        alt21=53; /* dfaAcceptState(alt) */
                    }
                    else /* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_74 == 'E') ) 
                    {
                        alt21=49; /* dfaAcceptState(alt) */
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                        theException()->decisionNum  = 21;
                        theException()->state        = 74;

                    
                        goto ruleTokensEx;
                    }
                }
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'N':
                alt21=51; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 22;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'e':
            alt21=50; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case '=':
            alt21=52; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'f':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'o':
                alt21=59; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'a':
                alt21=54; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'i':
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA21_78 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_78 == 'l') ) 
                    {
                        
                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                         */
                        {
                            int LA21_139 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_139 == 'e') ) 
                            {
                                
                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                 */
                                {
                                    int LA21_177 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                     */
                                    if ( (LA21_177 == 't') ) 
                                    {
                                        alt21=56; /* dfaAcceptState(alt) */
                                    }
                                    else /* dfaEdge(labelExpr, targetState, predicates)
                                     */
                                    if ( (LA21_177 == 'n') ) 
                                    {
                                        alt21=55; /* dfaAcceptState(alt) */
                                    }
                                    else 
                                    {
                                    
                                        /* newNVException()
                                         */
                                        exConstruct();
                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                        theException()->decisionNum  = 21;
                                        theException()->state        = 177;

                                    
                                        goto ruleTokensEx;
                                    }
                                }
                            }
                            else 
                            {
                            
                                /* newNVException()
                                 */
                                exConstruct();
                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                theException()->decisionNum  = 21;
                                theException()->state        = 139;

                            
                                goto ruleTokensEx;
                            }
                        }
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                        theException()->decisionNum  = 21;
                        theException()->state        = 78;

                    
                        goto ruleTokensEx;
                    }
                }
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 25;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'F':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'M':
                alt21=57; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'R':
                alt21=60; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'O':
                alt21=58; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 26;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'G':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'R':
                alt21=63; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'E':
                alt21=61; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'T':
                alt21=64; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 27;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'g':
            alt21=62; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'H':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_29 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_29 == 'D') ) 
                {
                    alt21=65; /* dfaAcceptState(alt) */
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_29 == 'E') ) 
                {
                    alt21=66; /* dfaAcceptState(alt) */
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 29;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'h':
            alt21=66; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'I':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'D':
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA21_85 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_85 == '.') ) 
                    {
                        alt21=67; /* dfaAcceptState(alt) */
                    }
                    else /* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_85 == 'L') ) 
                    {
                        alt21=68; /* dfaAcceptState(alt) */
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                        theException()->decisionNum  = 21;
                        theException()->state        = 85;

                    
                        goto ruleTokensEx;
                    }
                }
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'T':
                alt21=77; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'S':
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA21_87 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_87 == '.') ) 
                    {
                        
                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                         */
                        {
                            int LA21_142 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_142 == 'N') ) 
                            {
                                
                                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                 */
                                {
                                    int LA21_178 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                     */
                                    if ( (LA21_178 == 'O') ) 
                                    {
                                        alt21=74; /* dfaAcceptState(alt) */
                                    }
                                    else /* dfaEdge(labelExpr, targetState, predicates)
                                     */
                                    if ( (LA21_178 == 'U') ) 
                                    {
                                        alt21=73; /* dfaAcceptState(alt) */
                                    }
                                    else 
                                    {
                                    
                                        /* newNVException()
                                         */
                                        exConstruct();
                                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                        theException()->decisionNum  = 21;
                                        theException()->state        = 178;

                                    
                                        goto ruleTokensEx;
                                    }
                                }
                            }
                            else 
                            {
                            
                                /* newNVException()
                                 */
                                exConstruct();
                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                theException()->decisionNum  = 21;
                                theException()->state        = 142;

                            
                                goto ruleTokensEx;
                            }
                        }
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                        theException()->decisionNum  = 21;
                        theException()->state        = 87;

                    
                        goto ruleTokensEx;
                    }
                }
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'N':
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA21_88 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_88 == 'Q') ) 
                    {
                        alt21=69; /* dfaAcceptState(alt) */
                    }
                    else /* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_88 == 'T') ) 
                    {
                        alt21=72; /* dfaAcceptState(alt) */
                    }
                    else 
                    {
                    
                        /* newNVException()
                         */
                        exConstruct();
                        theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                        theException()->decisionNum  = 21;
                        theException()->state        = 88;

                    
                        goto ruleTokensEx;
                    }
                }
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 31;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'i':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_32 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_32 == 't') ) 
                {
                    alt21=76; /* dfaAcceptState(alt) */
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_32 == 'n') ) 
                {
                    
                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                     */
                    {
                        int LA21_90 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_90 == 'd') ) 
                        {
                            
                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                             */
                            {
                                int LA21_145 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                                 */
                                if ( (LA21_145 == 'e') ) 
                                {
                                    
                                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                     */
                                    {
                                        int LA21_179 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                         */
                                        if ( (LA21_179 == 'x') ) 
                                        {
                                            
                                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                             */
                                            {
                                                int LA21_199 = LA(6);/* dfaEdge(labelExpr, targetState, predicates)
                                                 */
                                                if ( (LA21_199 == 'e') ) 
                                                {
                                                    alt21=71; /* dfaAcceptState(alt) */
                                                }
                                                else 
                                                {
                                                    alt21=70;    }
                                            }
                                        }
                                        else 
                                        {
                                        
                                            /* newNVException()
                                             */
                                            exConstruct();
                                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                            theException()->decisionNum  = 21;
                                            theException()->state        = 179;

                                        
                                            goto ruleTokensEx;
                                        }
                                    }
                                }
                                else 
                                {
                                
                                    /* newNVException()
                                     */
                                    exConstruct();
                                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                    theException()->decisionNum  = 21;
                                    theException()->state        = 145;

                                
                                    goto ruleTokensEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            /* newNVException()
                             */
                            exConstruct();
                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                            theException()->decisionNum  = 21;
                            theException()->state        = 90;

                        
                            goto ruleTokensEx;
                        }
                    }
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 32;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'o':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'p':
                alt21=98; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'u':
                alt21=100; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'r':
                alt21=75; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 33;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'j':
            alt21=78; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'L':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'T':
                alt21=82; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'P':
                alt21=81; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'E':
                alt21=79; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'I':
                alt21=80; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 35;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'M':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'A':
                /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                 */
                switch ( LA(3) ) 
                {
                /* dfaEdgeSwitch(labels, targetState)
                 */
                case 'T':
                    alt21=80; /* dfaAcceptState(alt) */
                    break;
                /* dfaEdgeSwitch(labels, targetState)
                 */
                case 'X':
                    alt21=84; /* dfaAcceptState(alt) */
                    break;
                /* dfaEdgeSwitch(labels, targetState)
                 */
                case 'R':
                    alt21=83; /* dfaAcceptState(alt) */
                    break;
                
                default:
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 98;

                
                    goto ruleTokensEx;
                }
            
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'I':
                alt21=85; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'U':
                alt21=86; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 36;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'm':
            alt21=87; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'n':
            alt21=88; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'N':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_39 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_39 == 'O') ) 
                {
                    /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                     */
                    switch ( LA(3) ) 
                    {
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case 'T':
                        
                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                         */
                        {
                            int LA21_148 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_148 == '.') ) 
                            {
                                alt21=126; /* dfaAcceptState(alt) */
                            }
                            else 
                            {
                                alt21=96;    }
                        }
                        break;
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case 'S':
                        alt21=95; /* dfaAcceptState(alt) */
                        break;
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case 'P':
                        alt21=94; /* dfaAcceptState(alt) */
                        break;
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case '.':
                        
                        /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                         */
                        {
                            int LA21_151 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_151 == 'I') ) 
                            {
                                alt21=92; /* dfaAcceptState(alt) */
                            }
                            else /* dfaEdge(labelExpr, targetState, predicates)
                             */
                            if ( (LA21_151 == 'N') ) 
                            {
                                alt21=93; /* dfaAcceptState(alt) */
                            }
                            else 
                            {
                            
                                /* newNVException()
                                 */
                                exConstruct();
                                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                theException()->decisionNum  = 21;
                                theException()->state        = 151;

                            
                                goto ruleTokensEx;
                            }
                        }
                        break;
                    /* dfaEdgeSwitch(labels, targetState)
                     */
                    case 'D':
                        alt21=91; /* dfaAcceptState(alt) */
                        break;
                    
                    default:
                        alt21=90;}
                
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_39 == 'E') ) 
                {
                    alt21=89; /* dfaAcceptState(alt) */
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 39;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'O':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_40 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_40 == 'N') ) 
                {
                    alt21=97; /* dfaAcceptState(alt) */
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_40 == 'R') ) 
                {
                    alt21=99; /* dfaAcceptState(alt) */
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 40;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'P':
            alt21=101; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'p':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_42 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_42 == 'r') ) 
                {
                    
                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                     */
                    {
                        int LA21_105 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_105 == 'i') ) 
                        {
                            alt21=102; /* dfaAcceptState(alt) */
                        }
                        else /* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_105 == 'o') ) 
                        {
                            alt21=103; /* dfaAcceptState(alt) */
                        }
                        else 
                        {
                        
                            /* newNVException()
                             */
                            exConstruct();
                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                            theException()->decisionNum  = 21;
                            theException()->state        = 105;

                        
                            goto ruleTokensEx;
                        }
                    }
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 42;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'q':
            alt21=104; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'r':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_44 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_44 == 'e') ) 
                {
                    
                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                     */
                    {
                        int LA21_106 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_106 == 'g') ) 
                        {
                            alt21=106; /* dfaAcceptState(alt) */
                        }
                        else /* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_106 == 'f') ) 
                        {
                            alt21=105; /* dfaAcceptState(alt) */
                        }
                        else 
                        {
                        
                            /* newNVException()
                             */
                            exConstruct();
                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                            theException()->decisionNum  = 21;
                            theException()->state        = 106;

                        
                            goto ruleTokensEx;
                        }
                    }
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 44;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'R':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_45 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_45 == 'E') ) 
                {
                    
                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                     */
                    {
                        int LA21_107 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_107 == 'Q') ) 
                        {
                            
                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                             */
                            {
                                int LA21_158 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                                 */
                                if ( (LA21_158 == 'U') ) 
                                {
                                    
                                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                     */
                                    {
                                        int LA21_183 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                         */
                                        if ( (LA21_183 == 'I') ) 
                                        {
                                            
                                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                             */
                                            {
                                                int LA21_200 = LA(6);/* dfaEdge(labelExpr, targetState, predicates)
                                                 */
                                                if ( (LA21_200 == 'R') ) 
                                                {
                                                    
                                                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                     */
                                                    {
                                                        int LA21_211 = LA(7);/* dfaEdge(labelExpr, targetState, predicates)
                                                         */
                                                        if ( (LA21_211 == 'E') ) 
                                                        {
                                                            
                                                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                             */
                                                            {
                                                                int LA21_219 = LA(8);/* dfaEdge(labelExpr, targetState, predicates)
                                                                 */
                                                                if ( (LA21_219 == '.') ) 
                                                                {
                                                                    
                                                                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                                                     */
                                                                    {
                                                                        int LA21_224 = LA(9);/* dfaEdge(labelExpr, targetState, predicates)
                                                                         */
                                                                        if ( (LA21_224 == 'I') ) 
                                                                        {
                                                                            alt21=107; /* dfaAcceptState(alt) */
                                                                        }
                                                                        else /* dfaEdge(labelExpr, targetState, predicates)
                                                                         */
                                                                        if ( (LA21_224 == 'S') ) 
                                                                        {
                                                                            alt21=108; /* dfaAcceptState(alt) */
                                                                        }
                                                                        else 
                                                                        {
                                                                        
                                                                            /* newNVException()
                                                                             */
                                                                            exConstruct();
                                                                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                                            theException()->decisionNum  = 21;
                                                                            theException()->state        = 224;

                                                                        
                                                                            goto ruleTokensEx;
                                                                        }
                                                                    }
                                                                }
                                                                else 
                                                                {
                                                                
                                                                    /* newNVException()
                                                                     */
                                                                    exConstruct();
                                                                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                                    theException()->decisionNum  = 21;
                                                                    theException()->state        = 219;

                                                                
                                                                    goto ruleTokensEx;
                                                                }
                                                            }
                                                        }
                                                        else 
                                                        {
                                                        
                                                            /* newNVException()
                                                             */
                                                            exConstruct();
                                                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                            theException()->decisionNum  = 21;
                                                            theException()->state        = 211;

                                                        
                                                            goto ruleTokensEx;
                                                        }
                                                    }
                                                }
                                                else 
                                                {
                                                
                                                    /* newNVException()
                                                     */
                                                    exConstruct();
                                                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                                    theException()->decisionNum  = 21;
                                                    theException()->state        = 200;

                                                
                                                    goto ruleTokensEx;
                                                }
                                            }
                                        }
                                        else 
                                        {
                                        
                                            /* newNVException()
                                             */
                                            exConstruct();
                                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                            theException()->decisionNum  = 21;
                                            theException()->state        = 183;

                                        
                                            goto ruleTokensEx;
                                        }
                                    }
                                }
                                else 
                                {
                                
                                    /* newNVException()
                                     */
                                    exConstruct();
                                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                    theException()->decisionNum  = 21;
                                    theException()->state        = 158;

                                
                                    goto ruleTokensEx;
                                }
                            }
                        }
                        else /* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_107 == 'G') ) 
                        {
                            alt21=106; /* dfaAcceptState(alt) */
                        }
                        else 
                        {
                        
                            /* newNVException()
                             */
                            exConstruct();
                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                            theException()->decisionNum  = 21;
                            theException()->state        = 107;

                        
                            goto ruleTokensEx;
                        }
                    }
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 45;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'S':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'A':
                /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                 */
                switch ( LA(3) ) 
                {
                /* dfaEdgeSwitch(labels, targetState)
                 */
                case 'V':
                    alt21=112; /* dfaAcceptState(alt) */
                    break;
                /* dfaEdgeSwitch(labels, targetState)
                 */
                case 'I':
                    alt21=109; /* dfaAcceptState(alt) */
                    break;
                /* dfaEdgeSwitch(labels, targetState)
                 */
                case 'M':
                    
                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                     */
                    {
                        int LA21_160 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_160 == 'P') ) 
                        {
                            
                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                             */
                            {
                                int LA21_184 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                 */
                                if ( (LA21_184 == 'L') ) 
                                {
                                    
                                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                     */
                                    {
                                        int LA21_201 = LA(6);/* dfaEdge(labelExpr, targetState, predicates)
                                         */
                                        if ( (LA21_201 == 'E') ) 
                                        {
                                            
                                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                             */
                                            {
                                                int LA21_212 = LA(7);/* dfaEdge(labelExpr, targetState, predicates)
                                                 */
                                                if ( (LA21_212 == 'D') ) 
                                                {
                                                    alt21=111; /* dfaAcceptState(alt) */
                                                }
                                                else 
                                                {
                                                    alt21=110;    }
                                            }
                                        }
                                        else 
                                        {
                                        
                                            /* newNVException()
                                             */
                                            exConstruct();
                                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                            theException()->decisionNum  = 21;
                                            theException()->state        = 201;

                                        
                                            goto ruleTokensEx;
                                        }
                                    }
                                }
                                else 
                                {
                                
                                    /* newNVException()
                                     */
                                    exConstruct();
                                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                    theException()->decisionNum  = 21;
                                    theException()->state        = 184;

                                
                                    goto ruleTokensEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            /* newNVException()
                             */
                            exConstruct();
                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                            theException()->decisionNum  = 21;
                            theException()->state        = 160;

                        
                            goto ruleTokensEx;
                        }
                    }
                    break;
                
                default:
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 108;

                
                    goto ruleTokensEx;
                }
            
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'P':
                alt21=109; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'U':
                alt21=118; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'T':
                alt21=116; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'I':
                alt21=114; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 46;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 's':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'e':
                alt21=113; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 't':
                alt21=117; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'o':
                alt21=115; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 47;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'T':
            /* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
             */
            switch ( LA(2) ) 
            {
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'O':
                
                /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                 */
                {
                    int LA21_116 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                     */
                    if ( (LA21_116 == 'T') ) 
                    {
                        alt21=121; /* dfaAcceptState(alt) */
                    }
                    else 
                    {
                        alt21=120;    }
                }
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'E':
                alt21=119; /* dfaAcceptState(alt) */
                break;
            /* dfaEdgeSwitch(labels, targetState)
             */
            case 'R':
                alt21=122; /* dfaAcceptState(alt) */
                break;
            
            default:
                /* newNVException()
                 */
                exConstruct();
                theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                theException()->decisionNum  = 21;
                theException()->state        = 48;

            
                goto ruleTokensEx;
            }
        
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 't':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_49 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_49 == 'r') ) 
                {
                    alt21=123; /* dfaAcceptState(alt) */
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_49 == 'y') ) 
                {
                    alt21=124; /* dfaAcceptState(alt) */
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 49;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'U':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_50 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_50 == 'N') ) 
                {
                    
                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                     */
                    {
                        int LA21_121 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_121 == 'I') ) 
                        {
                            alt21=125; /* dfaAcceptState(alt) */
                        }
                        else /* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_121 == 'L') ) 
                        {
                            alt21=126; /* dfaAcceptState(alt) */
                        }
                        else 
                        {
                        
                            /* newNVException()
                             */
                            exConstruct();
                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                            theException()->decisionNum  = 21;
                            theException()->state        = 121;

                        
                            goto ruleTokensEx;
                        }
                    }
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_50 == 'Q') ) 
                {
                    alt21=127; /* dfaAcceptState(alt) */
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 50;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'V':
            alt21=128; /* dfaAcceptState(alt) */
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'W':
            
            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
             */
            {
                int LA21_52 = LA(2);/* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_52 == 'I') ) 
                {
                    
                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                     */
                    {
                        int LA21_123 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_123 == 'T') ) 
                        {
                            
                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                             */
                            {
                                int LA21_165 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                                 */
                                if ( (LA21_165 == 'H') ) 
                                {
                                    
                                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                                     */
                                    {
                                        int LA21_185 = LA(5);/* dfaEdge(labelExpr, targetState, predicates)
                                         */
                                        if ( (LA21_185 == 'I') ) 
                                        {
                                            alt21=132; /* dfaAcceptState(alt) */
                                        }
                                        else 
                                        {
                                            alt21=131;    }
                                    }
                                }
                                else 
                                {
                                
                                    /* newNVException()
                                     */
                                    exConstruct();
                                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                    theException()->decisionNum  = 21;
                                    theException()->state        = 165;

                                
                                    goto ruleTokensEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            /* newNVException()
                             */
                            exConstruct();
                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                            theException()->decisionNum  = 21;
                            theException()->state        = 123;

                        
                            goto ruleTokensEx;
                        }
                    }
                }
                else /* dfaEdge(labelExpr, targetState, predicates)
                 */
                if ( (LA21_52 == 'H') ) 
                {
                    
                    /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                     */
                    {
                        int LA21_124 = LA(3);/* dfaEdge(labelExpr, targetState, predicates)
                         */
                        if ( (LA21_124 == 'E') ) 
                        {
                            
                            /* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
                             */
                            {
                                int LA21_166 = LA(4);/* dfaEdge(labelExpr, targetState, predicates)
                                 */
                                if ( (LA21_166 == 'N') ) 
                                {
                                    alt21=129; /* dfaAcceptState(alt) */
                                }
                                else /* dfaEdge(labelExpr, targetState, predicates)
                                 */
                                if ( (LA21_166 == 'R') ) 
                                {
                                    alt21=131; /* dfaAcceptState(alt) */
                                }
                                else 
                                {
                                
                                    /* newNVException()
                                     */
                                    exConstruct();
                                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                                    theException()->decisionNum  = 21;
                                    theException()->state        = 166;

                                
                                    goto ruleTokensEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            /* newNVException()
                             */
                            exConstruct();
                            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                            theException()->decisionNum  = 21;
                            theException()->state        = 124;

                        
                            goto ruleTokensEx;
                        }
                    }
                }
                else 
                {
                
                    /* newNVException()
                     */
                    exConstruct();
                    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
                    theException()->decisionNum  = 21;
                    theException()->state        = 52;

                
                    goto ruleTokensEx;
                }
            }
            break;
        /* dfaEdgeSwitch(labels, targetState)
         */
        case 'w':
            alt21=130; /* dfaAcceptState(alt) */
            break;
        
        default:
            /* newNVException()
             */
            exConstruct();
            theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            theException()->message      = "1:1: Tokens : ( WS | STRING | IDSTRING | QUOTE | LBRACE | RBRACE | SEMI | LPAREN | RPAREN | COMMA | ATTRIBUTEVALUE | NUMBER | AT | AND | AS | ASSOC | ASSOC_WITH | ATTR | ATTR8 | ATTRNO | AVERAGE | BITMAP | BITSLICE | BETWEEN | BODY | BREAK_ON | BREAK_SUP | BY | BY_DSND | BY_EXP | BY_EXP_DSND | BY_EXP_SUB | BY_EXP_SUB_DSND | COL_HDG | CALC | COL_HDR_SUPP | COL_SPACES | COL_SUPP | COLNO | COLLATED | COMMAND | CONV | COUNT_SUPP | DATASTREAM | DBL_SPACE | DET_SUPP | DICTIONARY | DISPLAY_LIKE | EACH | ELEMENT | ENUM | EQ | EVAL | BFALSE | FILENAME | FILETYPE | FMT | FOOTING | FORMAT | FROM | GE | GLOBAL | GRAND_TOTAL | GT | HDR_SUPP | HEADING | ID_SUPP | IDLIST | INQUIRING | INDEX | INDEXES | INTERNAL | ISNULL | ISNOTNULL | ORDER | ITYPE | ITEMSTREAM | JUSTIFICATION | LE | LIKE | OPT_LPTR | OP_LT | MARGIN | MAX | MIN | MULTI_VALUE | MV | NAME | NE | NO | NODE | NO_INDEX | NO_NULLS | NOPAGE | NOSPLIT | NOT | ONLY | OPTIONS | OR | LIST_SPEC | PERCENT | PRINTER | PROCESSOR | QUERY | REFNO | REGULAR | REQUIRE_INDEX | REQUIRE_SELECT | SAID | SAMPLE | SAMPLED | SAVING | SELECTLIST | SINGLE_VALUE | SORTED | STAT | STORAGE | SUM | TERMINAL | TO | TOTAL | TRANSPORT | BTRUE | TYPE | UNIQUE | UNLIKE | UQS | VERT | WHEN | WIDTH | WITH | WITHIN );";
            theException()->decisionNum  = 21;
            theException()->state        = 0;

        
            goto ruleTokensEx;
        }
    
        switch (alt21) 
        {
    	/* altSwitchCase()
    	 */
    	case 1:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:10: WS
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:10: WS
    	         */
    	        mWS(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 2:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:13: STRING
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:13: STRING
    	         */
    	        mSTRING(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 3:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:20: IDSTRING
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:20: IDSTRING
    	         */
    	        mIDSTRING(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 4:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:29: QUOTE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:29: QUOTE
    	         */
    	        mQUOTE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 5:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:35: LBRACE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:35: LBRACE
    	         */
    	        mLBRACE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 6:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:42: RBRACE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:42: RBRACE
    	         */
    	        mRBRACE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 7:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:49: SEMI
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:49: SEMI
    	         */
    	        mSEMI(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 8:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:54: LPAREN
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:54: LPAREN
    	         */
    	        mLPAREN(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 9:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:61: RPAREN
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:61: RPAREN
    	         */
    	        mRPAREN(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 10:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:68: COMMA
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:68: COMMA
    	         */
    	        mCOMMA(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 11:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:74: ATTRIBUTEVALUE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:74: ATTRIBUTEVALUE
    	         */
    	        mATTRIBUTEVALUE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 12:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:89: NUMBER
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:89: NUMBER
    	         */
    	        mNUMBER(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 13:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:96: AT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:96: AT
    	         */
    	        mAT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 14:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:99: AND
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:99: AND
    	         */
    	        mAND(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 15:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:103: AS
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:103: AS
    	         */
    	        mAS(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 16:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:106: ASSOC
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:106: ASSOC
    	         */
    	        mASSOC(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 17:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:112: ASSOC_WITH
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:112: ASSOC_WITH
    	         */
    	        mASSOC_WITH(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 18:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:123: ATTR
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:123: ATTR
    	         */
    	        mATTR(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 19:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:128: ATTR8
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:128: ATTR8
    	         */
    	        mATTR8(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 20:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:134: ATTRNO
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:134: ATTRNO
    	         */
    	        mATTRNO(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 21:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:141: AVERAGE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:141: AVERAGE
    	         */
    	        mAVERAGE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 22:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:149: BITMAP
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:149: BITMAP
    	         */
    	        mBITMAP(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 23:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:156: BITSLICE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:156: BITSLICE
    	         */
    	        mBITSLICE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 24:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:165: BETWEEN
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:165: BETWEEN
    	         */
    	        mBETWEEN(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 25:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:173: BODY
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:173: BODY
    	         */
    	        mBODY(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 26:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:178: BREAK_ON
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:178: BREAK_ON
    	         */
    	        mBREAK_ON(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 27:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:187: BREAK_SUP
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:187: BREAK_SUP
    	         */
    	        mBREAK_SUP(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 28:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:197: BY
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:197: BY
    	         */
    	        mBY(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 29:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:200: BY_DSND
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:200: BY_DSND
    	         */
    	        mBY_DSND(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 30:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:208: BY_EXP
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:208: BY_EXP
    	         */
    	        mBY_EXP(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 31:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:215: BY_EXP_DSND
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:215: BY_EXP_DSND
    	         */
    	        mBY_EXP_DSND(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 32:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:227: BY_EXP_SUB
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:227: BY_EXP_SUB
    	         */
    	        mBY_EXP_SUB(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 33:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:238: BY_EXP_SUB_DSND
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:238: BY_EXP_SUB_DSND
    	         */
    	        mBY_EXP_SUB_DSND(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 34:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:254: COL_HDG
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:254: COL_HDG
    	         */
    	        mCOL_HDG(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 35:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:262: CALC
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:262: CALC
    	         */
    	        mCALC(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 36:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:267: COL_HDR_SUPP
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:267: COL_HDR_SUPP
    	         */
    	        mCOL_HDR_SUPP(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 37:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:280: COL_SPACES
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:280: COL_SPACES
    	         */
    	        mCOL_SPACES(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 38:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:291: COL_SUPP
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:291: COL_SUPP
    	         */
    	        mCOL_SUPP(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 39:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:300: COLNO
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:300: COLNO
    	         */
    	        mCOLNO(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 40:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:306: COLLATED
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:306: COLLATED
    	         */
    	        mCOLLATED(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 41:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:315: COMMAND
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:315: COMMAND
    	         */
    	        mCOMMAND(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 42:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:323: CONV
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:323: CONV
    	         */
    	        mCONV(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 43:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:328: COUNT_SUPP
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:328: COUNT_SUPP
    	         */
    	        mCOUNT_SUPP(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 44:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:339: DATASTREAM
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:339: DATASTREAM
    	         */
    	        mDATASTREAM(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 45:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:350: DBL_SPACE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:350: DBL_SPACE
    	         */
    	        mDBL_SPACE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 46:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:360: DET_SUPP
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:360: DET_SUPP
    	         */
    	        mDET_SUPP(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 47:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:369: DICTIONARY
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:369: DICTIONARY
    	         */
    	        mDICTIONARY(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 48:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:380: DISPLAY_LIKE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:380: DISPLAY_LIKE
    	         */
    	        mDISPLAY_LIKE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 49:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:393: EACH
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:393: EACH
    	         */
    	        mEACH(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 50:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:398: ELEMENT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:398: ELEMENT
    	         */
    	        mELEMENT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 51:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:406: ENUM
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:406: ENUM
    	         */
    	        mENUM(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 52:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:411: EQ
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:411: EQ
    	         */
    	        mEQ(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 53:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:414: EVAL
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:414: EVAL
    	         */
    	        mEVAL(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 54:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:419: BFALSE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:419: BFALSE
    	         */
    	        mBFALSE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 55:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:426: FILENAME
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:426: FILENAME
    	         */
    	        mFILENAME(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 56:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:435: FILETYPE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:435: FILETYPE
    	         */
    	        mFILETYPE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 57:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:444: FMT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:444: FMT
    	         */
    	        mFMT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 58:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:448: FOOTING
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:448: FOOTING
    	         */
    	        mFOOTING(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 59:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:456: FORMAT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:456: FORMAT
    	         */
    	        mFORMAT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 60:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:463: FROM
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:463: FROM
    	         */
    	        mFROM(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 61:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:468: GE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:468: GE
    	         */
    	        mGE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 62:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:471: GLOBAL
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:471: GLOBAL
    	         */
    	        mGLOBAL(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 63:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:478: GRAND_TOTAL
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:478: GRAND_TOTAL
    	         */
    	        mGRAND_TOTAL(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 64:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:490: GT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:490: GT
    	         */
    	        mGT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 65:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:493: HDR_SUPP
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:493: HDR_SUPP
    	         */
    	        mHDR_SUPP(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 66:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:502: HEADING
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:502: HEADING
    	         */
    	        mHEADING(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 67:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:510: ID_SUPP
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:510: ID_SUPP
    	         */
    	        mID_SUPP(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 68:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:518: IDLIST
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:518: IDLIST
    	         */
    	        mIDLIST(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 69:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:525: INQUIRING
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:525: INQUIRING
    	         */
    	        mINQUIRING(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 70:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:535: INDEX
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:535: INDEX
    	         */
    	        mINDEX(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 71:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:541: INDEXES
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:541: INDEXES
    	         */
    	        mINDEXES(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 72:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:549: INTERNAL
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:549: INTERNAL
    	         */
    	        mINTERNAL(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 73:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:558: ISNULL
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:558: ISNULL
    	         */
    	        mISNULL(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 74:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:565: ISNOTNULL
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:565: ISNOTNULL
    	         */
    	        mISNOTNULL(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 75:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:575: ORDER
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:575: ORDER
    	         */
    	        mORDER(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 76:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:581: ITYPE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:581: ITYPE
    	         */
    	        mITYPE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 77:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:587: ITEMSTREAM
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:587: ITEMSTREAM
    	         */
    	        mITEMSTREAM(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 78:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:598: JUSTIFICATION
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:598: JUSTIFICATION
    	         */
    	        mJUSTIFICATION(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 79:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:612: LE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:612: LE
    	         */
    	        mLE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 80:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:615: LIKE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:615: LIKE
    	         */
    	        mLIKE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 81:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:620: OPT_LPTR
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:620: OPT_LPTR
    	         */
    	        mOPT_LPTR(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 82:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:629: OP_LT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:629: OP_LT
    	         */
    	        mOP_LT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 83:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:635: MARGIN
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:635: MARGIN
    	         */
    	        mMARGIN(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 84:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:642: MAX
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:642: MAX
    	         */
    	        mMAX(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 85:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:646: MIN
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:646: MIN
    	         */
    	        mMIN(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 86:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:650: MULTI_VALUE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:650: MULTI_VALUE
    	         */
    	        mMULTI_VALUE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 87:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:662: MV
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:662: MV
    	         */
    	        mMV(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 88:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:665: NAME
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:665: NAME
    	         */
    	        mNAME(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 89:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:670: NE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:670: NE
    	         */
    	        mNE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 90:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:673: NO
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:673: NO
    	         */
    	        mNO(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 91:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:676: NODE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:676: NODE
    	         */
    	        mNODE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 92:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:681: NO_INDEX
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:681: NO_INDEX
    	         */
    	        mNO_INDEX(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 93:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:690: NO_NULLS
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:690: NO_NULLS
    	         */
    	        mNO_NULLS(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 94:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:699: NOPAGE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:699: NOPAGE
    	         */
    	        mNOPAGE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 95:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:706: NOSPLIT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:706: NOSPLIT
    	         */
    	        mNOSPLIT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 96:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:714: NOT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:714: NOT
    	         */
    	        mNOT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 97:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:718: ONLY
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:718: ONLY
    	         */
    	        mONLY(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 98:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:723: OPTIONS
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:723: OPTIONS
    	         */
    	        mOPTIONS(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 99:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:731: OR
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:731: OR
    	         */
    	        mOR(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 100:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:734: LIST_SPEC
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:734: LIST_SPEC
    	         */
    	        mLIST_SPEC(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 101:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:744: PERCENT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:744: PERCENT
    	         */
    	        mPERCENT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 102:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:752: PRINTER
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:752: PRINTER
    	         */
    	        mPRINTER(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 103:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:760: PROCESSOR
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:760: PROCESSOR
    	         */
    	        mPROCESSOR(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 104:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:770: QUERY
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:770: QUERY
    	         */
    	        mQUERY(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 105:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:776: REFNO
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:776: REFNO
    	         */
    	        mREFNO(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 106:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:782: REGULAR
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:782: REGULAR
    	         */
    	        mREGULAR(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 107:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:790: REQUIRE_INDEX
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:790: REQUIRE_INDEX
    	         */
    	        mREQUIRE_INDEX(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 108:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:804: REQUIRE_SELECT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:804: REQUIRE_SELECT
    	         */
    	        mREQUIRE_SELECT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 109:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:819: SAID
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:819: SAID
    	         */
    	        mSAID(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 110:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:824: SAMPLE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:824: SAMPLE
    	         */
    	        mSAMPLE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 111:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:831: SAMPLED
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:831: SAMPLED
    	         */
    	        mSAMPLED(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 112:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:839: SAVING
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:839: SAVING
    	         */
    	        mSAVING(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 113:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:846: SELECTLIST
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:846: SELECTLIST
    	         */
    	        mSELECTLIST(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 114:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:857: SINGLE_VALUE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:857: SINGLE_VALUE
    	         */
    	        mSINGLE_VALUE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 115:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:870: SORTED
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:870: SORTED
    	         */
    	        mSORTED(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 116:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:877: STAT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:877: STAT
    	         */
    	        mSTAT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 117:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:882: STORAGE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:882: STORAGE
    	         */
    	        mSTORAGE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 118:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:890: SUM
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:890: SUM
    	         */
    	        mSUM(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 119:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:894: TERMINAL
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:894: TERMINAL
    	         */
    	        mTERMINAL(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 120:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:903: TO
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:903: TO
    	         */
    	        mTO(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 121:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:906: TOTAL
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:906: TOTAL
    	         */
    	        mTOTAL(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 122:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:912: TRANSPORT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:912: TRANSPORT
    	         */
    	        mTRANSPORT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 123:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:922: BTRUE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:922: BTRUE
    	         */
    	        mBTRUE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 124:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:928: TYPE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:928: TYPE
    	         */
    	        mTYPE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 125:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:933: UNIQUE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:933: UNIQUE
    	         */
    	        mUNIQUE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 126:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:940: UNLIKE
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:940: UNLIKE
    	         */
    	        mUNLIKE(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 127:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:947: UQS
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:947: UQS
    	         */
    	        mUQS(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 128:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:951: VERT
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:951: VERT
    	         */
    	        mVERT(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 129:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:956: WHEN
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:956: WHEN
    	         */
    	        mWHEN(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 130:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:961: WIDTH
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:961: WIDTH
    	         */
    	        mWIDTH(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 131:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:967: WITH
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:967: WITH
    	         */
    	        mWITH(ctx ); 
    	    
    	    }
    	    break;
    	/* altSwitchCase()
    	 */
    	case 132:
    	    /* alt(elements,altNum,description,autoAST,outerAlt)
    	     * c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g:1:972: WITHIN
    	     */
    	    {
    	        /* element()
    	         */
    	        /* lexerRuleRef(rule,label,args)
    	         * From: 1:972: WITHIN
    	         */
    	        mWITHIN(ctx ); 
    	    
    	    }
    	    break;
    
        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */

/* =========================================================================
 * Lexer syntactic predicates
 */
/* =========================================================================
 * Lexer syntactic predicates end.
 * =========================================================================
 */
 
/* =========================================================================
 * DFA tables for the lexer
 */
 
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Cyclic DFAs for the lexer
 */
/* End of cyclic DFAs for the lexer
 */

/* End of code
 * =============================================================================
 */
