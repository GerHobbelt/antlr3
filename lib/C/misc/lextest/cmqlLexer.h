/** \file
 *  This C header file was generated by $ANTLR version 3.0b4
 *
 *     -  From the grammar source file : c:\\antlrsrc\\code\\antlr\\main\\lib\\C\\misc\\lextest\\cmql.g
 *     -                            On : 2006-08-18 16:05:54
 *     -                 for the lexer : cmqlLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim "Any relation to Eric?" Idle - "jimi" at idledotws
 *
 * View this file with tabs set to 8 (:set ts=8 in gvim) and indent at 4 (:set sw=4 in gvim)
 *
 * The lexer cmqlLexerhas the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 * 
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef pcmqlLexer, which is returned from a call to cmqlLexerNew().
 *
 * As this is a generated lexer, it is unlikely you will call it 'manually'. However
 * the entry points are provided anyway.
 * * The entry points for cmqlLexer are  as follows:
 *
 *  - void      pcmqlLexer->WS(pcmqlLexer)
 *  - void      pcmqlLexer->STRING(pcmqlLexer)
 *  - void      pcmqlLexer->IDSTRING(pcmqlLexer)
 *  - void      pcmqlLexer->ESCAPE_SEQUENCE(pcmqlLexer)
 *  - void      pcmqlLexer->QUOTE(pcmqlLexer)
 *  - void      pcmqlLexer->LBRACE(pcmqlLexer)
 *  - void      pcmqlLexer->RBRACE(pcmqlLexer)
 *  - void      pcmqlLexer->SEMI(pcmqlLexer)
 *  - void      pcmqlLexer->LPAREN(pcmqlLexer)
 *  - void      pcmqlLexer->RPAREN(pcmqlLexer)
 *  - void      pcmqlLexer->COMMA(pcmqlLexer)
 *  - void      pcmqlLexer->ATTRIBUTEVALUE(pcmqlLexer)
 *  - void      pcmqlLexer->NUMBER(pcmqlLexer)
 *  - void      pcmqlLexer->DIGIT(pcmqlLexer)
 *  - void      pcmqlLexer->AT(pcmqlLexer)
 *  - void      pcmqlLexer->AND(pcmqlLexer)
 *  - void      pcmqlLexer->AS(pcmqlLexer)
 *  - void      pcmqlLexer->ASSOC(pcmqlLexer)
 *  - void      pcmqlLexer->ASSOC_WITH(pcmqlLexer)
 *  - void      pcmqlLexer->ATTR(pcmqlLexer)
 *  - void      pcmqlLexer->ATTR8(pcmqlLexer)
 *  - void      pcmqlLexer->ATTRNO(pcmqlLexer)
 *  - void      pcmqlLexer->AVERAGE(pcmqlLexer)
 *  - void      pcmqlLexer->BITMAP(pcmqlLexer)
 *  - void      pcmqlLexer->BITSLICE(pcmqlLexer)
 *  - void      pcmqlLexer->BETWEEN(pcmqlLexer)
 *  - void      pcmqlLexer->BODY(pcmqlLexer)
 *  - void      pcmqlLexer->BREAK_ON(pcmqlLexer)
 *  - void      pcmqlLexer->BREAK_SUP(pcmqlLexer)
 *  - void      pcmqlLexer->BY(pcmqlLexer)
 *  - void      pcmqlLexer->BY_DSND(pcmqlLexer)
 *  - void      pcmqlLexer->BY_EXP(pcmqlLexer)
 *  - void      pcmqlLexer->BY_EXP_DSND(pcmqlLexer)
 *  - void      pcmqlLexer->BY_EXP_SUB(pcmqlLexer)
 *  - void      pcmqlLexer->BY_EXP_SUB_DSND(pcmqlLexer)
 *  - void      pcmqlLexer->COL_HDG(pcmqlLexer)
 *  - void      pcmqlLexer->CALC(pcmqlLexer)
 *  - void      pcmqlLexer->COL_HDR_SUPP(pcmqlLexer)
 *  - void      pcmqlLexer->COL_SPACES(pcmqlLexer)
 *  - void      pcmqlLexer->COL_SUPP(pcmqlLexer)
 *  - void      pcmqlLexer->COLNO(pcmqlLexer)
 *  - void      pcmqlLexer->COLLATED(pcmqlLexer)
 *  - void      pcmqlLexer->COMMAND(pcmqlLexer)
 *  - void      pcmqlLexer->CONV(pcmqlLexer)
 *  - void      pcmqlLexer->COUNT_SUPP(pcmqlLexer)
 *  - void      pcmqlLexer->DATASTREAM(pcmqlLexer)
 *  - void      pcmqlLexer->DBL_SPACE(pcmqlLexer)
 *  - void      pcmqlLexer->DET_SUPP(pcmqlLexer)
 *  - void      pcmqlLexer->DICTIONARY(pcmqlLexer)
 *  - void      pcmqlLexer->DISPLAY_LIKE(pcmqlLexer)
 *  - void      pcmqlLexer->EACH(pcmqlLexer)
 *  - void      pcmqlLexer->ELEMENT(pcmqlLexer)
 *  - void      pcmqlLexer->ENUM(pcmqlLexer)
 *  - void      pcmqlLexer->EQ(pcmqlLexer)
 *  - void      pcmqlLexer->EVAL(pcmqlLexer)
 *  - void      pcmqlLexer->BFALSE(pcmqlLexer)
 *  - void      pcmqlLexer->FILENAME(pcmqlLexer)
 *  - void      pcmqlLexer->FILETYPE(pcmqlLexer)
 *  - void      pcmqlLexer->FMT(pcmqlLexer)
 *  - void      pcmqlLexer->FOOTING(pcmqlLexer)
 *  - void      pcmqlLexer->FORMAT(pcmqlLexer)
 *  - void      pcmqlLexer->FROM(pcmqlLexer)
 *  - void      pcmqlLexer->GE(pcmqlLexer)
 *  - void      pcmqlLexer->GLOBAL(pcmqlLexer)
 *  - void      pcmqlLexer->GRAND_TOTAL(pcmqlLexer)
 *  - void      pcmqlLexer->GT(pcmqlLexer)
 *  - void      pcmqlLexer->HDR_SUPP(pcmqlLexer)
 *  - void      pcmqlLexer->HEADING(pcmqlLexer)
 *  - void      pcmqlLexer->ID_SUPP(pcmqlLexer)
 *  - void      pcmqlLexer->IDLIST(pcmqlLexer)
 *  - void      pcmqlLexer->INQUIRING(pcmqlLexer)
 *  - void      pcmqlLexer->INDEX(pcmqlLexer)
 *  - void      pcmqlLexer->INDEXES(pcmqlLexer)
 *  - void      pcmqlLexer->INTERNAL(pcmqlLexer)
 *  - void      pcmqlLexer->ISNULL(pcmqlLexer)
 *  - void      pcmqlLexer->ISNOTNULL(pcmqlLexer)
 *  - void      pcmqlLexer->ORDER(pcmqlLexer)
 *  - void      pcmqlLexer->ITYPE(pcmqlLexer)
 *  - void      pcmqlLexer->ITEMSTREAM(pcmqlLexer)
 *  - void      pcmqlLexer->JUSTIFICATION(pcmqlLexer)
 *  - void      pcmqlLexer->LE(pcmqlLexer)
 *  - void      pcmqlLexer->LIKE(pcmqlLexer)
 *  - void      pcmqlLexer->OPT_LPTR(pcmqlLexer)
 *  - void      pcmqlLexer->OP_LT(pcmqlLexer)
 *  - void      pcmqlLexer->MARGIN(pcmqlLexer)
 *  - void      pcmqlLexer->MAX(pcmqlLexer)
 *  - void      pcmqlLexer->MIN(pcmqlLexer)
 *  - void      pcmqlLexer->MULTI_VALUE(pcmqlLexer)
 *  - void      pcmqlLexer->MV(pcmqlLexer)
 *  - void      pcmqlLexer->NAME(pcmqlLexer)
 *  - void      pcmqlLexer->NE(pcmqlLexer)
 *  - void      pcmqlLexer->NO(pcmqlLexer)
 *  - void      pcmqlLexer->NODE(pcmqlLexer)
 *  - void      pcmqlLexer->NO_INDEX(pcmqlLexer)
 *  - void      pcmqlLexer->NO_NULLS(pcmqlLexer)
 *  - void      pcmqlLexer->NOPAGE(pcmqlLexer)
 *  - void      pcmqlLexer->NOSPLIT(pcmqlLexer)
 *  - void      pcmqlLexer->NOT(pcmqlLexer)
 *  - void      pcmqlLexer->ONLY(pcmqlLexer)
 *  - void      pcmqlLexer->OPTIONS(pcmqlLexer)
 *  - void      pcmqlLexer->OR(pcmqlLexer)
 *  - void      pcmqlLexer->LIST_SPEC(pcmqlLexer)
 *  - void      pcmqlLexer->PERCENT(pcmqlLexer)
 *  - void      pcmqlLexer->PRINTER(pcmqlLexer)
 *  - void      pcmqlLexer->PROCESSOR(pcmqlLexer)
 *  - void      pcmqlLexer->QUERY(pcmqlLexer)
 *  - void      pcmqlLexer->REFNO(pcmqlLexer)
 *  - void      pcmqlLexer->REGULAR(pcmqlLexer)
 *  - void      pcmqlLexer->REQUIRE_INDEX(pcmqlLexer)
 *  - void      pcmqlLexer->REQUIRE_SELECT(pcmqlLexer)
 *  - void      pcmqlLexer->SAID(pcmqlLexer)
 *  - void      pcmqlLexer->SAMPLE(pcmqlLexer)
 *  - void      pcmqlLexer->SAMPLED(pcmqlLexer)
 *  - void      pcmqlLexer->SAVING(pcmqlLexer)
 *  - void      pcmqlLexer->SELECTLIST(pcmqlLexer)
 *  - void      pcmqlLexer->SINGLE_VALUE(pcmqlLexer)
 *  - void      pcmqlLexer->SORTED(pcmqlLexer)
 *  - void      pcmqlLexer->STAT(pcmqlLexer)
 *  - void      pcmqlLexer->STORAGE(pcmqlLexer)
 *  - void      pcmqlLexer->SUM(pcmqlLexer)
 *  - void      pcmqlLexer->TERMINAL(pcmqlLexer)
 *  - void      pcmqlLexer->TO(pcmqlLexer)
 *  - void      pcmqlLexer->TOTAL(pcmqlLexer)
 *  - void      pcmqlLexer->TRANSPORT(pcmqlLexer)
 *  - void      pcmqlLexer->BTRUE(pcmqlLexer)
 *  - void      pcmqlLexer->TYPE(pcmqlLexer)
 *  - void      pcmqlLexer->UNIQUE(pcmqlLexer)
 *  - void      pcmqlLexer->UNLIKE(pcmqlLexer)
 *  - void      pcmqlLexer->UQS(pcmqlLexer)
 *  - void      pcmqlLexer->VERT(pcmqlLexer)
 *  - void      pcmqlLexer->WHEN(pcmqlLexer)
 *  - void      pcmqlLexer->WIDTH(pcmqlLexer)
 *  - void      pcmqlLexer->WITH(pcmqlLexer)
 *  - void      pcmqlLexer->WITHIN(pcmqlLexer)
 *  - void      pcmqlLexer->Tokens(pcmqlLexer)
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.
 */
#ifndef	_cmqlLexer_H
#define _cmqlLexer_H


/* =============================================================================
 * Standard antlr3 C runtime definitions
 */
#include    <antlr3.h>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */

/** Tricky typedef state to allow dfa states in Cyclic dfas to return the address of the
 *  next dfa state that is predicted for the current dfa state, or the address
 *  of themselves if they predict an alt. :-)
 *
 * \remark
 * In case you can't read this, and I think no less of you if you cannot, 
 * this declares ANTLR3_DFASTATE to be a pointer to a
 * a function that accepts a context pointer and a pointer to the alt, and returns
 * a pointer to a function that accepts a context pointer and a pointer to int and
 * returns a pointer to void (which we then cast to ANTLR3_DFASTATE). There are other ways
 * of doing this such as cascading definitions, but this works just fine.
 *
 * Jim Idle - March 2006
 */
typedef	    void *(*(*ANTLR3_DFASTATE)(pcmqlLexer, pANTLR3_UINT32))(pcmqlLexer, pANTLR3_UINT32) ;

/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */
/* returnScope() */
/* end: returnScope() */


/** Context tracking structure for cmqlLexer
 */
typedef struct cmqlLexer_Ctx_struct
{
    /** Built in ANTLR3 context tracker contains all the generic elements
     *  required for context tracking.
     */
    pANTLR3_LEXER    pLexer;








































































































































    void (*mWS)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSTRING)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mIDSTRING)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mESCAPE_SEQUENCE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mQUOTE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mLBRACE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mRBRACE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSEMI)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mLPAREN)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mRPAREN)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCOMMA)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mATTRIBUTEVALUE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mNUMBER)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mDIGIT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mAT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mAND)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mAS)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mASSOC)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mASSOC_WITH)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mATTR)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mATTR8)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mATTRNO)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mAVERAGE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBITMAP)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBITSLICE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBETWEEN)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBODY)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBREAK_ON)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBREAK_SUP)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBY)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBY_DSND)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBY_EXP)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBY_EXP_DSND)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBY_EXP_SUB)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBY_EXP_SUB_DSND)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCOL_HDG)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCALC)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCOL_HDR_SUPP)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCOL_SPACES)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCOL_SUPP)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCOLNO)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCOLLATED)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCOMMAND)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCONV)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mCOUNT_SUPP)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mDATASTREAM)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mDBL_SPACE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mDET_SUPP)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mDICTIONARY)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mDISPLAY_LIKE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mEACH)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mELEMENT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mENUM)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mEQ)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mEVAL)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBFALSE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mFILENAME)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mFILETYPE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mFMT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mFOOTING)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mFORMAT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mFROM)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mGE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mGLOBAL)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mGRAND_TOTAL)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mGT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mHDR_SUPP)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mHEADING)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mID_SUPP)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mIDLIST)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mINQUIRING)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mINDEX)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mINDEXES)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mINTERNAL)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mISNULL)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mISNOTNULL)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mORDER)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mITYPE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mITEMSTREAM)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mJUSTIFICATION)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mLE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mLIKE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mOPT_LPTR)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mOP_LT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mMARGIN)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mMAX)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mMIN)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mMULTI_VALUE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mMV)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mNAME)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mNE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mNO)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mNODE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mNO_INDEX)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mNO_NULLS)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mNOPAGE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mNOSPLIT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mNOT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mONLY)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mOPTIONS)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mOR)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mLIST_SPEC)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mPERCENT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mPRINTER)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mPROCESSOR)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mQUERY)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mREFNO)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mREGULAR)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mREQUIRE_INDEX)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mREQUIRE_SELECT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSAID)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSAMPLE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSAMPLED)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSAVING)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSELECTLIST)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSINGLE_VALUE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSORTED)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSTAT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSTORAGE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mSUM)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mTERMINAL)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mTO)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mTOTAL)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mTRANSPORT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mBTRUE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mTYPE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mUNIQUE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mUNLIKE)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mUQS)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mVERT)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mWHEN)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mWIDTH)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mWITH)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mWITHIN)	(struct cmqlLexer_Ctx_struct * ctx);
    void (*mTokens)	(struct cmqlLexer_Ctx_struct * ctx);    unsigned char * (*getGrammarFileName)();
    void	    (*free)   (struct cmqlLexer_Ctx_struct * ctx);
    
        
}
    cmqlLexer, * pcmqlLexer;

/* Function protoypes for the lexer functions that external translation units
 * may wish to call.
 */
ANTLR3_API pcmqlLexer cmqlLexerNew         (pANTLR3_INPUT_STREAM     instream);
/** Symbolic definitions of all the tokens that the lexer will work with.
 * \{
 *
 * Antlr will define EOF, but we can't use that as it it is too common in
 * in C header files and that would be confusing. There is no way to filter this out at the moment
 * so we just undef it here for now. That isn't the value we get back from C recognizers
 * anyway. We are looking for ANTLR3_TOKEN_EOF.
 */
#ifdef	EOF
#undef	EOF
#endif
 
#define INDEX      37
#define COMMA      155
#define ELEMENT      46
#define WITHIN      166
#define AS      157
#define REFNO      53
#define BTRUE      72
#define TOTAL      134
#define BY_EXP_DSND      131
#define NUMBER      66
#define COUNT_SUPP      86
#define ITYPE      57
#define BYEXP      32
#define COLLATED      48
#define SAVE      33
#define GRAND_TOTAL      90
#define QUERY_BODY      7
#define OPT_LPTR      93
#define INDEXES      34
#define ORDER      160
#define TO      82
#define OR_WITH      19
#define AND      109
#define MULTI_VALUE      148
#define ASP      23
#define ATTR      158
#define GLOBAL      64
#define STORAGE      45
#define CONNECTIVES      10
#define AVERAGE      135
#define FORMAT      61
#define LE      115
#define VSP_OR      27
#define BETWEEN      117
#define RPAREN      154
#define SELECT_TO      12
#define BY_EXP_SUB_DSND      133
#define BODY      80
#define FILENAME      63
#define KNULL      31
#define AND_WITH      18
#define NOPAGE      95
#define NOSPLIT      96
#define AT      81
#define REQUIRE_SELECT      100
#define ASP_AND      25
#define COL_SUPP      85
#define SAMPLE      103
#define ASSOC_WITH      147
#define ISNOTNULL      127
#define VSP_AND      28
#define INTERNAL      77
#define WHEN      122
#define VSP      26
#define WS      150
#define COL_HDG      146
#define STRING      40
#define EQ      39
#define LIST_SPEC      161
#define MARGIN      94
#define COL_HDR_SUPP      83
#define SAID      164
#define IIDSELECT      14
#define TRANSPORT      140
#define BY_EXP_SUB      132
#define UNLIKE      120
#define SEMI      41
#define DICT_SPEC      5
#define GE      116
#define BY_DSND      129
#define EVAL      159
#define INQUIRING      108
#define ATTRIBUTEVALUE      54
#define SORTED      70
#define OP_LT      113
#define SAMPLED      104
#define DICT_ELEMENT      6
#define NAME      38
#define AND_WHEN      21
#define BFALSE      73
#define NO_NULLS      107
#define WIDTH      60
#define UNIQUE      106
#define EACH      125
#define TYPE      42
#define REGULAR      163
#define STATEMENT      9
#define DICTIONARY      49
#define PERCENT      139
#define OR_WHEN      22
#define WITH_CLAUSE      16
#define SAVING      105
#define ASSOC      50
#define FILETYPE      65
#define QUERY      4
#define NO_INDEX      97
#define CONV      58
#define VERT      101
#define BY_EXP      130
#define OR      110
#define TERMINAL      165
#define ATTRNO      52
#define LBRACE      35
#define RBRACE      36
#define COL_SPACES      84
#define IDSTRING      111
#define BY      128
#define UQS      118
#define BITSLICE      44
#define FMT      144
#define IID      13
#define ATTR8      56
#define OPTIONS      69
#define COLNO      62
#define LPAREN      153
#define DIGIT      156
#define MV      55
#define SUM      78
#define IDLIST      74
#define INDEX_NODE      30
#define FROM      102
#define ENUM      136
#define PRINTER      162
#define ID_SUPP      92
#define SELECTLIST      71
#define MAX      137
#define ASP_OR      24
#define STAT      79
#define INDEX_ELEMENT      29
#define JUSTIFICATION      59
#define ONLY      98
#define NE      112
#define GT      114
#define NO      123
#define WITH_FACTOR      17
#define MIN      138
#define HDR_SUPP      91
#define QUOTE      152
#define HEADING      51
#define DISPLAY_LIKE      145
#define LIKE      119
#define ITEMSTREAM      75
#define BITMAP      43
#define WITH      121
#define FOOTING      89
#define PROCESSOR      68
#define DET_SUPP      88
#define WHEN_CLAUSE      20
#define BREAK_SUP      142
#define QUERY_SPECS      8
#define ESCAPE_SEQUENCE      151
#define EOF      -1
#define DBL_SPACE      87
#define NODE      47
#define ISNULL      126
#define Tokens      167
#define DATASTREAM      76
#define SINGLE_VALUE      149
#define CALC      143
#define OUTPUT_SPEC      11
#define REQUIRE_INDEX      99
#define NOT      124
#define COMMAND      67
#define SELECT_FACTOR      15
#define BREAK_ON      141


/* End of token definitions for cmqlLexer
 * =============================================================================
 */
/** \} */



/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always refering to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritence and without nailing anybody to a cross for 
 * suggesting we just be nice to each other.
 */
 
/* Macros for access things in a lexer
 */
#undef	    lexr
#undef	    ruleMemo		    
#undef	    getCharIndex
#undef	    getLine
#undef	    getCharPositionInLine
#undef	    emit
#undef	    emitNew
#undef	    matchc
#undef	    matchs
#undef	    matchRange
#undef	    ltoken
#undef	    hasFailed
#undef	    failedFlag
#undef	    theInput
#undef	    LA
#undef	    hasException
#undef	    theException
#undef	    exConstruct
#undef	    inputConsume
#undef	    lrecover
#undef	    markMyWords
#undef	    rewindInput

#define	    lexr		    ctx->pLexer
#define	    ruleMemo		    lexr->rec->ruleMemo
#define	    getCharIndex()	    lexr->getCharIndex(lexr->me)
#define	    getLine()		    lexr->getLine(lexr->me)
#define	    getCharPositionInLine() lexr->getCharPositionInLine(lexr->me)
#define	    emit(t)		    lexr->emit(lexr->me, t)
#define	    emitNew(t,l,cp,ch,s,i)  lexr->emitNew(lexr->me, t, l, cp, ch, s, i)
#define	    matchc(c)		    lexr->matchc(lexr->me, c)
#define	    matchs(s)		    lexr->matchs(lexr->me, s)
#define	    matchRange(c1,c2)	    lexr->matchRange(lexr->me, c1, c2)
#define	    ltoken()		    lexr->token
#define	    hasFailed()		    (lexr->rec->failed == ANTLR3_TRUE)
#define	    failedFlag()	    lexr->rec->failed
#define	    theInput()		    lexr->input
#define	    LA(n)		    theInput()->istream->LA(lexr->input->istream->me, n)
#define	    hasException()	    (theInput()->istream->error == ANTLR3_TRUE)
#define	    theException()	    theInput()->istream->exception
#define	    exConstruct()	    theInput()->istream->exConstruct(theInput()->istream)
#define	    inputConsume()	    theInput()->istream->consume(theInput()->istream->me)
#define	    lrecover()		    lexr->recover(lexr->me)
#define	    markMyWords()	    theInput()->istream->mark(theInput()->istream->me)
#define	    rewindInput(m)	    theInput()->istream->rewind(theInput()->istream->me, m)
#endif