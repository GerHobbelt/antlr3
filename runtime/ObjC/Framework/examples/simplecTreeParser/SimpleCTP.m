// $ANTLR 3.1b1 SimpleCTP.gtp 2007-11-13 15:03:27

#import "SimpleCTP.h"


#pragma mark Bitsets
const static unsigned long long FOLLOW_declaration_in_program38_data[] = {0x0000000000000192LL};
static ANTLRBitSet *FOLLOW_declaration_in_program38;
const static unsigned long long FOLLOW_variable_in_declaration58_data[] = {0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_variable_in_declaration58;
const static unsigned long long FOLLOW_SimpleCTP_FUNC_DECL_in_declaration69_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_FUNC_DECL_in_declaration69;
const static unsigned long long FOLLOW_functionHeader_in_declaration71_data[] = {0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_functionHeader_in_declaration71;
const static unsigned long long FOLLOW_SimpleCTP_FUNC_DEF_in_declaration83_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_FUNC_DEF_in_declaration83;
const static unsigned long long FOLLOW_functionHeader_in_declaration85_data[] = {0x0000000000000200LL};
static ANTLRBitSet *FOLLOW_functionHeader_in_declaration85;
const static unsigned long long FOLLOW_block_in_declaration87_data[] = {0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_block_in_declaration87;
const static unsigned long long FOLLOW_SimpleCTP_VAR_DEF_in_variable108_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_VAR_DEF_in_variable108;
const static unsigned long long FOLLOW_type_in_variable110_data[] = {0x0000000000000400LL};
static ANTLRBitSet *FOLLOW_type_in_variable110;
const static unsigned long long FOLLOW_declarator_in_variable112_data[] = {0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_declarator_in_variable112;
const static unsigned long long FOLLOW_SimpleCTP_ID_in_declarator132_data[] = {0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_ID_in_declarator132;
const static unsigned long long FOLLOW_SimpleCTP_FUNC_HDR_in_functionHeader153_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_FUNC_HDR_in_functionHeader153;
const static unsigned long long FOLLOW_type_in_functionHeader155_data[] = {0x0000000000000400LL};
static ANTLRBitSet *FOLLOW_type_in_functionHeader155;
const static unsigned long long FOLLOW_SimpleCTP_ID_in_functionHeader157_data[] = {0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_ID_in_functionHeader157;
const static unsigned long long FOLLOW_formalParameter_in_functionHeader159_data[] = {0x0000000000000028LL};
static ANTLRBitSet *FOLLOW_formalParameter_in_functionHeader159;
const static unsigned long long FOLLOW_SimpleCTP_ARG_DEF_in_formalParameter181_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_ARG_DEF_in_formalParameter181;
const static unsigned long long FOLLOW_type_in_formalParameter183_data[] = {0x0000000000000400LL};
static ANTLRBitSet *FOLLOW_type_in_formalParameter183;
const static unsigned long long FOLLOW_declarator_in_formalParameter185_data[] = {0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_declarator_in_formalParameter185;
const static unsigned long long FOLLOW_set_in_type0_data[] = {0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_set_in_type0;
const static unsigned long long FOLLOW_SimpleCTP_BLOCK_in_block268_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_BLOCK_in_block268;
const static unsigned long long FOLLOW_variable_in_block270_data[] = {0x00000000000E3E18LL};
static ANTLRBitSet *FOLLOW_variable_in_block270;
const static unsigned long long FOLLOW_stat_in_block273_data[] = {0x00000000000E3E08LL};
static ANTLRBitSet *FOLLOW_stat_in_block273;
const static unsigned long long FOLLOW_forStat_in_stat287_data[] = {0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_forStat_in_stat287;
const static unsigned long long FOLLOW_expr_in_stat295_data[] = {0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_expr_in_stat295;
const static unsigned long long FOLLOW_block_in_stat303_data[] = {0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_block_in_stat303;
const static unsigned long long FOLLOW_SimpleCTP_FOR_in_forStat323_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_FOR_in_forStat323;
const static unsigned long long FOLLOW_expr_in_forStat325_data[] = {0x00000000000E1C00LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat325;
const static unsigned long long FOLLOW_expr_in_forStat327_data[] = {0x00000000000E1C00LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat327;
const static unsigned long long FOLLOW_expr_in_forStat329_data[] = {0x0000000000000200LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat329;
const static unsigned long long FOLLOW_block_in_forStat331_data[] = {0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_block_in_forStat331;
const static unsigned long long FOLLOW_SimpleCTP_EQEQ_in_expr347_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_EQEQ_in_expr347;
const static unsigned long long FOLLOW_expr_in_expr349_data[] = {0x00000000000E1C00LL};
static ANTLRBitSet *FOLLOW_expr_in_expr349;
const static unsigned long long FOLLOW_expr_in_expr351_data[] = {0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_expr_in_expr351;
const static unsigned long long FOLLOW_SimpleCTP_LT_in_expr363_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_LT_in_expr363;
const static unsigned long long FOLLOW_expr_in_expr365_data[] = {0x00000000000E1C00LL};
static ANTLRBitSet *FOLLOW_expr_in_expr365;
const static unsigned long long FOLLOW_expr_in_expr367_data[] = {0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_expr_in_expr367;
const static unsigned long long FOLLOW_SimpleCTP_PLUS_in_expr379_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_PLUS_in_expr379;
const static unsigned long long FOLLOW_expr_in_expr381_data[] = {0x00000000000E1C00LL};
static ANTLRBitSet *FOLLOW_expr_in_expr381;
const static unsigned long long FOLLOW_expr_in_expr383_data[] = {0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_expr_in_expr383;
const static unsigned long long FOLLOW_SimpleCTP_EQ_in_expr395_data[] = {0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_EQ_in_expr395;
const static unsigned long long FOLLOW_SimpleCTP_ID_in_expr397_data[] = {0x00000000000E1C00LL};
static ANTLRBitSet *FOLLOW_SimpleCTP_ID_in_expr397;
const static unsigned long long FOLLOW_expr_in_expr401_data[] = {0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_expr_in_expr401;
const static unsigned long long FOLLOW_atom_in_expr414_data[] = {0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_atom_in_expr414;
const static unsigned long long FOLLOW_set_in_atom0_data[] = {0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_set_in_atom0;


#pragma mark Dynamic Global Scopes

#pragma mark Dynamic Rule Scopes

#pragma mark Rule return scopes start
@implementation SimpleCTP_expr_return
@end


@implementation SimpleCTP

static NSArray *tokenNames;

+ (void) initialize
{
	FOLLOW_declaration_in_program38 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_declaration_in_program38_data count:1];
	FOLLOW_variable_in_declaration58 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_variable_in_declaration58_data count:1];
	FOLLOW_SimpleCTP_FUNC_DECL_in_declaration69 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_FUNC_DECL_in_declaration69_data count:1];
	FOLLOW_functionHeader_in_declaration71 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_functionHeader_in_declaration71_data count:1];
	FOLLOW_SimpleCTP_FUNC_DEF_in_declaration83 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_FUNC_DEF_in_declaration83_data count:1];
	FOLLOW_functionHeader_in_declaration85 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_functionHeader_in_declaration85_data count:1];
	FOLLOW_block_in_declaration87 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_block_in_declaration87_data count:1];
	FOLLOW_SimpleCTP_VAR_DEF_in_variable108 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_VAR_DEF_in_variable108_data count:1];
	FOLLOW_type_in_variable110 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_type_in_variable110_data count:1];
	FOLLOW_declarator_in_variable112 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_declarator_in_variable112_data count:1];
	FOLLOW_SimpleCTP_ID_in_declarator132 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_ID_in_declarator132_data count:1];
	FOLLOW_SimpleCTP_FUNC_HDR_in_functionHeader153 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_FUNC_HDR_in_functionHeader153_data count:1];
	FOLLOW_type_in_functionHeader155 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_type_in_functionHeader155_data count:1];
	FOLLOW_SimpleCTP_ID_in_functionHeader157 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_ID_in_functionHeader157_data count:1];
	FOLLOW_formalParameter_in_functionHeader159 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_formalParameter_in_functionHeader159_data count:1];
	FOLLOW_SimpleCTP_ARG_DEF_in_formalParameter181 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_ARG_DEF_in_formalParameter181_data count:1];
	FOLLOW_type_in_formalParameter183 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_type_in_formalParameter183_data count:1];
	FOLLOW_declarator_in_formalParameter185 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_declarator_in_formalParameter185_data count:1];
	FOLLOW_set_in_type0 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_set_in_type0_data count:1];
	FOLLOW_SimpleCTP_BLOCK_in_block268 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_BLOCK_in_block268_data count:1];
	FOLLOW_variable_in_block270 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_variable_in_block270_data count:1];
	FOLLOW_stat_in_block273 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_stat_in_block273_data count:1];
	FOLLOW_forStat_in_stat287 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_forStat_in_stat287_data count:1];
	FOLLOW_expr_in_stat295 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_stat295_data count:1];
	FOLLOW_block_in_stat303 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_block_in_stat303_data count:1];
	FOLLOW_SimpleCTP_FOR_in_forStat323 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_FOR_in_forStat323_data count:1];
	FOLLOW_expr_in_forStat325 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_forStat325_data count:1];
	FOLLOW_expr_in_forStat327 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_forStat327_data count:1];
	FOLLOW_expr_in_forStat329 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_forStat329_data count:1];
	FOLLOW_block_in_forStat331 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_block_in_forStat331_data count:1];
	FOLLOW_SimpleCTP_EQEQ_in_expr347 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_EQEQ_in_expr347_data count:1];
	FOLLOW_expr_in_expr349 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_expr349_data count:1];
	FOLLOW_expr_in_expr351 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_expr351_data count:1];
	FOLLOW_SimpleCTP_LT_in_expr363 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_LT_in_expr363_data count:1];
	FOLLOW_expr_in_expr365 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_expr365_data count:1];
	FOLLOW_expr_in_expr367 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_expr367_data count:1];
	FOLLOW_SimpleCTP_PLUS_in_expr379 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_PLUS_in_expr379_data count:1];
	FOLLOW_expr_in_expr381 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_expr381_data count:1];
	FOLLOW_expr_in_expr383 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_expr383_data count:1];
	FOLLOW_SimpleCTP_EQ_in_expr395 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_EQ_in_expr395_data count:1];
	FOLLOW_SimpleCTP_ID_in_expr397 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_SimpleCTP_ID_in_expr397_data count:1];
	FOLLOW_expr_in_expr401 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_expr_in_expr401_data count:1];
	FOLLOW_atom_in_expr414 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_atom_in_expr414_data count:1];
	FOLLOW_set_in_atom0 = [[ANTLRBitSet alloc] initWithBits:FOLLOW_set_in_atom0_data count:1];

	tokenNames = [[NSArray alloc] initWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>", 
	@"VAR_DEF", @"ARG_DEF", @"FUNC_HDR", @"FUNC_DECL", @"FUNC_DEF", @"BLOCK", 
	@"ID", @"EQ", @"INT", @"FOR", @"INT_TYPE", @"CHAR", @"VOID", @"EQEQ", @"LT", 
	@"PLUS", @"WS", @"';'", @"'('", @"','", @"')'", @"'{'", @"'}'", nil];
}


- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)aStream
{
	if ((self = [super initWithTreeNodeStream:aStream])) {


																										
	}
	return self;
}

- (void) dealloc
{

	[super dealloc];
}

- (NSString *) grammarFileName
{
	return @"SimpleCTP.gtp";
}


// $ANTLR start program
// SimpleCTP.gtp:8:1: program : ( declaration )+ ;
- (void) program
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:9:5: ( ( declaration )+ ) // ruleBlockSingleAlt
        // SimpleCTP.gtp:9:9: ( declaration )+ // alt
        {
        // SimpleCTP.gtp:9:9: ( declaration )+	// positiveClosureBlock
        int cnt1=0;

        do {
            int alt1=2;
            {
            	int LA1_0 = [input LA:1];
            	if ( LA1_0==SimpleCTP_VAR_DEF||(LA1_0>=SimpleCTP_FUNC_DECL && LA1_0<=SimpleCTP_FUNC_DEF) ) {
            		alt1 = 1;
            	}

            }
            switch (alt1) {
        	case 1 :
        	    // SimpleCTP.gtp:9:9: declaration // alt
        	    {
        	    [[_state following] addObject:FOLLOW_declaration_in_program38];
        	    [self declaration];
        	    [[_state following] removeLastObject];



        	    }
        	    break;

        	default :
        	    if ( cnt1 >= 1 )  goto loop1;
        			ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:1];
        			@throw eee;
            }
            cnt1++;
        } while (YES); loop1: ;


        }

    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end program

// $ANTLR start declaration
// SimpleCTP.gtp:12:1: declaration : ( variable | ^( FUNC_DECL functionHeader ) | ^( FUNC_DEF functionHeader block ) );
- (void) declaration
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:13:5: ( variable | ^( FUNC_DECL functionHeader ) | ^( FUNC_DEF functionHeader block ) ) //ruleblock
        int alt2=3;
        switch ([input LA:1]) {
        	case SimpleCTP_VAR_DEF:
        		alt2 = 1;
        		break;
        	case SimpleCTP_FUNC_DECL:
        		alt2 = 2;
        		break;
        	case SimpleCTP_FUNC_DEF:
        		alt2 = 3;
        		break;
        default:
         {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException exceptionWithDecision:2 state:0 stream:input];
        	@throw nvae;

        	}}
        switch (alt2) {
        	case 1 :
        	    // SimpleCTP.gtp:13:9: variable // alt
        	    {
        	    [[_state following] addObject:FOLLOW_variable_in_declaration58];
        	    [self variable];
        	    [[_state following] removeLastObject];



        	    }
        	    break;
        	case 2 :
        	    // SimpleCTP.gtp:14:9: ^( FUNC_DECL functionHeader ) // alt
        	    {
        	    [self match:input tokenType:SimpleCTP_FUNC_DECL follow:FOLLOW_SimpleCTP_FUNC_DECL_in_declaration69]; 

        	    [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
        	    [[_state following] addObject:FOLLOW_functionHeader_in_declaration71];
        	    [self functionHeader];
        	    [[_state following] removeLastObject];



        	    [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 

        	    }
        	    break;
        	case 3 :
        	    // SimpleCTP.gtp:15:9: ^( FUNC_DEF functionHeader block ) // alt
        	    {
        	    [self match:input tokenType:SimpleCTP_FUNC_DEF follow:FOLLOW_SimpleCTP_FUNC_DEF_in_declaration83]; 

        	    [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
        	    [[_state following] addObject:FOLLOW_functionHeader_in_declaration85];
        	    [self functionHeader];
        	    [[_state following] removeLastObject];


        	    [[_state following] addObject:FOLLOW_block_in_declaration87];
        	    [self block];
        	    [[_state following] removeLastObject];



        	    [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 

        	    }
        	    break;

        }
    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end declaration

// $ANTLR start variable
// SimpleCTP.gtp:18:1: variable : ^( VAR_DEF type declarator ) ;
- (void) variable
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:19:5: ( ^( VAR_DEF type declarator ) ) // ruleBlockSingleAlt
        // SimpleCTP.gtp:19:9: ^( VAR_DEF type declarator ) // alt
        {
        [self match:input tokenType:SimpleCTP_VAR_DEF follow:FOLLOW_SimpleCTP_VAR_DEF_in_variable108]; 

        [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
        [[_state following] addObject:FOLLOW_type_in_variable110];
        [self type];
        [[_state following] removeLastObject];


        [[_state following] addObject:FOLLOW_declarator_in_variable112];
        [self declarator];
        [[_state following] removeLastObject];



        [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 

        }

    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end variable

// $ANTLR start declarator
// SimpleCTP.gtp:22:1: declarator : ID ;
- (void) declarator
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:23:5: ( ID ) // ruleBlockSingleAlt
        // SimpleCTP.gtp:23:9: ID // alt
        {
        [self match:input tokenType:SimpleCTP_ID follow:FOLLOW_SimpleCTP_ID_in_declarator132]; 

        }

    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end declarator

// $ANTLR start functionHeader
// SimpleCTP.gtp:26:1: functionHeader : ^( FUNC_HDR type ID ( formalParameter )+ ) ;
- (void) functionHeader
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:27:5: ( ^( FUNC_HDR type ID ( formalParameter )+ ) ) // ruleBlockSingleAlt
        // SimpleCTP.gtp:27:9: ^( FUNC_HDR type ID ( formalParameter )+ ) // alt
        {
        [self match:input tokenType:SimpleCTP_FUNC_HDR follow:FOLLOW_SimpleCTP_FUNC_HDR_in_functionHeader153]; 

        [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
        [[_state following] addObject:FOLLOW_type_in_functionHeader155];
        [self type];
        [[_state following] removeLastObject];


        [self match:input tokenType:SimpleCTP_ID follow:FOLLOW_SimpleCTP_ID_in_functionHeader157]; 
        // SimpleCTP.gtp:27:28: ( formalParameter )+	// positiveClosureBlock
        int cnt3=0;

        do {
            int alt3=2;
            {
            	int LA3_0 = [input LA:1];
            	if ( LA3_0==SimpleCTP_ARG_DEF ) {
            		alt3 = 1;
            	}

            }
            switch (alt3) {
        	case 1 :
        	    // SimpleCTP.gtp:27:28: formalParameter // alt
        	    {
        	    [[_state following] addObject:FOLLOW_formalParameter_in_functionHeader159];
        	    [self formalParameter];
        	    [[_state following] removeLastObject];



        	    }
        	    break;

        	default :
        	    if ( cnt3 >= 1 )  goto loop3;
        			ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:3];
        			@throw eee;
            }
            cnt3++;
        } while (YES); loop3: ;


        [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 

        }

    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end functionHeader

// $ANTLR start formalParameter
// SimpleCTP.gtp:30:1: formalParameter : ^( ARG_DEF type declarator ) ;
- (void) formalParameter
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:31:5: ( ^( ARG_DEF type declarator ) ) // ruleBlockSingleAlt
        // SimpleCTP.gtp:31:9: ^( ARG_DEF type declarator ) // alt
        {
        [self match:input tokenType:SimpleCTP_ARG_DEF follow:FOLLOW_SimpleCTP_ARG_DEF_in_formalParameter181]; 

        [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
        [[_state following] addObject:FOLLOW_type_in_formalParameter183];
        [self type];
        [[_state following] removeLastObject];


        [[_state following] addObject:FOLLOW_declarator_in_formalParameter185];
        [self declarator];
        [[_state following] removeLastObject];



        [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 

        }

    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end formalParameter

// $ANTLR start type
// SimpleCTP.gtp:34:1: type : ( 'int' | 'char' | 'void' | ID );
- (void) type
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:35:5: ( 'int' | 'char' | 'void' | ID ) // ruleBlockSingleAlt
        // SimpleCTP.gtp: // alt
        {
        if ([input LA:1]==SimpleCTP_ID||([input LA:1]>=SimpleCTP_INT_TYPE && [input LA:1]<=SimpleCTP_VOID)) {
        	[input consume];
        	[_state setIsErrorRecovery:NO];
        } else {
        	ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
        	[self recoverFromMismatchedSet:input exception:mse follow:FOLLOW_set_in_type0];	@throw mse;
        }


        }

    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end type

// $ANTLR start block
// SimpleCTP.gtp:41:1: block : ^( BLOCK ( variable )* ( stat )* ) ;
- (void) block
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:42:5: ( ^( BLOCK ( variable )* ( stat )* ) ) // ruleBlockSingleAlt
        // SimpleCTP.gtp:42:9: ^( BLOCK ( variable )* ( stat )* ) // alt
        {
        [self match:input tokenType:SimpleCTP_BLOCK follow:FOLLOW_SimpleCTP_BLOCK_in_block268]; 

        if ( [input LA:1] == ANTLRTokenTypeDOWN ) {
            [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
            do {
                int alt4=2;
                {
                	int LA4_0 = [input LA:1];
                	if ( LA4_0==SimpleCTP_VAR_DEF ) {
                		alt4 = 1;
                	}

                }
                switch (alt4) {
            	case 1 :
            	    // SimpleCTP.gtp:42:17: variable // alt
            	    {
            	    [[_state following] addObject:FOLLOW_variable_in_block270];
            	    [self variable];
            	    [[_state following] removeLastObject];



            	    }
            	    break;

            	default :
            	    goto loop4;
                }
            } while (YES); loop4: ;

            do {
                int alt5=2;
                {
                	int LA5_0 = [input LA:1];
                	if ( (LA5_0>=SimpleCTP_BLOCK && LA5_0<=SimpleCTP_FOR)||(LA5_0>=SimpleCTP_EQEQ && LA5_0<=SimpleCTP_PLUS) ) {
                		alt5 = 1;
                	}

                }
                switch (alt5) {
            	case 1 :
            	    // SimpleCTP.gtp:42:27: stat // alt
            	    {
            	    [[_state following] addObject:FOLLOW_stat_in_block273];
            	    [self stat];
            	    [[_state following] removeLastObject];



            	    }
            	    break;

            	default :
            	    goto loop5;
                }
            } while (YES); loop5: ;


            [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 
        }

        }

    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end block

// $ANTLR start stat
// SimpleCTP.gtp:45:1: stat : ( forStat | expr | block );
- (void) stat
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:45:5: ( forStat | expr | block ) //ruleblock
        int alt6=3;
        switch ([input LA:1]) {
        	case SimpleCTP_FOR:
        		alt6 = 1;
        		break;
        	case SimpleCTP_ID:
        	case SimpleCTP_EQ:
        	case SimpleCTP_INT:
        	case SimpleCTP_EQEQ:
        	case SimpleCTP_LT:
        	case SimpleCTP_PLUS:
        		alt6 = 2;
        		break;
        	case SimpleCTP_BLOCK:
        		alt6 = 3;
        		break;
        default:
         {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException exceptionWithDecision:6 state:0 stream:input];
        	@throw nvae;

        	}}
        switch (alt6) {
        	case 1 :
        	    // SimpleCTP.gtp:45:7: forStat // alt
        	    {
        	    [[_state following] addObject:FOLLOW_forStat_in_stat287];
        	    [self forStat];
        	    [[_state following] removeLastObject];



        	    }
        	    break;
        	case 2 :
        	    // SimpleCTP.gtp:46:7: expr // alt
        	    {
        	    [[_state following] addObject:FOLLOW_expr_in_stat295];
        	    [self expr];
        	    [[_state following] removeLastObject];



        	    }
        	    break;
        	case 3 :
        	    // SimpleCTP.gtp:47:7: block // alt
        	    {
        	    [[_state following] addObject:FOLLOW_block_in_stat303];
        	    [self block];
        	    [[_state following] removeLastObject];



        	    }
        	    break;

        }
    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end stat

// $ANTLR start forStat
// SimpleCTP.gtp:50:1: forStat : ^( 'for' expr expr expr block ) ;
- (void) forStat
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:51:5: ( ^( 'for' expr expr expr block ) ) // ruleBlockSingleAlt
        // SimpleCTP.gtp:51:9: ^( 'for' expr expr expr block ) // alt
        {
        [self match:input tokenType:SimpleCTP_FOR follow:FOLLOW_SimpleCTP_FOR_in_forStat323]; 

        [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
        [[_state following] addObject:FOLLOW_expr_in_forStat325];
        [self expr];
        [[_state following] removeLastObject];


        [[_state following] addObject:FOLLOW_expr_in_forStat327];
        [self expr];
        [[_state following] removeLastObject];


        [[_state following] addObject:FOLLOW_expr_in_forStat329];
        [self expr];
        [[_state following] removeLastObject];


        [[_state following] addObject:FOLLOW_block_in_forStat331];
        [self block];
        [[_state following] removeLastObject];



        [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 

        }

    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end forStat

// $ANTLR start expr
// SimpleCTP.gtp:54:1: expr : ( ^( EQEQ expr expr ) | ^( LT expr expr ) | ^( PLUS expr expr ) | ^( EQ ID e= expr ) | atom );
- (SimpleCTP_expr_return *) expr
{
    ANTLRBaseRecognizerState *_state = [self state];
    SimpleCTP_expr_return * _retval = [[[SimpleCTP_expr_return alloc] init] autorelease];
    [_retval setStart:[input LT:1]];

    id _ID1 = nil;
    SimpleCTP_expr_return * _e = nil;


    @try {
        // SimpleCTP.gtp:54:5: ( ^( EQEQ expr expr ) | ^( LT expr expr ) | ^( PLUS expr expr ) | ^( EQ ID e= expr ) | atom ) //ruleblock
        int alt7=5;
        switch ([input LA:1]) {
        	case SimpleCTP_EQEQ:
        		alt7 = 1;
        		break;
        	case SimpleCTP_LT:
        		alt7 = 2;
        		break;
        	case SimpleCTP_PLUS:
        		alt7 = 3;
        		break;
        	case SimpleCTP_EQ:
        		alt7 = 4;
        		break;
        	case SimpleCTP_ID:
        	case SimpleCTP_INT:
        		alt7 = 5;
        		break;
        default:
         {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException exceptionWithDecision:7 state:0 stream:input];
        	@throw nvae;

        	}}
        switch (alt7) {
        	case 1 :
        	    // SimpleCTP.gtp:54:9: ^( EQEQ expr expr ) // alt
        	    {
        	    [self match:input tokenType:SimpleCTP_EQEQ follow:FOLLOW_SimpleCTP_EQEQ_in_expr347]; 

        	    [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
        	    [[_state following] addObject:FOLLOW_expr_in_expr349];
        	    [self expr];
        	    [[_state following] removeLastObject];


        	    [[_state following] addObject:FOLLOW_expr_in_expr351];
        	    [self expr];
        	    [[_state following] removeLastObject];



        	    [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 

        	    }
        	    break;
        	case 2 :
        	    // SimpleCTP.gtp:55:9: ^( LT expr expr ) // alt
        	    {
        	    [self match:input tokenType:SimpleCTP_LT follow:FOLLOW_SimpleCTP_LT_in_expr363]; 

        	    [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
        	    [[_state following] addObject:FOLLOW_expr_in_expr365];
        	    [self expr];
        	    [[_state following] removeLastObject];


        	    [[_state following] addObject:FOLLOW_expr_in_expr367];
        	    [self expr];
        	    [[_state following] removeLastObject];



        	    [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 

        	    }
        	    break;
        	case 3 :
        	    // SimpleCTP.gtp:56:9: ^( PLUS expr expr ) // alt
        	    {
        	    [self match:input tokenType:SimpleCTP_PLUS follow:FOLLOW_SimpleCTP_PLUS_in_expr379]; 

        	    [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
        	    [[_state following] addObject:FOLLOW_expr_in_expr381];
        	    [self expr];
        	    [[_state following] removeLastObject];


        	    [[_state following] addObject:FOLLOW_expr_in_expr383];
        	    [self expr];
        	    [[_state following] removeLastObject];



        	    [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 

        	    }
        	    break;
        	case 4 :
        	    // SimpleCTP.gtp:57:9: ^( EQ ID e= expr ) // alt
        	    {
        	    [self match:input tokenType:SimpleCTP_EQ follow:FOLLOW_SimpleCTP_EQ_in_expr395]; 

        	    [self match:input tokenType:ANTLRTokenTypeDOWN follow:nil]; 
        	    _ID1=(id)[input LT:1];
        	    [self match:input tokenType:SimpleCTP_ID follow:FOLLOW_SimpleCTP_ID_in_expr397]; 
        	    [[_state following] addObject:FOLLOW_expr_in_expr401];
        	    _e = [self expr];
        	    [[_state following] removeLastObject];



        	    [self match:input tokenType:ANTLRTokenTypeUP follow:nil]; 
        	     NSLog(@"assigning %@ to variable %@", [[input treeAdaptor] textForNode:[_e start]], [_ID1 text]); 

        	    }
        	    break;
        	case 5 :
        	    // SimpleCTP.gtp:58:9: atom // alt
        	    {
        	    [[_state following] addObject:FOLLOW_atom_in_expr414];
        	    [self atom];
        	    [[_state following] removeLastObject];



        	    }
        	    break;

        }
    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return _retval;
}
// $ANTLR end expr

// $ANTLR start atom
// SimpleCTP.gtp:61:1: atom : ( ID | INT );
- (void) atom
{
    ANTLRBaseRecognizerState *_state = [self state];
    @try {
        // SimpleCTP.gtp:62:5: ( ID | INT ) // ruleBlockSingleAlt
        // SimpleCTP.gtp: // alt
        {
        if ([input LA:1]==SimpleCTP_ID||[input LA:1]==SimpleCTP_INT) {
        	[input consume];
        	[_state setIsErrorRecovery:NO];
        } else {
        	ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
        	[self recoverFromMismatchedSet:input exception:mse follow:FOLLOW_set_in_atom0];	@throw mse;
        }


        }

    }
	@catch (ANTLRRecognitionException *re) {
		[self reportError:re];
		[self recover:input exception:re];
	}
	@finally {
		// token+rule list labels

	}
	return ;
}
// $ANTLR end atom



@end